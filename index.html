<!DOCTYPE html>
<html lang="en">
<head>

  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <script>
    (function () {
      try {
        const savedTheme = localStorage.getItem("studyai-theme");
        const prefersDark =
          window.matchMedia &&
          window.matchMedia("(prefers-color-scheme: dark)").matches;

        const theme = savedTheme || (prefersDark ? "dark" : "light");
        document.documentElement.setAttribute("data-theme", theme);
      } catch (e) {
        // fallback if localStorage is blocked
        document.documentElement.setAttribute("data-theme", "dark");
      }
    })();
  </script>
  
  <title>Passing Grade</title>
   <!-- Tell Safari/Chrome we support both themes -->
  <meta name="color-scheme" content="light dark" />

  <!-- Browser / status bar color (will be updated by JS) -->
  <meta name="theme-color" content="#020617" id="meta-theme-color" />

  <!-- Optional iOS standalone app styling -->
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />


  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Passing Grade</title>

  <!-- Google Fonts + Material Icons -->
  <link
    rel="stylesheet"
    href="https://fonts.googleapis.com/css2?family=Outfit:wght@500;600;700&family=DM+Sans:wght@400;500;600&family=Material+Symbols+Outlined:wght@400&display=swap"
  />
<!-- FAVICONS -->
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/icon-16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/icon-32.png">
<link rel="icon" type="image/png" sizes="48x48" href="/icon-48.png">
<link rel="apple-touch-icon" sizes="180x180" href="/icon-180.png">
<link rel="icon" type="image/png" sizes="192x192" href="/icon-192.png">




<style>
  :root {
    /* ===== Design tokens: easy to tweak ===== */
    /* Core colors (Vercel-ish, neutral) */
    --primary: #111827;
    --primary-variant: #0ea5e9;
    --on-primary: #ffffff;

    --surface-dark: #020617;
    --surface-light: #fafafa;
    --surface-elevated-dark: #020617;
    --surface-elevated-light: #ffffff;

    --on-surface-dark: #e5e7eb;
    --on-surface-light: #0f172a;

    --outline-dark: rgba(148, 163, 184, 0.35);
    --outline-light: #e4e4e7;

    --radius-lg: 6px;
    --radius-md: 6px;
    --radius-pill: 6px;
    --transition-fast: 0.16s ease-out;

    /* Buttons – outline (white) + solid (black) */
    --btn-bg-light: #ffffff;
    --btn-fg-light: #111827;
    --btn-bg-dark: #111827;
    --btn-fg-dark: #f9fafb;

    --btn-bg-active-light: #f4f4f5;
    --btn-fg-active-light: #111827;
    --btn-bg-active-dark: #030712;
    --btn-fg-active-dark: #f9fafb;

    --btn-solid-bg: #111827;  /* Vercel black button */
    --btn-solid-fg: #f9fafb;
    --btn-solid-hover-bg: #000000;

    --font-sans: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
      sans-serif;
  }

  [data-theme="dark"] {
    --surface: var(--surface-dark);
    --card-bg: var(--surface-elevated-dark);
    --on-surface: var(--on-surface-dark);
    --outline: var(--outline-dark);
    --field-bg: rgba(15, 23, 42, 0.95);
    --chip-bg: #020617;
    --code-bg: #020617;
    --code-fg: #e5e7eb;
    --muted: #9ca3af;
    --header-bg: radial-gradient(circle at top left, #111827, #020617);
    --sidebar-bg: #020617;

    --btn-bg: var(--btn-bg-dark);
    --btn-fg: var(--btn-fg-dark);
    --btn-bg-active: var(--btn-bg-active-dark);
    --btn-fg-active: var(--btn-fg-active-dark);
  }

  [data-theme="light"] {
    --surface: var(--surface-light);
    --card-bg: var(--surface-elevated-light);
    --on-surface: var(--on-surface-light);
    --outline: var(--outline-light);
    --field-bg: #ffffff;
    --chip-bg: #f4f4f5;
    --code-bg: #ffffff;
    --code-fg: #020617;
    --muted: #000;
    --header-bg: #ffffff;
    --sidebar-bg: #f9fafb;

    --btn-bg: var(--btn-bg-light);          /* white outline style */
    --btn-fg: var(--btn-fg-light);          /* black text */
    --btn-bg-active: var(--btn-bg-active-light);
    --btn-fg-active: var(--btn-fg-active-light);
  }

  * {
    box-sizing: border-box;
  }

  body {
    margin: 0;
    font-family: var(--font-sans);
    background: var(--surface);
    color: var(--on-surface);
    min-height: 100vh;
    display: flex;
    justify-content: center;
    padding-top: 0.75rem;
  }

  .app {
    width: 100%;
    max-width: 980px;
    min-height: 100vh;
    padding: 14px 14px 18px;
    display: flex;
    flex-direction: column;
    gap: 10px;
  }

  header {
    background: var(--card-bg);
    border-radius: var(--radius-lg);
    padding: 20px 18px;
    border: 1px solid var(--outline);
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 10px;
  }

  .title-block {
    display: flex;
    flex-direction: column;
    gap: 5px;
  }

  .title-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 1rem;
  }

  .title-block h1 {
    margin: 0;
    font-family: var(--font-sans);
    font-size: 1.4rem;
    letter-spacing: 0.02em;
    display: flex;
    align-items: center;
    gap: 8px;
    font-weight: 600;
  }

  .visually-hidden {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
  }

  /* Show correct logo per theme */
  html[data-theme="light"] .brand-logo-light {
    display: block;
  }
  html[data-theme="light"] .brand-logo-dark {
    display: none;
  }
  html[data-theme="dark"] .brand-logo-light {
    display: none;
  }
  html[data-theme="dark"] .brand-logo-dark {
    display: block;
  }

  .brand-logo-wrap {
    display: flex;
    align-items: center;
    flex: 0 1 auto;
  }

  .brand-logo {
    display: block;
    height: 40px;
    width: auto;
  }

  .header-subline {
    margin-top: 0.35rem;
    font-size: 0.9rem;
    line-height: 1.4;
    color: #4b5563;
  }

  .header-right {
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 6px;
  }

  .header-top-row {
    display: flex;
    align-items: center;
    gap: 10px;
  }

  /* ---- Auth status + sign-in button ---- */
  .auth-row {
    margin-top: 4px;
    display: flex;
    align-items: center;
    justify-content: flex-end;
    gap: 8px;
    flex-wrap: wrap;
    font-size: 0.75rem;
    color: var(--muted);

  }

  .user-plan-label {
    white-space: nowrap;
  }

  .auth-button {
    border-radius: var(--radius-pill);
    border: 1px solid var(--outline);
    padding: 6px 12px;
    font-size: 0.78rem;
    background: transparent;
    color: var(--on-surface);
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    gap: 6px;
    box-shadow: none;
  }

  .auth-button:hover {
    border-color: var(--primary);
    background: rgba(15, 23, 42, 0.04);
  }

  .chip {
    font-size: 0.74rem;
    padding: 5px 12px;
    border-radius: var(--radius-pill);
    border: 1px solid var(--outline);
    background: var(--chip-bg);
    color: var(--muted);
    display: inline-flex;
    align-items: center;
    gap: 7px;
    white-space: nowrap;
    cursor: pointer;
    user-select: none;
  }

  .chip-dot {
    width: 9px;
    height: 9px;
    border-radius: var(--radius-pill);
    background: #22c55e;
    box-shadow: 0 0 6px rgba(34, 197, 94, 0.7);
  }

  .theme-toggle,
  .drawer-toggle {
    border-radius: var(--radius-pill);
    border: 1px solid var(--outline);
    padding: 7px 13px;
    background: var(--card-bg);
    display: inline-flex;
    align-items: center;
    gap: 8px;
    font-size: 0.78rem;
    color: var(--on-surface);
    cursor: pointer;
    transition:
      border-color var(--transition-fast),
      color var(--transition-fast),
      background var(--transition-fast),
      transform 0.08s ease-out;
  }

  .theme-toggle svg {
    width: 18px;
    height: 18px;
  }

  .drawer-toggle .material-symbols-outlined {
    font-size: 20px;
  }

  .theme-toggle:hover,
  .drawer-toggle:hover {
    border-color: transparent;
    background: var(--btn-bg-active);
    color: var(--btn-fg-active);
    transform: translateY(-1px);
  }

  .top-bar {
    display: flex;
    gap: 8px;
    margin: 2px 0 4px;
  }

  select {
    border-radius: var(--radius-pill);
    border: 1px solid var(--outline);
    background: var(--card-bg);
    color: var(--on-surface);
    font-size: 0.9rem;
    padding: 11px 12px;
    outline: none;
  }

  .top-bar select {
    flex: 1;
  }

  .main-layout {
    display: flex;
    gap: 12px;
    flex: 1;
    min-height: 0;
    margin-top: 4px;
  }

  .content {
    flex: 1;
    min-width: 0;
  }

  .card {
    background: var(--card-bg);
    border-radius: var(--radius-md);
    border: 1px solid var(--outline);
    padding: 14px;
    margin-bottom: 10px;
  }

  .card h2 {
    margin: 0 0 4px;
    font-family: var(--font-sans);
    font-size: 1.05rem;
    font-weight: 600;
    letter-spacing: 0.01em;
  }

  .desc {
    margin: 0 0 10px;
    font-size: 0.8rem;
    color: var(--muted);
  }

  .tab-content {
    display: none;
  }

  .tab-content.active {
    display: block;
  }

  label {
    display: block;
    font-size: 0.78rem;
    color: var(--muted);
    margin-bottom: 4px;
  }

  /* ===== Text inputs ===== */

  textarea {
    width: 100%;
    font-family: inherit;
    font-size: 0.9rem;
    padding: 10px 12px;
    border-radius: 6px;
    border: 1px solid var(--outline);
    background: var(--field-bg);
    color: var(--on-surface);
    outline: none;
    resize: vertical;
    min-height: 120px;
    transition:
      border-color var(--transition-fast),
      box-shadow var(--transition-fast),
      background var(--transition-fast);
  }

  input[type="file"],
  input[type="text"] {
    margin-top: 0.5em;
    width: 100%;
    font-family: inherit;
    font-size: 0.9rem;
    padding: 10px 12px;
    border-radius: 6px;
    border: 1px solid var(--outline);
    background: var(--field-bg);
    color: var(--on-surface);
    outline: none;
    min-height: 44px;
    transition:
      border-color var(--transition-fast),
      box-shadow var(--transition-fast),
      background var(--transition-fast);
  }

  .text-input {
    background: var(--field-bg);
    color: var(--on-surface);
  }

  input[type="file"] {
    min-height: auto;
    padding: 8px;
    cursor: pointer;
    font-size: 0.8rem;
  }

  textarea:focus,
  input:focus {
    border-color: var(--primary);
    box-shadow: 0 0 0 1px rgba(15, 23, 42, 0.12);
    background: #ffffff05;
  }

  .btn-row {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-top: 9px;
    margin-bottom: 15px;
    justify-content: flex-end;
  }

  /* ===== Base button (white outline style) ===== */
  button {
    border-radius: var(--radius-pill);
    border: 1px solid var(--outline);
    padding: 9px 16px;
    font-size: 0.85rem;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    gap: 7px;
    background: var(--btn-bg);
    color: var(--btn-fg);
    transition:
      transform 0.08s ease-out,
      box-shadow 0.08s ease-out,
      opacity 0.08s,
      background 0.12s ease-out,
      color 0.12s ease-out,
      border-color 0.12s ease-out;
    font-weight: 500;
  }

  button:hover {
    background: var(--btn-bg-active);
    color: var(--btn-fg-active);
    border-color: #d4d4d8;
    box-shadow: 0 6px 18px rgba(15, 23, 42, 0.06);
  }

  button.secondary {
    background: var(--btn-bg);
    color: var(--btn-fg);
    box-shadow: none;
    border: 1px solid var(--outline);
  }

  button:active {
    transform: translateY(1px) scale(0.99);
    opacity: 0.96;
    box-shadow: 0 6px 14px rgba(15, 23, 42, 0.25);
  }

  .hint-row {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    margin-top: 6px;
    justify-content: flex-end;
  }

  .hint-row button {
        font-size: 0.9rem;
    padding: 12px;
  }

  /* ===== Text outputs ===== */

  pre {
    margin-top: 8px;
    background: var(--code-bg);
    color: var(--code-fg);
    border-radius: 6px;
    padding: 14px 16px;
    font-size: 0.9rem;
    line-height: 1.6;
    max-height: 260px;
    overflow: auto;
    border: 1px solid rgba(148, 163, 184, 0.4);
    white-space: pre-wrap;
    word-wrap: break-word;
  }

  .text-output {
    background: var(--code-bg);
    color: var(--code-fg);
  }

  pre .step-line {
    display: block;
    font-weight: 700;
    margin: 6px 0 2px;
  }

  pre .answer-label {
    font-weight: 600;
  }

  pre .answer-value {
    font-weight: 700;
  }

  pre .hint-label {
    display: block;
    margin-top: 10px;
    font-size: 0.8rem;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    opacity: 0.8;
  }

  pre .section-heading {
    display: block;
    margin-top: 10px;
    margin-bottom: 4px;
    font-weight: 700;
    font-size: 0.85rem;
    text-transform: uppercase;
    letter-spacing: 0.08em;
  }

  .pill-button {
    border-radius: var(--radius-pill);
    border: 1px solid var(--outline);
    padding: 12px;
    font-size: 0.9rem;
    background: var(--btn-bg);
    color: var(--btn-fg);
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    gap: 5px;
  }

  .pill-button.active,
  .nav-btn.active,
  .notebook-filter.active {
    background: var(--btn-bg-active);
    color: var(--btn-fg-active);
    border-color: var(--primary);
  }

  .material-symbols-outlined {
    font-family: "Material Symbols Outlined";
    font-weight: normal;
    font-style: normal;
    font-size: 20px;
    line-height: 1;
    letter-spacing: normal;
    text-transform: none;
    display: inline-block;
    white-space: nowrap;
    word-wrap: normal;
    direction: ltr;
    -webkit-font-feature-settings: "liga";
    -webkit-font-smoothing: antialiased;
    font-variation-settings:
      "FILL" 0,
      "wght" 400,
      "GRAD" 0,
      "opsz" 24;
  }

  .hint-footer {
    margin-top: 8px;
    font-size: 0.7rem;
    color: var(--muted);
    text-align: left;
  }

  .notebook-item {
    padding: 8px;
    border-radius: 6px;
    border: 1px solid rgba(148, 163, 184, 0.7);
    margin-bottom: 6px;
    font-size: 0.8rem;
    background: rgba(15, 23, 42, 0.03);
    line-height: 1.5;
  }

  [data-theme="light"] .notebook-item {
    background: #f9fafb;
  }

  .notebook-item small {
    display: block;
    color: var(--muted);
    margin-bottom: 2px;
    font-size: 0.7rem;
  }

  .notebook-item-header {
    display: flex;
    justify-content: space-between;
    gap: 6px;
    margin-bottom: 6px;
  }

  .notebook-meta {
    font-size: 0.9rem;
    text-transform: uppercase;
    letter-spacing: 0.09em;
    font-weight: 600;
    color: var(--primary-variant);
  }

  .notebook-actions {
    display: inline-flex;
    gap: 4px;
    flex-wrap: wrap;
  }

  .notebook-actions button {
    box-shadow: none;
    padding: 3px 8px;
    font-size: 0.7rem;
  }

  .notebook-item > div:last-child {
    font-size: 0.82rem;
    color: var(--on-surface);
    white-space: pre-wrap;
  }

  .flashcard {
    margin-top: 8px;
    padding: 14px 12px;
    border-radius: 6px;
    border: 1px solid rgb(157, 157, 157);
    background: var(--field-bg);
    min-height: 80px;
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
    transition: transform 0.3s ease;
    transform-origin: center;
  }

  .flashcard.flipping {
    transform: rotateY(180deg);
  }

  .flashcard-side {
    font-size: 0.9rem;
    white-space: pre-wrap;
    word-wrap: break-word;
    width: 100%;
    line-height: 1.6;
    text-align: center;
  }

  #cardsStats {
    font-size: 0.78rem;
    margin-bottom: 6px;
    opacity: 0.85;
    text-align: center;
  }

  #cardsCard.flashcard {
    border-width: 1px;
    padding: 5em 1em;
  }

  #cardsFront {
    font-weight: 700;
    color: #25ae4a;
    font-size: 1.02em;
  }

  #cardsBack {
    font-weight: 500;
    color: var(--on-surface);
    opacity: 1;
  }

  .side-drawer {
    width: 220px;
    background: var(--sidebar-bg);
    border-left: 1px solid rgba(148, 163, 184, 0.5);
    border-radius: 6px;
    box-shadow: 0 0 30px rgba(0, 0, 0, 0.45);
    position: fixed;
    top: 10px;
    right: 10px;
    height: calc(100vh - 20px);
    transform: translateX(110%);
    transition: transform 0.18s ease-out;
    z-index: 30;
    display: flex;
    flex-direction: column;
  }

  .side-drawer.open {
    transform: translateX(0);
  }

  .side-drawer-inner {
    padding: 12px 10px 10px;
    display: flex;
    flex-direction: column;
    height: 100%;
  }

  .side-drawer-header {
    font-size: 0.7rem;
    text-transform: uppercase;
    letter-spacing: 0.09em;
    color: var(--muted);
    margin-bottom: 6px;
    padding: 0 6px;
  }

  .side-nav {
    display: flex;
    flex-direction: column;
    gap: 4px;
    overflow-y: auto;
    padding-right: 4px;
    margin-top: 2px;
  }

  .nav-btn {
    border-radius: var(--radius-pill);
    border: 1px solid var(--outline);
    background: var(--btn-bg);
    color: var(--btn-fg);
    font-size: 0.9rem;
    display: flex;
    align-items: center;
    gap: 9px;
    padding: 11px 12px;
    cursor: pointer;
    text-align: left;
    transition:
      background var(--transition-fast),
      color var(--transition-fast),
      transform 0.06s ease-out;
  }

  .nav-btn .material-symbols-outlined {
    font-size: 20px;
  }

  .nav-btn span.label {
    flex: 1;
  }

  .drawer-backdrop.show {
    display: block;
  }

  @media (min-width: 700px) {
    .app {
      padding-bottom: 18px;
    }

    .main-layout {
      display: flex;
    }


    .side-drawer {
      position: static;
      height: auto;
      transform: none !important;
      box-shadow: none;
      border-radius: 6px;
      max-height: none;
      width: 230px;
    }

    .side-drawer-inner {
      height: auto;
      max-height: calc(100vh - 120px);
    }

    .drawer-backdrop {
      display: none !important;
    }

    .drawer-toggle {
      display: none;
    }
  }

  [data-theme="light"] .side-drawer {
    background: #ffffff;
  }

  [data-theme="dark"] .side-drawer {
    background: #020617;
  }

  .mobile-break {
    display: none;
  }

  @media (max-width: 700px) {
    header {
      position: relative;
      flex-direction: column;
      align-items: stretch;
      gap: 8px;
      padding: 16px 12px 12px;
    }

    .title-block {
      width: 100%;
    }

    .title-row {
      justify-content: flex-start;
    }

    .brand-logo {
      display: block;
      height: 30px;
      width: auto;
    }

    .brand-logo-wrap {
      display: inline-flex;
      align-items: center;
      justify-content: flex-start;
      background: transparent;
      box-shadow: none;
      height: auto;
      margin: 19px  0 6px 0;
    }

    .subtitle {
      font-size: 0.85rem;
      color: var(--muted);
    }

    .header-right {
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin-top: 4px;
      padding-top: 10px;
    }

    .auth-row {
      width: 100%;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: flex-end;
      gap: 6px;
      font-size: 0.75rem;
    }

    #userPlanLabel {
      flex: 1 1 100%;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      text-align: right;
      line-height: 1.3;
    }



    .chip.learn-mode {
      flex: 0 0 auto;
      padding: 4px 10px;
      font-size: 0.74rem;
      white-space: nowrap;
    }

    .theme-toggle,
    .drawer-toggle {
      flex: 0 0 auto;
      padding: 6px;
      min-width: 40px;
      justify-content: center;
      font-size: 0.8rem;
    }

    [data-theme="dark"] .brand-logo {
      filter: brightness(1.08);
    }
  }

  /* ---- Subtle "completed" pulse animation ---- */
  @keyframes pulse-highlight {
    0% {
      box-shadow: 0 0 0 0 rgba(15, 23, 42, 0);
      transform: scale(1);
    }
    35% {
      box-shadow: 0 0 0 4px rgba(15, 23, 42, 0.25);
      transform: scale(1.01);
    }
    100% {
      box-shadow: 0 0 0 0 rgba(15, 23, 42, 0);
      transform: scale(1);
    }
  }

  .pulse-once {
    animation: pulse-highlight 0.7s ease-out;
  }

  .notebook-filter {
    opacity: 0.85;
  }

  .notebook-filter.active {
    opacity: 1;
    box-shadow: 0 0 0 1px rgba(59, 130, 246, 0.4);
  }

  .notebook-filter.active .material-symbols-outlined {
    color: inherit;
  }

  .notebook-subject-row {
    position: relative;
    display: inline-flex;
    align-items: center;
    gap: 4px;
    margin-bottom: 4px;
  }

  .notebook-subject-btn {
    padding: 4px 10px;
    border-radius: var(--radius-pill);
    border: 1px solid var(--outline);
    background: var(--field-bg);
    font-size: 0.78rem;
    font-weight: 600;
    cursor: pointer;
  }

  .notebook-subject-btn.active {
    border-color: var(--primary);
    background: var(--btn-bg-active);
    color: var(--btn-fg-active);
  }

  .notebook-subject-menu {
    padding: 2px 8px;
    min-width: auto;
  }

  .notebook-subject-edit,
  .notebook-subject-delete {
    display: none;
    padding: 2px 6px;
    border-radius: var(--radius-pill);
    border: 1px solid transparent;
    background: transparent;
    font-size: 0.7rem;
    opacity: 0.7;
    cursor: pointer;
  }

  .notebook-subject-dropdown {
    display: none;
    position: absolute;
    right: 0;
    top: 110%;
    background: var(--surface);
    border: 1px solid var(--outline);
    border-radius: 6px;
    padding: 6px;
    box-shadow: 0 8px 20px rgba(15, 23, 42, 0.25);
    z-index: 30;
    min-width: 170px;
    flex-direction: column;
    gap: 6px;
  }

  .notebook-subject-dropdown .notebook-subject-edit,
  .notebook-subject-dropdown .notebook-subject-delete {
    display: flex;
    width: 100%;
    justify-content: flex-start;
    font-size: 0.78rem;
    padding: 6px 10px;
    border-radius: var(--radius-pill);
    border: 1px solid transparent;
    background: var(--btn-bg);
    gap: 6px;
  }

  .notebook-subject-edit {
    color: var(--on-surface);
  }

  .notebook-subject-delete {
    color: #dc2626;
  }

  .notebook-subject-edit:hover,
  .notebook-subject-delete:hover {
    opacity: 1;
    border-color: rgba(148, 163, 184, 0.5);
    background: var(--btn-bg-active);
  }

  #saveSubjectInput {
    width: 100%;
    font-family: inherit;
    font-size: 0.9rem;
    padding: 8px 10px;
    border-radius: var(--radius-pill);
    border: 1px solid var(--outline);
    background: var(--field-bg);
    color: #bbbbbb;
    outline: none;
    min-height: auto;
    height: auto;
    transition:
      border-color var(--transition-fast),
      box-shadow var(--transition-fast),
      background var(--transition-fast);
  }

  label[for="saveSubjectInput"] {
    display: block;
    width: 100%;
    text-align: left;
  }

  /* Let result boxes grow full height */
  #snapResult,
  #mathResult,
  #studyResult,
  #flashcardsResult,
  #essayResult {
    max-height: none !important;
    overflow: visible !important;
  }

  #snapText,
  #mathInput,
  #studyInput,
  #essayInput {
    max-height: none !important;
    overflow-y: hidden !important;
    resize: none;
	margin-top:.5em;
  }

  #copySnapTextBtn {
    border: 1px solid rgba(148, 163, 184, 0.6);
    background: rgba(148, 163, 184, 0.08);
    border-radius: var(--radius-pill);
    padding: 4px 6px;
    font-size: 0.7rem;
    display: inline-flex;
    align-items: center;
    gap: 4px;
    cursor: pointer;
    color: inherit;
  }

  #copySnapTextBtn .material-symbols-outlined {
    font-size: 14px;
    color: inherit;
  }

  .snap-text-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 8px;
  }

  .snap-actions-wrapper {
    justify-content: flex-start;
  }

  .snap-actions-dropdown {
    position: relative;
    display: inline-block;
    margin-left: auto;
  }

  .snap-actions-toggle {
    display: inline-flex;
    align-items: center;
    gap: 4px;
  }

  .snap-actions-menu {
    position: absolute;
    top: 100%;
    right: 0;
    margin-top: 4px;
    padding: 6px 0;
    border-radius: 6px;
    border: 1px solid var(--outline);
    background: var(--card-bg);
    box-shadow: 0 8px 20px rgba(15, 23, 42, 0.4);
    min-width: 180px;
    display: none;
    z-index: 30;
  }

  .snap-actions-menu button {
    width: 100%;
    justify-content: flex-start;
    border-radius: 6px;
    border: none;
    background: var(--btn-bg);
    color: var(--btn-fg);
  }

  .snap-actions-menu button:hover {
    background: var(--btn-bg-active);
  }

  #snapPreview {
    margin-bottom: 1em;
  }

  #textActionsDropdown .snap-actions-menu {
    top: auto;
    bottom: 100%;
    margin-top: 0;
    margin-bottom: 4px;
  }

  /* Notebook dropdown layout */
  .notebook-top-row {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-bottom: 6px;
  }

  .nb-dropdown {
    position: relative;
    display: inline-flex;
  }

  .nb-dropdown-toggle {
    display: inline-flex;
    align-items: center;
    gap: 6px;
  }

  .nb-dropdown-toggle::-webkit-details-marker {
    display: none;
  }

  .nb-dropdown-menu {
    position: absolute;
    top: calc(100% + 6px);
    left: 0;
    transform: none;
    min-width: 220px;
    padding: 10px;
    border-radius: 6px;
    background: var(--card-bg);
    border: 1px solid var(--outline);
    box-shadow: 0 10px 24px rgba(15, 23, 42, 0.35);
    z-index: 40;
    display: none;
  }

  .nb-dropdown[open] .nb-dropdown-menu {
    display: block;
  }

  .nb-dropdown-menu .hint-row {
    margin: 0;
    justify-content: flex-start;
  }

  .nb-dropdown-menu .pill-button {
    font-size: 0.76rem;
    padding: 6px 10px;
  }

  /* ==== Back / Forward tool navigation buttons ==== */
  #tabNavButtons {
    position: fixed;
    bottom: 0.75rem;
    left: 50%;
    transform: translateX(-50%);
    z-index: 50;
    display: flex;
    gap: 0.5rem;
  }

  .tab-nav-btn {
    padding: 0.35rem 0.9rem;
    border-radius: var(--radius-pill);
    border: 1px solid #e5e7eb;
    background: var(--btn-solid-bg);
    color: var(--btn-solid-fg);
    font-size: 0.8rem;
    font-weight: 500;
    display: inline-flex;
    align-items: center;
    gap: 0.25rem;
    box-shadow: 0 6px 18px rgba(15, 23, 42, 0.22);
    cursor: pointer;
  }

  .tab-nav-btn:hover {
    background: var(--btn-solid-hover-bg);
  }

  .tab-nav-btn.tab-nav-btn-disabled {
    opacity: 0.4;
    cursor: default;
    box-shadow: none;
  }

  /* ==== Extract Notes tool tweaks ==== */
  #notesResult {
    max-height: none !important;
    overflow: visible !important;
  }

  .notes-hint {
    font-size: 0.78rem;
    color: var(--muted);
    margin: 4px 0 10px;
  }

  .text-output.tool-output {
    background: var(--code-bg);
    color: var(--code-fg);
    border-color: rgba(148, 163, 184, 0.4);
  }

  .text-output.tool-output .tool-output-body {
    color: var(--code-fg);
  }

  .text-output.tool-output .tool-output-copy {
    border: 1px solid rgba(148, 163, 184, 0.6);
    background: var(--btn-bg);
    color: var(--btn-fg);
  }

  .text-output.tool-output .tool-output-copy:hover {
    background: var(--btn-bg-active);
    color: var(--btn-fg-active);
  }

  .text-output.tool-output .section-heading,
  .text-output.tool-output .step-line,
  .text-output.tool-output .answer-label,
  .text-output.tool-output .answer-value,
  .text-output.tool-output .hint-label {
    color: var(--code-fg);
  }
  /* ============================================
   DROPDOWN POSITIONING + STACKING + ANIMATION
   ============================================ */

/* Keep all dropdown panels inside the viewport */
.header-menu-inner,
.snap-actions-menu,
.nb-dropdown-menu,
.notebook-subject-dropdown {
  max-width: calc(100vw - 24px);
}

/* ----- Header "Menu" dropdown (little menu) ----- */
/* Make sure it sits on top of the big Tools menu
   and opens directly under the Menu button. */
.header-menu {
  position: relative;
}

.header-menu-inner {
  top: calc(100% + 8px) !important; /* just under the summary */
  right: 0 !important;
  left: auto !important;
  z-index: 60;                       /* above side-drawer (30) and others */
  opacity: 0;
  pointer-events: none;
  transform: translateY(4px) !important;
  transform-origin: top right;
  transition:
    opacity 0.16s ease-out,
    transform 0.16s ease-out;
}

/* Animate open/close via the <details open> state */
.header-menu[open] .header-menu-inner {
  opacity: 1;
  pointer-events: auto;
  transform: translateY(0) !important;
}

/* ----- Snap / Text actions dropdowns ----- */
/* Always open directly under their toggle and above other UI. */
.snap-actions-menu {
  top: calc(100% + 4px);
  left: 0;
  right: auto;
  z-index: 70;
  transform-origin: top left;
  transition:
    opacity 0.16s ease-out,
    transform 0.16s ease-out;
}

/* Make the Text actions dropdown open *below* as well */
#textActionsDropdown .snap-actions-menu {
  top: calc(100% + 4px);
  bottom: auto;
  margin-top: 4px;
  margin-bottom: 0;
}

/* ----- Notebook: Saved Subjects / Subjects by tools dropdowns ----- */
/* These are <details> menus, so we can animate them cleanly. */
.nb-dropdown-menu {
  top: calc(100% + 6px);
  left: 0;
  right: auto;
  z-index: 70;
  display: block;            /* show/hide handled by opacity/visibility */
  opacity: 0;
  visibility: hidden;
  pointer-events: none;
  transform: translateY(4px);
  transform-origin: top left;
  transition:
    opacity 0.16s ease-out,
    transform 0.16s ease-out,
    visibility 0.16s ease-out;
}

.nb-dropdown[open] .nb-dropdown-menu {
  opacity: 1;
  visibility: visible;
  pointer-events: auto;
  transform: translateY(0);
}

/* ----- Notebook subject "⋯" dropdown ----- */
/* Open right under the subject row, on top of everything. */
.notebook-subject-dropdown {
  top: calc(100% + 4px);
  right: 0;
  left: auto;
  z-index: 70;
  transform-origin: top right;
  transition:
    opacity 0.16s ease-out,
    transform 0.16s ease-out;
}
/* --- Ensure header mini-menu is above the side drawer --- */
.side-drawer {
  z-index: 20 !important;      /* still above page, below header menu & tab nav */
}

.header-menu-inner {
  z-index: 120 !important;     /* above side drawer and other UI */
}

/* --- Shared dropdown open animation (all menus) --- */
@keyframes dropdownFade {
  from {
    opacity: 0;
    transform: translateY(4px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Apply the same open animation to every dropdown panel */
.header-menu-inner,
.snap-actions-menu,
.nb-dropdown-menu,
.notebook-subject-dropdown {
  animation: dropdownFade 0.16s ease-out;
}

/* Keep them under their toggles & inside viewport */
.header-menu-inner,
.snap-actions-menu,
.nb-dropdown-menu,
.notebook-subject-dropdown {
  max-width: calc(100vw - 24px);
}

/* Header menu: directly under “Menu” button */
.header-menu {
  position: relative;
}
.header-menu-inner {
  top: calc(100% + 8px) !important;  /* right under the summary */
  right: 0 !important;
  left: auto !important;
  transform-origin: top right;
}

/* Snap / Text actions: always under their toggles */
.snap-actions-menu {
  top: calc(100% + 4px);
  left: 0;
  right: auto;
  transform-origin: top left;
}

/* Text actions specifically should also open below the button */
#textActionsDropdown .snap-actions-menu {
  top: calc(-700% + 4px);
  bottom: auto;
  margin-top: 4px;
  margin-bottom: 0;
}

/* Notebook details dropdowns: open under the pills */
.nb-dropdown-menu {
  top: calc(100% + 6px);
  left: 0;
  right: auto;
  transform-origin: top left;
}

/* Notebook subject “⋯” menu: under the subject row, right-aligned */
.notebook-subject-dropdown {
  top: calc(100% + 4px);
  right: 0;
  left: auto;
  transform-origin: top right;
}
/* Global text sizing for basic elements */
label,
p,
ul,
li {
  font-size: 1em;
}
/* Flashcard question text: black in light, white in dark */
:root[data-theme="light"] #cardsFront.flashcard-question-light {
  color: #000000;
}

:root[data-theme="dark"] #cardsFront.flashcard-question-dark {
  color: #ffffff;
}

/* Flashcard card background: white in light, dark in dark */
:root[data-theme="light"] #cardsCard.flashcard-card-light {
  background-color: #ffffff;
}

:root[data-theme="dark"] #cardsCard.flashcard-card-dark {
  background-color: #020617; /* or your dark card color */
}

/* ============================
   FLASHCARD "GOT IT" BURST TEXT
   ============================ */

.gotit-burst-word {
  position: fixed;
  left: 0;
  top: 0;
  transform: translate(-50%, -50%);
  font-family: var(--font-sans);
  font-weight: 800;
  font-size: 1rem;
  color: inherit;              /* inherit theme text color */
  pointer-events: none;
  z-index: 9999;
  opacity: 0;
  white-space: nowrap;
  user-select: none;
}

/* main rise + fade animation for the phrase */
@keyframes gotit-rise {
  0% {
    transform: translate(-50%, 0) scale(0.9);
    opacity: 0;
  }
  20% {
    opacity: 1;
    transform: translate(-50%, -10px) scale(1.05);
  }
  60% {
    opacity: 1;
  }
  100% {
    transform: translate(-50%, -40px) scale(0.95);
    opacity: 0;
  }
}

/* fragment "explosion" outward */
@keyframes gotit-frag {
  0% {
    transform: translate(0, 0) scale(1);
    opacity: 1;
  }
  100% {
    transform: translate(var(--gx), var(--gy)) scale(0.5);
    opacity: 0;
  }
}

/* container for fragments so we can position relative to phrase */
.gotit-burst-frag-container {
  position: absolute;
  left: 50%;
  top: 0;
  transform: translateX(-50%);
  pointer-events: none;
}

/* each tiny fragment (a part of the letters) */
.gotit-burst-frag {
  display: inline-block;
  font-size: 0.75rem;
  font-weight: 700;
  opacity: 0;
}


/* ===== Responsive tweaks ===== */
@media (max-width: 700px) {
  .gotit-burst-word {
    font-size: 0.9rem;
  }

  .gotit-burst-frag {
    font-size: 0.7rem;
  }
}

@media (min-width: 1000px) {
  .gotit-burst-word {
    font-size: 1.05rem;
  }

  .gotit-burst-frag {
    font-size: 0.8rem;
  }
}

/* ---------- Sticky Loop Bar ---------- */

#pg-sticky-loop-shell {
  position: sticky;
  top: 0;
  z-index: 40;
  padding: 0.5rem 0;
  margin-bottom: 0.75rem;
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
    border-radius: var(--radius-lg);;
  border: 1px solid rgba(125, 125, 255, 0.22);
  background: background: var(--card-bg);
}

/* Light / dark friendly subtle color */
#pg-sticky-loop-shell-inner {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.5rem 0.75rem;

}

/* Respect dark mode if you already flip background/text colors */
@media (prefers-color-scheme: dark) {
  #pg-sticky-loop-shell-inner {
    border-color: rgba(165, 180, 252, 0.4);
    background: linear-gradient(
      120deg,
      rgba(129, 140, 248, 0.35),
      rgba(56, 189, 248, 0.22),
      rgba(15, 23, 42, 0.7)
    );
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
  }
}

/* Pills inside loop */
.pg-loop-pill {
  display: inline-flex;
  align-items: center;
  gap: 0.35rem;
padding: 0.5rem 1rem;  border-radius: 999px;
  font-size: 0.78rem;
  line-height: 1.2;
  white-space: nowrap;
  border: 1px solid rgba(255, 255, 255, 0.35);
  background: rgba(15, 23, 42, 0.06);
  cursor: default;
  user-select: none;
}

@media (prefers-color-scheme: dark) {
  .pg-loop-pill {
    border-color: rgba(148, 163, 184, 0.7);
    background: rgba(15, 23, 42, 0.75);
  }
}
/* Action pills (Menu / Tools used elsewhere too) */
.pg-loop-pill--action {
  cursor: pointer;
  font-weight: 600;
  border-style: solid;
  border-width: 1px;
  border-color: rgba(96, 165, 250, 0.9);
  background: rgba(37, 99, 235, 0.08);
  transition:
    transform 0.12s ease-out,
    box-shadow 0.12s ease-out,
    background 0.12s ease-out;
}

.pg-loop-pill--action:active {
  transform: translateY(1px) scale(0.99);
  box-shadow: 0 0 0 rgba(0, 0, 0, 0);
}

/* Metric pills (streak, weekly recap) */
.pg-loop-pill-label {
  opacity: 0.7;
  font-weight: 500;
}

.pg-loop-pill-value {
  font-weight: 700;
}

/* Loop animation: items fade/slide in sequence */
.pg-loop-items {
  display: inline-flex;
  position: relative;
  overflow: hidden;
}

.pg-loop-item {
  opacity: 0;
  transform: translateY(8px);
  transition:
    opacity 0.3s ease-out,
    transform 0.3s ease-out;
  position: absolute;
  left: 0;
}

.pg-loop-item.pg-loop-item--active {
  opacity: 1;
  transform: translateY(0);
  position: relative;
}

/* --------- STICKY BAR: just the two buttons, styled like .card --------- */

#pg-sticky-loop-shell {
  position: sticky;
  top: 0;
  z-index: 30;
  margin: 0 0 12px;
  padding: 8px 12px;
  background: var(--card-bg);
  border-radius: var(--card-radius, 6px);
}

/* Row inside sticky bar = Menu + Tools */
.pg-loop-row {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.pg-loop-row--actions {
  justify-content: flex-end;
  flex-wrap: nowrap; /* keep buttons side by side */
}

/* Make sure Menu wrapper & Tools button don't become full-width on mobile */
.pg-loop-row--actions .header-top-row {
  display: flex;
  align-items: center;
  width: auto !important;
  flex: 0 0 auto !important;
}

.pg-loop-row--actions summary.pill-button,
.pg-loop-row--actions #pg-loop-tools-toggle {
  width: auto !important;
  flex: 0 0 auto !important;
}

/* ---------- Reusable "loop" behavior: NOT sticky anymore ---------- */
/* (used for the header metrics container) */

[data-sticky-loop] {
  position: relative; /* was sticky before – now only used for JS loop */
  z-index: 1;
  margin-top:10px;
}

/* Mobile tweaks: keep Menu + Tools on one line */
@media (max-width: 700px) {
  #pg-sticky-loop-shell {
    top: 1em;
  }
.header-menu .pill-button, #pg-loop-tools-toggle{
padding: 8px;
}
  .pg-loop-row--actions {
    justify-content: flex-end;
    flex-wrap: nowrap;
  }
}

/* Utility: hide original toggles on mobile ONLY when we've wired the loop */
.pg-mobile-hide-original-toggle {
  display: inline-flex;
}

@media (max-width: 700px) {
  .pg-mobile-hide-original-toggle {
    display: none !important;
  }
}
/* Mobile: stack metric pills (Today / Weekly recap) on their own lines */
@media (max-width: 500px) {
  .pg-loop-row--metrics {
    flex-direction: column;      /* stack instead of row */
    align-items: flex-start;
	margin-top:10px;
  }

  .pg-loop-row--metrics .pg-loop-pill {
    width: 100%;                 /* optional: make each pill full-width */
  }
}

/* Smooth transform for the Menu + Tools buttons */
#pg-sticky-loop-shell summary.pill-button,
#pg-sticky-loop-shell #pg-loop-tools-toggle {
  transition:
    transform 0.15s ease-out,
    padding 0.15s ease-out;
}

/* When sticky bar is "stuck", shrink the buttons slightly */
#pg-sticky-loop-shell.pg-is-stuck summary.pill-button,
#pg-sticky-loop-shell.pg-is-stuck #pg-loop-tools-toggle {
  transform: scale(0.9);
  padding-block: 0.5rem;
}
/* Default: hide sticky Tools button */
#pg-loop-tools-toggle {
  display: none !important;
}

/* Mobile: show sticky Tools button */
@media (max-width: 700px) {
  #pg-loop-tools-toggle {
    display: inline-flex !important;
    align-items: center;
    gap: 0.25rem;
  }
}


</style>


</head>

<body>
<div class="app">
 <header>
  <div class="title-block">
    <div class="title-row">
      <div class="brand-logo-wrap">
        <img
          src="studylens-light.png"
          class="brand-logo brand-logo-light"
          alt="StudyLens"
        />
        <img
          src="studylens-dark-highvis.png"
          class="brand-logo brand-logo-dark"
          alt="StudyLens"
        />
      </div>
      <h1 class="visually-hidden">StudyLens</h1>
    </div>
    <div class="subtitle">
      Snap, solve, study & write.<span class="mobile-break"><br></span> Built
      for students.
    </div>

    <!-- NEW: metrics row lives in the header now -->
    <div
      class="header-metrics pg-loop-row pg-loop-row--metrics"
      data-sticky-loop
      data-loop-interval="6000"
    >
      <div class="pg-loop-pill">
        <span class="pg-loop-pill-label">Today</span>
        <span class="pg-loop-pill-value" data-pg-streak-value>—</span>
      </div>

      <div class="pg-loop-pill">
        <div class="pg-loop-items" id="pg-loop-metrics-rotator">
          <div class="pg-loop-item pg-loop-item--active">
            <span class="pg-loop-pill-label">Weekly recap</span>
            <span
              class="pg-loop-pill-value"
              data-pg-weekly-summary
            >
              —
            </span>
          </div>
          <div class="pg-loop-item">
            <span class="pg-loop-pill-label">Questions solved</span>
            <span
              class="pg-loop-pill-value"
              data-pg-session-count
            >
              —
            </span>
          </div>
        </div>
      </div>
    </div>
    <!-- end header-metrics -->
  </div>

  <div class="header-right">
    <!-- your existing auth-row etc stays the same -->
    <div class="auth-row">
      <span id="proBadge" style="display:none; font-weight:bold;">
        Pro account ✅
      </span>
      <span id="userPlanLabel">Guest · 10 free uses</span>
    </div>
  </div>
</header>

  
  <!-- Sticky progress / loop bar (right under header) -->
<!-- Sticky bar: JUST the two buttons -->
<section id="pg-sticky-loop-shell">
  <div class="pg-loop-row pg-loop-row--actions">
    <!-- existing Menu dropdown -->
    <div class="header-top-row">
		  <div
            class="chip learn-mode"
            id="modeChip"
            style="justify-content:space-between;"
          >
            <span class="chip-dot"></span>
            <span class="mode-label">Learn mode ON</span>
          </div>
      <details
        class="header-menu"
        style="position:relative; display:inline-block;"
      >

        <summary
          class="pill-button"
          style="display:inline-flex;align-items:center;gap:4px;cursor:pointer;"
        >
          <span class="material-symbols-outlined" style="font-size:18px;"
            >expand_more</span
          >
          <span>Menu</span>
        </summary>

        <div
          class="header-menu-inner"
          style="
            position:absolute;
            top:calc(-100%);
            left:-100%;
            transform:translateX(-50%);
            display:flex;
            flex-direction:column;
            gap:6px;
            align-items:stretch;
            width:1*0px;
            z-index:30;
            background: var(--card-bg);
            padding: 16px;
            border-radius: 6px;
            box-shadow: 0 10px 24px rgba(15, 23, 42, 0.35);
          "
        >
          <!-- everything inside the dropdown stays exactly the same -->
		  
          <button
            class="drawer-toggle" style="display:none";
            id="drawerToggle"
            type="button"
            style="width:100%; justify-content:center;"
          >
            <span class="material-symbols-outlined">view_sidebar</span>
            <span>Tools</span>
          </button>

          <button
            class="theme-toggle"
            id="themeToggle"
            type="button"
            style="width:100%; justify-content:center;"
          >
            <svg id="iconSun" viewBox="0 0 24 24">
              <path
                fill="currentColor"
                d="M12 4a1 1 0 0 1 1 1V6a1 1 0 1 1-2 0V5a1 1 0 0 1 1-1Zm0 12a4 4 0 1 0 0-8 4 4 0 0 0 0 8Zm8-4a1 1 0 0 1-1 1h-1a1 1 0 1 1 0-2h1a1 1 0 0 1 1 1ZM6 13a1 1 0 1 1 0-2H5a1 1 0 1 1 0 2h1Zm11.07-5.07a1 1 0 0 1-1.41 0L14.9 7.17a1 1 0 0 1 1.42-1.41l.76.76a1 1 0 0 1 0 1.41Zm-9.54 9.54a1 1 0 0 1-1.41 0l-.76-.76A1 1 0 0 1 6.24 15.3l.76.76a1 1 0 0 1 0 1.41ZM18 17.24a1 1 0 0 1 0-1.41l.76-.76a1 1 0 1 1 1.41 1.41l-.76.76a1 1 0 0 1-1.41 0ZM6.24 8.7a1 1 0 0 1-1.41-1.41l.76-.76A1 1 0 0 1 7 7.24l-.76.76Z"
              />
            </svg>
            <svg id="iconMoon" viewBox="0 0 24 24" style="display: none">
              <path
                fill="currentColor"
                d="M20.3 14.8A7.5 7.5 0 0 1 11.2 3.7 1 1 0 0 0 10 2.49 9.5 9.5 0 1 0 21.51 14a1 1 0 0 0-1.21-1.22Z"
              />
            </svg>
            <span id="themeLabel">Dark</span>
          </button>

          <button
            id="upgradeButton"
            class="pill-button"
            type="button"
            style="width:100%; justify-content:center;"
          >
            Upgrade to Pro
          </button>

          <button
            id="authButton"
            class="pill-button"
            type="button"
            style="width:100%; justify-content:center;"
          >
            Sign in
          </button>

          
        </div>
      </details>
    </div>

    <!-- Tools pill in the loop -->
    <button
      type="button"
      class="pill-button"
      id="pg-loop-tools-toggle"
    >
      <span class="material-symbols-outlined" aria-hidden="true">view_sidebar</span>
      <span>Tools</span>
    </button>
  </div>
</section>



  <div class="top-bar">
    <select id="subjectSelect" class="text-input">
      <option value="general">Subject: Auto</option>
      <option value="math">Math</option>
      <option value="science">Science</option>
      <option value="english">English</option>
      <option value="history">History</option>
    </select>

    <!-- Single model option, still uses value="smart" so backend stays the same -->
    <select id="modelSelect" class="text-input">
      <option value="smart">Model: OpenAI (smart auto)</option>
    </select>
  </div>

  <p class="desc" style="margin: 4px 0 0; font-size: 0.72rem;">
    Subject just gives the AI a hint (Math, Science, etc.). You can leave it on
    <strong>Auto</strong>.
  </p>

  <div class="main-layout">
    <div class="content">
      <!-- SNAP & SOLVE (always visible main input) -->
      <section id="snap" class="tab-content active">
        <div class="card">
          <h2>Snap</h2>
          <p class="desc">
            Take a photo or screenshot of homework → text → AI explanation.
          </p>

          <label for="snapInput">Homework image</label>

          <!-- Hidden file inputs: gallery + camera -->
          <input
            type="file"
            id="snapInputGallery"
            accept="image/*"
            style="display:none;"
          />
          <input
            type="file"
            id="snapInputCamera"
            accept="image/*"
            capture="environment"
            style="display:none;"
          />

          <!-- DROPDOWN WRAPPER FOR SNAP ACTIONS -->
		  
          <div class="btn-row snap-actions-wrapper">
            <div class="snap-actions-dropdown">
              <button
                class="pill-button snap-actions-toggle"
                id="snapActionsToggle"
                type="button"
              >
                <span
                  class="material-symbols-outlined"
                  style="font-size: 18px;"
                >
                  expand_more
                </span>
                <span>Image actions</span>
              </button>

              <div class="snap-actions-menu" id="snapActionsMenu">
                <!-- Open camera / gallery -->
                <button id="snapCameraBtn" type="button">
                  <span class="material-symbols-outlined">photo_camera</span>
                  <span>Take Photo</span>
                </button>

                <button
                  id="snapUploadBtn"
                  class="secondary"
                  type="button"
                >
                  <span class="material-symbols-outlined">image</span>
                  <span>Upload Image</span>
                </button>

                <button id="snapOCRBtn" type="button">
                  <span class="material-symbols-outlined">scan</span>
                  <span>Run OCR</span>
                </button>

                <button
                  class="secondary"
                  id="snapClearBtn"
                  type="button"
                >
                  <span class="material-symbols-outlined">delete</span>
                  <span>Clear</span>
                </button>
              </div>
            </div>
          </div>

          <!-- Preview -->
          <img
            id="snapPreview"
            alt="Homework preview"
            style="
              margin-top: 8px;
              max-width: 100%;
              border-radius: 6px;
              display: none;
            "
          />

          <div class="snap-text-header">
            <label for="snapText">
              Recognized text (main input for all tools — you can also type
              here)
            </label>

            <button
              id="copySnapTextBtn"
              type="button"
              aria-label="Copy text"
            >
              <span class="material-symbols-outlined">content_copy</span>
              <span class="copy-label">Copy</span>
            </button>
          </div>

          <textarea
            id="snapText"
            class="text-input"
            placeholder="OCR text will appear here..."
          ></textarea>

          <!--<button id="refreshOcrButton" type="button" disabled>↻ Refresh OCR</button>-->
<div class="hint-row" style="margin-top: 10px; flex-direction: column; align-items: stretch;">
  <label for="extraInstructions" class="desc" style="margin: 0 0 4px; font-size: 0.75rem;">
    Optional: tell the AI what you want (tone, length, format, etc.)
  </label>
  <textarea
    id="extraInstructions"
    class="text-input"
    placeholder="Example: Explain like I'm in 8th grade and keep the answer under 5 steps."
    style="min-height: 60px;"
  ></textarea>
</div>
          <!-- NEW: custom subject / folder name for saving work -->
          <div
            class="hint-row"
            style="margin-top: 14px; justify-content: flex-start;"
          >
            <span class="desc" style="margin: 0; font-size: 0.75rem;">
              Save this work under:
            </span>
            <input
              id="saveSubjectInput"
              class="text-input"
              type="text"
              value="ex: algebra 2 fri"
              placeholder="e.g. Algebra test 2"
              style="
                
                font-size: 0.9rem;
                padding: 8px 10px;
                border-radius: 6px;
                flex: 0 0 auto;
                min-width: 110px;
              "
            />
          </div>


          <div class="hint-row" style="margin-top: 16px;">
            <span class="desc" style="margin: 0; font-size: 0.75rem;">
              What do you want to do with this text?
            </span>
          </div>

<div class="hint-row" style="margin-top: 4px; justify-content:flex-start;">
  <div class="snap-actions-dropdown" id="textActionsDropdown">
    <!-- dropdown toggle -->
    <button
      class="pill-button snap-actions-toggle"
      id="textActionsToggle"
      type="button"
    >
      <span class="material-symbols-outlined" style="font-size:18px;">
        expand_more
      </span>
      <span>Text actions</span>
    </button>

    <!-- dropdown menu with your existing buttons -->
    <div class="snap-actions-menu" id="textActionsMenu">
      <button id="snapActionSolveBtn" class="pill-button" type="button">
        <span class="material-symbols-outlined" style="font-size: 16px;">
          photo_camera
        </span>
        <span>Solve / Explain</span>
      </button>
<!-- A) Add this button INSIDE the Text actions menu (#textActionsMenu) -->
<button id="notesBtn" class="pill-button" type="button">
  <span class="material-symbols-outlined" style="font-size:16px;">
    checklist
  </span>
  <span>Extract Notes</span>
</button>
      <button id="mathSolveBtn" class="pill-button" type="button">
        <span class="material-symbols-outlined">calculate</span>
        <span>Math Solver</span>
      </button>

      <button id="studyGuideBtn" class="pill-button" type="button">
        <span class="material-symbols-outlined">menu_book</span>
        <span>Study Guide</span>
      </button>

      <button id="essayBtn" class="pill-button" type="button">
        <span class="material-symbols-outlined">draw</span>
        <span>Essay Helper</span>
      </button>

      <button id="cardsBtn" class="pill-button" type="button">
        <span class="material-symbols-outlined">style</span>
        <span>Flashcards</span>
      </button>
    </div>
  </div>
</div>

        </div>
      </section>

      <!-- SOLVE RESULT (new tool section) -->
      <section id="solve" class="tab-content">
        <div class="card">
          <h2>Solve</h2>
          <p class="desc">
            Results from solving the text in the Snap area.
          </p>
          <div class="hint-row">
            <button
              class="pill-button"
              type="button"
              data-action="simplify"
              data-target="snapResult"
            >
              <span
                class="material-symbols-outlined"
                style="font-size: 16px;"
                >lightbulb</span
              >
              Explain simpler
            </button>
            <button
              class="pill-button"
              type="button"
              data-action="hint"
              data-target="snapResult"
            >
              <span
                class="material-symbols-outlined"
                style="font-size: 16px;"
                >tips_and_updates</span
              >
              Give me a hint
            </button>
          </div>


          <pre id="snapResult" class="text-output"></pre>
        </div>
      </section>

      <!-- MATH SOLVER -->
      <section id="math" class="tab-content">
        <div class="card">
          <h2>Math Solver</h2>
          <p class="desc">
            Type or paste a math question → step-by-step solution.
          </p>

          
          <label for="snapText"
            >Math problem</label
          >
          <textarea
            id="mathInput"
            class="text-input"
            placeholder="Example: Solve 3x + 7 = 22"
            style="display:none;"
          ></textarea>

          <!-- Action button removed here; only Clear remains -->
          <div class="btn-row">
            <button
              class="secondary"
              id="mathClearBtn"
              type="button"
            >
              <span class="material-symbols-outlined">delete</span>
              <span>Clear</span>
            </button>
          </div>

          <div class="hint-row">
            <button
              class="pill-button"
              data-action="simplify"
              data-target="mathResult"
            >
              <span
                class="material-symbols-outlined"
                style="font-size: 16px;"
                >lightbulb</span
              >
              Explain simpler
            </button>
          </div>

          <pre id="mathResult" class="text-output"></pre>
        </div>
      </section>

      <!-- STUDY GUIDE -->
      <section id="study" class="tab-content">
        <div class="card">
          <h2>Study Guide</h2>
          <p class="desc">
            Turn messy notes or textbook text into a clean study guide.
          </p>

 
          <label for="snapText"
            >Notes or textbook text</label
          >
          <textarea
            id="studyInput"
            class="text-input"
            placeholder="Paste your notes or textbook text here..."
            style="display:none;"
          ></textarea>

          <!-- Action button removed here; only Clear remains -->
          <div class="btn-row">
            <button
              class="secondary"
              id="studyClearBtn"
              type="button"
            >
              <span class="material-symbols-outlined">delete</span>
              <span>Clear</span>
            </button>
          </div>

          <div class="hint-row">
            <button
              class="pill-button"
              data-action="simplify"
              data-target="studyResult"
            >
              <span
                class="material-symbols-outlined"
                style="font-size: 16px;"
                >lightbulb</span
              >
              Explain simpler
            </button>
          </div>

          <pre id="studyResult" class="text-output"></pre>
        </div>
      </section>

      <!-- ESSAY HELPER -->
      <section id="essay" class="tab-content">
        <div class="card">
          <h2>Essay Helper</h2>
          <p class="desc">
            Fix grammar, improve structure, or generate a draft from a prompt.
          </p>

        
          <label for="snapText"
            >Essay text or assignment prompt</label
          >
          <textarea
            id="essayInput"
            class="text-input"
            placeholder="Paste your essay or describe what you need to write..."
            style="display:none;"
          ></textarea>

          <!-- Action button removed here; only Clear remains -->
          <div class="btn-row">
            <button
              class="secondary"
              id="essayClearBtn"
              type="button"
            >
              <span class="material-symbols-outlined">delete</span>
              <span>Clear</span>
            </button>
          </div>

          <div class="hint-row">
            <button
              class="pill-button"
              data-action="simplify"
              data-target="essayResult"
            >
              <span
                class="material-symbols-outlined"
                style="font-size: 16px;"
                >lightbulb</span
              >
              Simpler version
            </button>
          </div>
<div class="output-format-bar">
  <label for="formatSelect-essayResult" style="margin-right:6px;">
    Format:
  </label>
  <select
    id="formatSelect-essayResult"
    class="text-input output-format-select"
    data-target="essayResult"
    style="width:auto; min-width:160px;"
  >
    <option value="plain">Plain (no formatting)</option>
    <option value="mla">MLA</option>
    <option value="apa">APA 7</option>
    <option value="chicago">Chicago / Turabian</option>
    <option value="ieee">IEEE</option>
  </select>

  <button
    type="button"
    class="pill-button output-format-apply"
    data-target="essayResult"
    style="margin-left:6px;"
  >
    Apply format
  </button>
</div>
          <pre id="essayResult" class="text-output"></pre>
        </div>
      </section>



<section id="notes" class="tab-content">
  <div class="card">
    <h2>Extract Notes</h2>
    <p class="desc">
      Turn the Snap text into short, high-yield bullet points.
    </p>

    <p class="notes-hint">
      This uses the main Snap textbox (OCR or pasted text). No extra typing needed.
    </p>

    <!-- hidden input, like the other tools; we still copy Snap text into here -->
    <label for="snapText">
      Source text
    </label>
    <textarea
      id="notesInput"
      class="text-input"
      placeholder="(Uses the Snap text above)"
      style="display:none;"
    ></textarea>

    <div class="btn-row">
      <button
        class="secondary"
        id="notesClearBtn"
        type="button"
      >
        <span class="material-symbols-outlined">delete</span>
        <span>Clear</span>
      </button>
    </div>

    <div class="hint-row">
      <button
        class="pill-button"
        data-action="simplify"
        data-target="notesResult"
        type="button"
      >
        <span class="material-symbols-outlined" style="font-size:16px;">
          lightbulb
        </span>
        <span>Explain simpler</span>
      </button>
    </div>

    <pre id="notesResult" class="text-output"></pre>
  </div>
</section>





      <section id="flashcards" class="tab-content">
        <div class="card">
          <h2>Flashcards</h2>
          <p class="desc">
            Paste content → get term/question → answer flashcards.
          </p>

   
          <label for="snapText"
            >Source text for flashcards</label
          >
          <textarea
            id="cardsInput"
            class="text-input"
            placeholder="Paste notes, vocabulary lists, or textbook text..."
            style="display:none;"
          ></textarea>

          <!-- Action button removed here; only Clear remains -->
          <div class="btn-row">
            <button
              class="secondary"
              id="cardsClearBtn"
              type="button"
            >
              <span class="material-symbols-outlined">delete</span>
              <span>Clear</span>
            </button>
          </div>

          <!-- Raw AI output (for debug / copy) -->
          <pre id="cardsResult" class="text-output"></pre>

          <!-- New interactive flashcard viewer -->
          <div
            id="cardsViewer"
            style="display: none; margin-top: 10px;"
          >
            <div id="cardsStats" class="desc">
              <!-- e.g. Card 1 of 10 • Got it 3 • Need work 2 -->
            </div>

            <div id="cardsCard" class="flashcard">
              <div id="cardsFront" class="flashcard-side">
                Front
              </div>
              <div
                id="cardsBack"
                class="flashcard-side"
                style="display: none;"
              >
                Back
              </div>
            </div>

            <div class="btn-row" style="margin-top: 8px;">
              <button
                class="secondary"
                id="cardsNeedWorkBtn"
                type="button"
              >
                <span class="material-symbols-outlined">priority_high</span>
                <span>Need work</span>
              </button>

              <button
                class="secondary"
                id="cardsGotItBtn"
                type="button"
              >
                <span class="material-symbols-outlined">check_circle</span>
                <span>Got it</span>
              </button>

              <button id="cardsFlipBtn" type="button">
                <span class="material-symbols-outlined">sync</span>
                <span>Flip</span>
              </button>
            </div>
          </div>
        </div>
      </section>
	  
	  
	  
	  
<section id="notebook" class="tab-content">
<div class="card">
<h2>Notebook</h2>
<p class="desc">
  Recent saved results from Snap, Math, Study, Essay, etc.
</p>

<!-- NEW: notebook top row with two dropdowns -->
<div class="notebook-top-row">
  <!-- Saved Subjects dropdown (uses #notebookSubjects) -->
  <details class="nb-dropdown" id="nbSavedSubjectsDropdown">
    <summary class="pill-button nb-dropdown-toggle">
      <span class="material-symbols-outlined" style="font-size:16px;">label</span>
      <span>Saved Subjects</span>
      <span class="material-symbols-outlined nb-dropdown-caret">expand_more</span>
    </summary>

    <div class="nb-dropdown-menu" id="nbSavedSubjectsMenu">
      <!-- your subject chips still render into this same element -->
      <div id="notebookSubjects" class="hint-row" style="margin-bottom:0;"></div>
    </div>
  </details>

  <!-- Subjects by tools dropdown (uses existing .notebook-filter buttons) -->
  <details class="nb-dropdown" id="nbToolFilterDropdown">
    <summary class="pill-button nb-dropdown-toggle">
      <span class="material-symbols-outlined" style="font-size:16px;">filter_alt</span>
      <span>Subjects by tools</span>
      <span class="material-symbols-outlined nb-dropdown-caret">expand_more</span>
    </summary>

    <div class="nb-dropdown-menu" id="nbToolFilterMenu">
      <div class="hint-row" id="notebookFilterRow">
        <button
          class="pill-button notebook-filter active"
          data-filter="all"
        >
          <span class="material-symbols-outlined" style="font-size:16px;">
            filter_alt
          </span>
          <span>All</span>
        </button>

        <button
          class="pill-button notebook-filter"
          data-filter="Snap"
        >
          <span class="material-symbols-outlined" style="font-size:16px;">
            photo_camera
          </span>
          <span>Solve</span>
        </button>

        <button
          class="pill-button notebook-filter"
          data-filter="Math"
        >
          <span class="material-symbols-outlined" style="font-size:16px;">
            calculate
          </span>
          <span>Math</span>
        </button>

        <button
          class="pill-button notebook-filter"
          data-filter="Study"
        >
          <span class="material-symbols-outlined" style="font-size:16px;">
            menu_book
          </span>
          <span>Study</span>
        </button>

        <button
          class="pill-button notebook-filter"
          data-filter="Essay"
        >
          <span class="material-symbols-outlined" style="font-size:16px;">
            draw
          </span>
          <span>Essay</span>
        </button>

        <button
          class="pill-button notebook-filter"
          data-filter="Cards"
        >
          <span class="material-symbols-outlined" style="font-size:16px;">
            style
          </span>
          <span>Flashcards</span>
        </button>
      </div>
    </div>
  </details>
</div>



<!-- keep your existing Clear / Undo row exactly as it was -->
<div class="btn-row" style="margin-bottom: 8px;">
  <button class="secondary" id="clearNotebookBtn" type="button">
    <span class="material-symbols-outlined">delete_forever</span>
    <span>Clear notebook</span>
  </button>
  <button class="secondary" id="undoNotebookBtn" type="button">
    <span class="material-symbols-outlined">undo</span>
    <span>Undo</span>
  </button>
</div>

<!-- notebookSubjects div is now inside the Saved Subjects dropdown above -->
<div id="notebookList"></div>
</div>
</section>


      <div class="hint-footer" id="hintFooter">
        AI is for learning, not cheating. Always check your work.
      </div>
    </div>

    <!-- RIGHT SIDE DRAWER / SIDEBAR -->
    <aside class="side-drawer" id="sideDrawer">
      <div class="side-drawer-inner">
        <div class="side-drawer-header">TOOLS</div>
        <nav class="side-nav">
          <!-- NEW: OCR tool -->
          <button class="nav-btn active" data-target="snap" type="button">
            <span class="material-symbols-outlined">scan</span>
            <span class="label">Snap</span>
          </button>
<button class="nav-btn" data-target="notes" type="button">
  <span class="material-symbols-outlined">checklist</span>
  <span class="label">Extract Notes</span>
</button>
          <!-- Existing tools, unchanged except Solve is no longer the default active -->
          <button class="nav-btn" data-target="solve" type="button">
            <span class="material-symbols-outlined">photo_camera</span>
            <span class="label">Solve</span>
          </button>

          <button class="nav-btn" data-target="math" type="button">
            <span class="material-symbols-outlined">calculate</span>
            <span class="label">Math Solver</span>
          </button>

          <button class="nav-btn" data-target="study" type="button">
            <span class="material-symbols-outlined">menu_book</span>
            <span class="label">Study Guide</span>
          </button>

          <button class="nav-btn" data-target="essay" type="button">
            <span class="material-symbols-outlined">draw</span>
            <span class="label">Essay Helper</span>
          </button>

          <button class="nav-btn" data-target="flashcards" type="button">
            <span class="material-symbols-outlined">style</span>
            <span class="label">Flashcards</span>
          </button>

          <button class="nav-btn" data-target="notebook" type="button">
            <span class="material-symbols-outlined">book_2</span>
            <span class="label">Notebook</span>
          </button>
        </nav>

      </div>
    </aside>
  </div>
</div>





<!-- Fixed back / forward tool buttons -->
<div id="tabNavButtons">
  <button id="backTabButton" class="tab-nav-btn" type="button">
    ← Back
  </button>
  <button id="forwardTabButton" class="tab-nav-btn" type="button">
    Forward →
  </button>
</div>










<!-- BLOCK 1: Theme toggle, cheat/learn mode, drawer/sidebar, subject/model helpers -->
<script>
// ---------- THEME TOGGLE ----------
const themeToggle = document.getElementById("themeToggle");
const themeLabel = document.getElementById("themeLabel");
const iconSun = document.getElementById("iconSun");
const iconMoon = document.getElementById("iconMoon");

// NEW: keep browser/status bar color in sync
function applyThemeColor(theme) {
  const meta = document.querySelector('meta[name="theme-color"]');
  if (!meta) return;
  const isDark = theme === "dark";
  // dark uses your dark surface, light uses your light header/bg
  meta.setAttribute("content", isDark ? "#020617" : "#f9fafb");
}

function setTheme(theme) {
  document.documentElement.setAttribute("data-theme", theme);
  localStorage.setItem("studyai-theme", theme);

  const dark = theme === "dark";
  themeLabel.textContent = dark ? "Dark" : "Light";
  iconSun.style.display = dark ? "block" : "none";
  iconMoon.style.display = dark ? "none" : "block";

  // NEW: sync meta tag
  applyThemeColor(theme);
}

// use whatever the <html> tag currently has as the initial theme
const initialTheme =
  document.documentElement.getAttribute("data-theme") || "dark";
setTheme(initialTheme);

themeToggle.addEventListener("click", () => {
  const current =
    document.documentElement.getAttribute("data-theme") || "dark";
  setTheme(current === "dark" ? "light" : "dark");
});




// ---------- DRAWER / SIDEBAR ----------
const drawerToggle = document.getElementById("drawerToggle");
const sideDrawer = document.getElementById("sideDrawer");
const drawerBackdrop = document.getElementById("drawerBackdrop");

function isDesktop() {
  return window.innerWidth >= 800;
}

function openDrawer() {
  if (isDesktop()) return; // always visible on desktop
  sideDrawer.classList.add("open");
  drawerBackdrop.classList.add("show");
}

function closeDrawer() {
  if (isDesktop()) return;
  sideDrawer.classList.remove("open");
  drawerBackdrop.classList.remove("show");
}

if (drawerToggle) {
  drawerToggle.addEventListener("click", () => {
    if (sideDrawer.classList.contains("open")) {
      closeDrawer();
    } else {
      openDrawer();
    }
  });
}

drawerBackdrop.addEventListener("click", closeDrawer);

window.addEventListener("resize", () => {
  if (isDesktop()) {
    sideDrawer.classList.add("open");
    drawerBackdrop.classList.remove("show");
  } else {
    sideDrawer.classList.remove("open");
  }
});

if (isDesktop()) {
  sideDrawer.classList.add("open");
}

// ---------- SUBJECT / MODEL HELPERS ----------
function getSubject() {
  const subjectSelect = document.getElementById("subjectSelect");
  return (subjectSelect && subjectSelect.value) ? subjectSelect.value : "general";
}

function getModelChoice() {
  const modelSelect = document.getElementById("modelSelect");
  return (modelSelect && modelSelect.value) ? modelSelect.value : "smart";
}
</script>


<script>
  // ---------- CHEAT MODE TOGGLE ----------
  const modeChip = document.getElementById("modeChip");
  window.__cheatMode = false; // false = learn mode ON, true = hidden cheat mode

  // If the chip isn't on the page for some reason, bail out safely
  if (!modeChip) {
    console.warn("modeChip element not found; cheat/learn toggle not initialized.");
  } else {
    const modeLabel = modeChip.querySelector(".mode-label");
    const chipDot = modeChip.querySelector(".chip-dot");

    function updateModeChip() {
      const isLearnOn = !window.__cheatMode;

      // Text: never mention "cheat mode" in the UI
      if (modeLabel) {
        modeLabel.textContent = isLearnOn ? "Learn mode ON" : "Learn mode OFF";
      }

      // Visually act like a green/red toggle switch
      if (chipDot) {
        chipDot.style.backgroundColor = isLearnOn ? "#22c55e" : "#ef4444"; // green / red dot
      }

      modeChip.style.borderColor = isLearnOn
        ? "rgba(34,197,94,0.6)"          // green border
        : "rgba(239,68,68,0.6)";         // red border

      modeChip.style.backgroundColor = isLearnOn
        ? "rgba(34,197,94,0.12)"         // light green bg
        : "rgba(239,68,68,0.12)";        // light red bg

      modeChip.setAttribute("data-state", isLearnOn ? "on" : "off");
    }

    modeChip.addEventListener("click", () => {
      // Flip between learn (false) and hidden cheat (true)
      window.__cheatMode = !window.__cheatMode;
      updateModeChip();
    });

    // Initial state: Learn mode ON (green)
    updateModeChip();
  }
</script>



<!-- BLOCK 2: Notebook load/save/render, filters, add item -->
<script>
  // ---------- NOTEBOOK ----------
  const notebookKey = "studyai-notebook";
  const notebookListEl = document.getElementById("notebookList");
  const notebookFilterButtons = document.querySelectorAll(".notebook-filter");
  const notebookSubjectsEl = document.getElementById("notebookSubjects");
  let notebookFilter = "all";
  let notebookSubjectFilter = "all";
  let notebookLastSnapshot = null; // for undo

  // NEW: generic clipboard helper
  function copyTextToClipboard(text) {
    const value = String(text || "");
    if (!value) return;
    if (navigator.clipboard && navigator.clipboard.writeText) {
      navigator.clipboard.writeText(value).catch((err) =>
        console.error("Clipboard error:", err)
      );
      return;
    }
    // fallback
    const ta = document.createElement("textarea");
    ta.value = value;
    ta.style.position = "fixed";
    ta.style.opacity = "0";
    document.body.appendChild(ta);
    ta.select();
    try {
      document.execCommand("copy");
    } catch (e) {
      console.error("execCommand copy failed:", e);
    }
    document.body.removeChild(ta);
  }

  function loadNotebook() {
    try {
      return JSON.parse(localStorage.getItem(notebookKey) || "[]");
    } catch {
      return [];
    }
  }

  function saveNotebook(items) {
    localStorage.setItem(notebookKey, JSON.stringify(items.slice(-200))); // keep last 200
  }

  // NEW: subject name used when saving notebook items
  function getSaveSubject() {
    const input = document.getElementById("saveSubjectInput");
    if (!input) return "general";
    const value = (input.value || "").trim();
    return value || "general";
  }

  // NEW: render subjects list / chips
  function renderNotebookSubjects(allItems) {
    if (!notebookSubjectsEl) return;

    const subjects = Array.from(
      new Set(
        allItems.map((i) => {
          const s = (i.subject || "general").trim();
          return s || "general";
        })
      )
    ).sort((a, b) => a.localeCompare(b));

    notebookSubjectsEl.innerHTML = "";

    if (!subjects.length) {
      return;
    }

    subjects.forEach((subj) => {
      const row = document.createElement("div");
      row.className = "notebook-subject-row";
      row.style.position = "relative";
      row.style.display = "inline-flex";
      row.style.alignItems = "center";
      row.style.gap = "4px";

      const subjBtn = document.createElement("button");
      subjBtn.type = "button";
      subjBtn.className = "pill-button notebook-subject-btn";
      if (notebookSubjectFilter === subj) {
        subjBtn.classList.add("active");
      }
      subjBtn.dataset.subject = subj;
      subjBtn.textContent = subj;

      // small "menu" button to toggle dropdown
      const menuBtn = document.createElement("button");
      menuBtn.type = "button";
      menuBtn.className = "pill-button notebook-subject-menu";
      menuBtn.dataset.subject = subj;
      menuBtn.textContent = "⋯";

      // dropdown container (hidden by default)
      const dropdown = document.createElement("div");
      dropdown.className = "notebook-subject-dropdown";
      dropdown.style.display = "none";
      dropdown.style.position = "absolute";
      dropdown.style.right = "0";
      dropdown.style.top = "110%";
      dropdown.style.background = "#fff";
      dropdown.style.border = "1px solid var(--outline)";
      dropdown.style.borderRadius = "0px";
      dropdown.style.padding = "1em";
      dropdown.style.zIndex = "20";
      dropdown.style.whiteSpace = "nowrap";

      const editBtn = document.createElement("button");
      editBtn.type = "button";
      editBtn.className = "pill-button notebook-subject-edit";
      editBtn.dataset.subject = subj;
      editBtn.textContent = "Rename subject";

      const delBtn = document.createElement("button");
      delBtn.type = "button";
      delBtn.className = "pill-button notebook-subject-delete";
      delBtn.dataset.subject = subj;
      delBtn.textContent = "Delete subject & notes";

      dropdown.appendChild(editBtn);
      dropdown.appendChild(delBtn);

      // 🔹 direct handler for this menu button
      menuBtn.addEventListener("click", (ev) => {
        ev.stopPropagation();
        const isShowing = dropdown.style.display === "flex";
        dropdown.style.display = isShowing ? "none" : "flex";
      });

      row.appendChild(subjBtn);
      row.appendChild(menuBtn);
      row.appendChild(dropdown);

      notebookSubjectsEl.appendChild(row);
    });
  }

  function renderNotebook() {
    if (!notebookListEl) return;

    const allItems = loadNotebook();
    notebookListEl.innerHTML = "";

    // always render subjects list from full set
    renderNotebookSubjects(allItems);

    if (!allItems.length) {
      notebookListEl.innerHTML =
        '<p class="desc">Nothing saved yet. Solve something and it will appear here.</p>';
      return;
    }

    const byType =
      notebookFilter === "all"
        ? allItems
        : allItems.filter((i) => i.type === notebookFilter);

    const items =
      notebookSubjectFilter === "all"
        ? byType
        : byType.filter(
            (i) =>
              (i.subject || "general").trim() === notebookSubjectFilter
          );

    if (!items.length) {
      notebookListEl.innerHTML =
        '<p class="desc">No items for this filter yet.</p>';
      return;
    }

    const labelMap = {
      Snap: "Solve",
      Math: "Math Solver",
      Study: "Study Guide",
      Essay: "Essay Helper",
      Cards: "Flashcards",
      Flashcards: "Flashcards",
      Simplified: "Simplified answer",
      Hint: "Hint",
    };

    items
      .slice()
      .reverse()
      .forEach((item) => {
        const wrapper = document.createElement("div");
        wrapper.className = "notebook-item";

        const header = document.createElement("div");
        header.className = "notebook-item-header";

        const meta = document.createElement("div");
        meta.className = "notebook-meta";
        const timeStr = new Date(item.time).toLocaleString();
        meta.textContent = `${item.type} • ${timeStr} • ${
          item.subject || "general"
        } • ${item.model || "smart"} • ${item.mode || "learn"}`;

        header.appendChild(meta);
        wrapper.appendChild(header);

        const body = document.createElement("div");
        body.textContent = item.text;
        wrapper.appendChild(body);

        // footer with "Open in ..." + Copy + Delete
        const footer = document.createElement("div");
        footer.className = "notebook-item-footer";

        const openBtn = document.createElement("button");
        openBtn.className = "pill-button notebook-open-btn";
        openBtn.type = "button";
        openBtn.dataset.id = item.id;

        const displayType =
          labelMap[item.type] || item.type || "tool";
        openBtn.textContent = "Open in " + displayType;

        // NEW: copy icon button
        const copyBtn = document.createElement("button");
        copyBtn.className = "pill-button notebook-item-copy";
        copyBtn.type = "button";
        copyBtn.dataset.id = item.id;
        copyBtn.innerHTML =
          '<span class="material-symbols-outlined">content_copy</span>';

        const deleteBtn = document.createElement("button");
        deleteBtn.className = "pill-button notebook-item-delete";
        deleteBtn.type = "button";
        deleteBtn.dataset.id = item.id;
        deleteBtn.textContent = "Delete";

        footer.appendChild(openBtn);
        footer.appendChild(copyBtn);
        footer.appendChild(deleteBtn);
        wrapper.appendChild(footer);

        notebookListEl.appendChild(wrapper);
      });
  }

  // open a saved notebook item back in its tool
  function openNotebookItemById(itemId) {
    const items = loadNotebook();
    const item = items.find((i) => i.id === itemId);
    if (!item) return;

    const text = item.text || "";

    function safeRender(elementId) {
      const el = document.getElementById(elementId);
      if (!el) return;
      if (typeof renderAnswer === "function") {
        renderAnswer(el, text);
      } else {
        el.textContent = text;
      }
    }

    switch (item.type) {
      case "Snap":
        if (typeof activateTab === "function") {
          if (document.getElementById("solve")) {
            activateTab("solve");
          } else {
            activateTab("snap");
          }
        }
        safeRender("snapResult");
        break;

      case "Math":
        if (typeof activateTab === "function") activateTab("math");
        safeRender("mathResult");
        break;

      case "Study":
        if (typeof activateTab === "function") activateTab("study");
        safeRender("studyResult");
        break;

      case "Essay":
        if (typeof activateTab === "function") activateTab("essay");
        safeRender("essayResult");
        break;

      case "Cards":
      case "Flashcards":
        if (typeof activateTab === "function") activateTab("flashcards");

        // put raw text back into cardsResult
        const cardsResultEl = document.getElementById("cardsResult");
        if (cardsResultEl) {
          cardsResultEl.textContent = text;
        }

        // rebuild interactive flashcards if helpers exist
        if (typeof parseFlashcardsFromText === "function") {
          try {
            const parsed = parseFlashcardsFromText(text);
            if (parsed && parsed.length) {
              if (typeof saveFlashcards === "function") {
                saveFlashcards(parsed);
              }
              if (typeof window !== "undefined") {
                window.flashcards = parsed;
                window.currentCardIndex = 0;
              }
              if (typeof renderCurrentCard === "function") {
                renderCurrentCard();
              }
            }
          } catch (e) {
            console.error("Error rebuilding flashcards from notebook:", e);
          }
        }
        break;

      case "Simplified":
      case "Hint":
      default:
        // fallback: show in Solve/Snap
        if (typeof activateTab === "function") {
          if (document.getElementById("solve")) {
            activateTab("solve");
          } else {
            activateTab("snap");
          }
        }
        safeRender("snapResult");
        break;
    }
  }

  // click handler for "Open in ...", Copy, item Delete (event delegation)
  if (notebookListEl) {
    notebookListEl.addEventListener("click", (e) => {
      const openBtn = e.target.closest(".notebook-open-btn");
      if (openBtn) {
        const id = openBtn.dataset.id;
        if (!id) return;
        openNotebookItemById(id);
        return;
      }

      const copyBtn = e.target.closest(".notebook-item-copy");
      if (copyBtn) {
        const id = copyBtn.dataset.id;
        if (!id) return;
        const items = loadNotebook();
        const item = items.find((i) => i.id === id);
        if (!item) return;
        copyTextToClipboard(item.text || "");
        return;
      }

      const deleteBtn = e.target.closest(".notebook-item-delete");
      if (deleteBtn) {
        const id = deleteBtn.dataset.id;
        if (!id) return;
        const items = loadNotebook();
        const idx = items.findIndex((i) => i.id === id);
        if (idx === -1) return;

        const ok = confirm("Delete this saved item? You can undo once.");
        if (!ok) return;

        notebookLastSnapshot = items.slice();
        items.splice(idx, 1);
        saveNotebook(items);
        renderNotebook();
      }
    });
  }

  // NEW: subject chips (filter / edit / delete) using delegation (menu handled directly)
  if (notebookSubjectsEl) {
    notebookSubjectsEl.addEventListener("click", (e) => {
      const subjectBtn = e.target.closest(".notebook-subject-btn");
      if (subjectBtn) {
        const subj = subjectBtn.dataset.subject;
        if (!subj) return;
        notebookSubjectFilter =
          notebookSubjectFilter === subj ? "all" : subj;
        renderNotebook();
        return;
      }

      const editBtn = e.target.closest(".notebook-subject-edit");
      if (editBtn) {
        const oldSubj = editBtn.dataset.subject;
        if (!oldSubj) return;

        const newNameRaw = prompt("Rename subject:", oldSubj);
        if (newNameRaw === null) return;
        const newName = newNameRaw.trim();
        if (!newName || newName === oldSubj) return;

        const ok = confirm(`Rename subject "${oldSubj}" to "${newName}"?`);
        if (!ok) return;

        const items = loadNotebook();
        notebookLastSnapshot = items.slice();

        const updated = items.map((it) => {
          const s = (it.subject || "general").trim();
          if (s === oldSubj) {
            return { ...it, subject: newName };
          }
          return it;
        });

        if (notebookSubjectFilter === oldSubj) {
          notebookSubjectFilter = newName;
        }

        saveNotebook(updated);
        renderNotebook();
        return;
      }

      const delBtn = e.target.closest(".notebook-subject-delete");
      if (delBtn) {
        const subj = delBtn.dataset.subject;
        if (!subj) return;

        const ok = confirm(
          `Delete subject "${subj}" and all its saved work? You can undo once.`
        );
        if (!ok) return;

        const items = loadNotebook();
        notebookLastSnapshot = items.slice();
        const remaining = items.filter(
          (it) => (it.subject || "general").trim() !== subj
        );

        if (notebookSubjectFilter === subj) {
          notebookSubjectFilter = "all";
        }

        saveNotebook(remaining);
        renderNotebook();
      }
    });
  }

  // Notebook filters (All, Snap, Math, Study, Essay, Quiz...)
  notebookFilterButtons.forEach((btn) => {
    btn.addEventListener("click", () => {
      notebookFilterButtons.forEach((b) => b.classList.remove("active"));
      btn.classList.add("active");
      notebookFilter = btn.dataset.filter || "all";
      renderNotebook();
    });
  });

  // Add an item to notebook
  function addNotebookItem(type, text) {
    if (!text || !text.trim()) return;
    const items = loadNotebook();
    notebookLastSnapshot = items.slice(); // allow undo of this insert
    items.push({
      id: Date.now() + Math.random().toString(16).slice(2),
      type, // "Snap", "Math", "Study", etc.
      text: text.trim(),
      time: Date.now(),
      subject: getSaveSubject(),
      model: getModelChoice(),
      mode: window.__cheatMode ? "cheat" : "learn",
      pinned: false,
    });
    saveNotebook(items);
    renderNotebook();
  }

  // NEW: clear notebook + undo
  const clearNotebookBtn = document.getElementById("clearNotebookBtn");
  if (clearNotebookBtn) {
    clearNotebookBtn.addEventListener("click", () => {
      const items = loadNotebook();
      if (!items.length) {
        alert("Notebook is already empty.");
        return;
      }
      const ok = confirm(
        "Clear all saved notebook items? You can undo this once."
      );
      if (!ok) return;
      notebookLastSnapshot = items.slice();
      saveNotebook([]);

      renderNotebook();
    });
  }

  const undoNotebookBtn = document.getElementById("undoNotebookBtn");
  if (undoNotebookBtn) {
    undoNotebookBtn.addEventListener("click", () => {
      if (!notebookLastSnapshot) {
        alert("Nothing to undo yet.");
        return;
      }
      saveNotebook(notebookLastSnapshot);
      notebookLastSnapshot = null;
      renderNotebook();
    });
  }

  // Initial render
  renderNotebook();

  // NEW: wire up copy buttons for textareas (Snap + other visible ones)
  document.addEventListener("DOMContentLoaded", () => {
    const snapTa = document.getElementById("snapText");
    const copySnapBtn = document.getElementById("copySnapTextBtn");
    if (snapTa && copySnapBtn) {
      copySnapBtn.addEventListener("click", () => {
        copyTextToClipboard(snapTa.value || "");
      });
    }

    // auto-add copy icon next to other visible textareas (not snapText, not display:none)
    const textareas = document.querySelectorAll("textarea");
    textareas.forEach((ta) => {
      if (ta.id === "snapText") return;
	      if (ta.id === "extraInstructions") return;   // ⬅️ add this line

      if (ta.style.display === "none") return;
      if (!ta.parentNode) return;

      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "icon-copy-btn";
      btn.setAttribute("aria-label", "Copy text");
      btn.innerHTML =
        '<span class="material-symbols-outlined">content_copy</span>';

      ta.parentNode.insertBefore(btn, ta.nextSibling);
      btn.addEventListener("click", () => {
        copyTextToClipboard(ta.value || "");
      });
    });
  });
</script>




<!-- BLOCK 3: Answer sanitizing, AI backend call, and all task helpers -->
<script>
function sanitizeAnswerText(raw) {
  if (!raw) return "";
  let text = String(raw);

  text = text.replace(/^\s*#{1,6}\s+.*$/gm, "");
  text = text.replace(/^\s*[-*_]{3,}\s*$/gm, "");
  text = text.replace(/---/g, "");
  text = text.replace(/```/g, "");

  text = text.replace(/\\frac\{([^}]+)\}\{([^}]+)\}/g, "$1/$2");
  text = text.replace(/\\sqrt\{([^}]+)\}/g, "√($1)");
  text = text.replace(/√\(([^()]+)\)/g, "√$1");
  text = text.replace(/\\boxed\{([^}]+)\}/g, "$1");

  text = text.replace(/\\\(|\\\)/g, "");
  text = text.replace(/\\\[|\\\]/g, "");
  text = text.replace(/\$\$/g, "");
  text = text.replace(/\$(.*?)\$/g, "$1");

  text = text.replace(/\\times/g, "×");
  text = text.replace(/\\cdot/g, "·");

  text = text.replace(/^\s*-\s+(?!\d)/gm, "");
  text = text.replace(/^\s*\*\s+(?!\d)/gm, "");

  text = text.replace(/^Lets solve.*$/gmi, "");

  text = text.replace(/[\\`#*_$>]/g, "");
  text = text.replace(/\r\n/g, "\n");
  text = text.replace(/\n{3,}/g, "\n\n");
  // If we have a line that ends with "Final answer:" and nothing after it,
  // fill it with the last number we see in the text.
  const finalLineMatch = text.match(/Final answer:\s*$/m);
  if (finalLineMatch) {
    const numbers = text.match(/-?\d+(\.\d+)?/g);
    if (numbers && numbers.length > 0) {
      const lastNum = numbers[numbers.length - 1];
      text = text.replace(/Final answer:\s*$/m, "Final answer: " + lastNum);
    }
  }

  return text.trim();
}

// Inject styles for tool outputs + headings + copy button
(function ensureToolOutputStyles() {
  if (document.getElementById("tool-output-styles")) return;
  const style = document.createElement("style");
  style.id = "tool-output-styles";
  style.textContent = `
    .tool-output {
      position: relative;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      font-size: 0.95rem;
      line-height: 1.6;
      color: #111827;
      background: #f9fafb;
      border-radius: 0.75rem;
      border: 1px solid #e5e7eb;
      padding: 0.85rem 1rem 0.9rem 1rem;
      margin-top: 0.75rem;
      overflow-wrap: anywhere;
    }
    .tool-output-header {
      display: flex;
      justify-content: flex-end;
      align-items: center;
      margin-bottom: 0.25rem;
    }
    .tool-output-body {
      white-space: pre-wrap;
    }
    .tool-output-copy {
      border: 1px solid #e5e7eb;
      background: #f3f4f6;
      border-radius: 6px;
      font-size: 0.75rem;
      padding: 0.1rem 0.6rem;
      cursor: pointer;
      color: #374151;
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
    }
    .tool-output-copy:hover {
      background: #e5e7eb;
    }
    .tool-output-copy-label {
      font-weight: 500;
    }
    .section-heading {
      display: block;
      font-weight: 700;
      color: #000;
      margin-top: 0.9rem;
      margin-bottom: 0.1rem;
      font-size: 1rem;
    }
    .step-line {
      display: block;
      font-weight: 600;
      color: #111827;
      margin-top: 0.4rem;
    }
    .answer-label {
      font-weight: 700;
      color: #000;
    }
    .answer-value {
      font-weight: 500;
      color: #111827;
    }
    .hint-label {
      display: inline-block;
      margin-top: 0.75rem;
      font-weight: 700;
      color: #000;
    }
  `;
  document.head.appendChild(style);
})();

function renderAnswer(preEl, text) {
  if (!preEl) return;

  const plain = String(text || "");
  preEl.dataset.plainText = plain;
  preEl.classList.add("tool-output");

  const escaped = plain
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;");

  const lines = escaped.split("\n");

  const htmlLines = lines.map((line) => {
    const trimmed = line.trim();

    // Final answer: ...
    const finalMatch = line.match(/^(Final answer:\s*)(.*)$/i);
    if (finalMatch) {
      const label = finalMatch[1];
      const value = finalMatch[2] || "";
      return `<span class="answer-label">${label}</span><span class="answer-value"> ${value}</span>`;
    }

    // Step 1:, Step 2, etc.
    if (/^Step\s+\d+/i.test(trimmed)) {
      return `<span class="step-line">${line}</span>`;
    }

    // Section headings like "Summary:", "Answer Key:", etc.
    if (/^(Summary|Answer Key|Multiple Choice|Short Answer|True\/False)\s*:/i.test(trimmed)) {
      return `<span class="section-heading">${line}</span>`;
    }

    // "Hint:"
    if (/^Hint:\s*$/i.test(trimmed)) {
      return `<span class="hint-label">Hint</span>`;
    }

    return line;
  });

  const contentHtml = htmlLines.join("\n");
  const copyTarget = preEl.id ? ` data-copy-target="${preEl.id}"` : "";

  preEl.innerHTML = `
    <div class="tool-output-header">
      <button type="button" class="tool-output-copy"${copyTarget}>
        <span class="tool-output-copy-label">Copy</span>
      </button>
    </div>
    <div class="tool-output-body">${contentHtml}</div>
  `;
}

// Global click handler for tool-output copy buttons
document.addEventListener("click", (e) => {
  const btn = e.target.closest(".tool-output-copy");
  if (!btn) return;

  let textToCopy = "";
  const targetId = btn.dataset.copyTarget;
  if (targetId) {
    const container = document.getElementById(targetId);
    if (container) {
      textToCopy =
        (container.dataset && container.dataset.plainText) ||
        container.innerText ||
        "";
    }
  } else {
    const container = btn.closest(".tool-output");
    if (container) {
      textToCopy =
        (container.dataset && container.dataset.plainText) ||
        container.innerText ||
        "";
    }
  }

  if (!textToCopy) return;

  copyTextToClipboard(textToCopy);

  const label = btn.querySelector(".tool-output-copy-label");
  if (label) {
    const old = label.textContent;
    label.textContent = "Copied!";
    setTimeout(() => {
      label.textContent = old;
    }, 1200);
  }
});

// helper to clean flashcard sides (front/back)
function cleanSide(text) {
  return String(text || "")
    .trim()
    .replace(/^[QA]\s*:\s*/i, "") // remove leading "Q:" or "A:"
    .replace(/^:\s*/, "")         // remove leading ":"
    .replace(/\s*:\s*$/, "");     // remove trailing ":"
}



  // ---------- AI ENGINE (BACKEND HOOK POINT) ----------
  async function callAI({ prompt, task }) {
    const modelChoice = getModelChoice();
    const subject = getSubject();
    const mode = window.__cheatMode ? "cheat" : "learn";

    try {
      const res = await fetch("/api/solve", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          prompt:
            `Mode: ${mode}\n` +
            `Subject: ${subject}\n` +
            `Tool: ${task}\n\n` +
            prompt,
          task,
          model: modelChoice,
        }),
      });

      if (!res.ok) {
        throw new Error("Network error (" + res.status + ")");
      }

      const data = await res.json();
      if (data.error) throw new Error(data.error);

      return data.text || "[Empty response]";
    } catch (err) {
      console.error(err);
      return "⚠️ Error talking to AI:\n" + err.message;
    }
  }

  // ---------- TASK HELPERS ----------
  async function runMathSolver(text) {
    const cheat = window.__cheatMode;
    const prompt = cheat
      ? "Solve this math problem and give ONLY the final numeric/algebraic answer. " +
        "If there are multiple parts, label each answer clearly (a), b), c), etc.).\n\nProblem:\n" +
        text.trim()
      : "You are a step-by-step math tutor for a middle/high school student.\n" +
"Solve the problem clearly. Show each step, and END with a line exactly like:\n" +
"`Final answer: <number>`\n\n" +
"Problem:\n" +
text.trim();

    return callAI({ prompt, task: "math" });
  }

  async function runStudyGuide(text) {
    const prompt =
      "Turn the following notes or textbook text into a study guide for a student.\n" +
      "Output:\n- Bullet point main ideas\n- Key definitions\n- Short summary at the end.\n\n" +
      text.trim();
    return callAI({ prompt, task: "study_guide" });
  }

  async function runEssayHelper(text) {
    const cheat = window.__cheatMode;
    const prompt = cheat
      ? "Write a strong, polished essay based on this text or prompt. Just give the finished essay.\n\nInput:\n" +
        text.trim()
      : "You are an essay helper for a middle/high school student.\n" +
        "If the text looks like a draft, improve clarity, grammar, and structure but keep their voice.\n" +
        "If it is a prompt, generate a well-structured answer.\n\n" +
        "Input:\n" +
        text.trim();
    return callAI({ prompt, task: "essay" });
  }

  async function runFlashcards(text) {
    const prompt =
      "Create useful flashcards from this content for a student.\n" +
      "Output format strictly like:\n" +
      "Q: ...\nA: ...\n\n" +
      "Use many short cards.\n\n" +
      "Content:\n" +
      text.trim();

    return callAI({ prompt, task: "flashcards" });
  }

  

  async function runSimplify(text) {
    const prompt =
      "Explain the following answer in much simpler language for a middle or high school student. Keep key ideas, but shorten and simplify:\n\n" +
      text.trim();
    return callAI({ prompt, task: "simplify" });
  }

  async function runHint(question, existingAnswer) {
    const prompt =
      "Give a helpful hint (not the full solution) for this problem for a student.\n" +
      "Keep it short and focused.\n\nProblem:\n" +
      question.trim() +
      "\n\nExisting answer (if any):\n" +
      (existingAnswer || "");
    return callAI({ prompt, task: "hint" });
  }

  async function runSnapSolve(text) {
    const cheat = window.__cheatMode;
    const prompt = cheat
      ? "A student scanned this homework text. Give the direct final answers as clearly as possible. " +
        "If there are multiple questions, number each answer so it matches. Minimal explanation.\n\n" +
        text.trim()
      : "A student scanned this homework text. Solve or explain it step-by-step in a clear way.\n\n" +
        text.trim();
    return callAI({ prompt, task: "snap" });
  }
</script>





<!-- BLOCK 4: Image resize helper and OCR call to backend -->
<script>
  // Store last OCR image so we can refresh without re-upload
  let lastOcrImageDataUrl = null;

  // Helper: resize image before sending to backend (faster on phones)
  function resizeImageToDataUrl(file, maxWidth = 1200, quality = 0.8) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = (e) => {
        const img = new Image();
        img.onload = () => {
          const scale = Math.min(1, maxWidth / img.width);
          const w = img.width * scale;
          const h = img.height * scale;

          const canvas = document.createElement("canvas");
          canvas.width = w;
          canvas.height = h;
          const ctx = canvas.getContext("2d");
          ctx.drawImage(img, 0, 0, w, h);

          try {
            const dataUrl = canvas.toDataURL("image/jpeg", quality);
            resolve(dataUrl);
          } catch (err) {
            reject(err);
          }
        };
        img.onerror = reject;
        img.src = e.target.result;
      };
      reader.onerror = reject;
      reader.readAsDataURL(file);
    });
  }

  // ---------- REAL OCR VIA AI BACKEND ----------
  async function runFakeOCR(file) {
    let imageData;

    if (file) {
      // New image: resize and remember it
      imageData = await resizeImageToDataUrl(file, 1200, 0.8);
      lastOcrImageDataUrl = imageData;
    } else if (lastOcrImageDataUrl) {
      // No file passed: reuse last image (refresh)
      imageData = lastOcrImageDataUrl;
    } else {
      return "⚠️ No image available for OCR yet.";
    }

    const subject = getSubject();
    const modelChoice = getModelChoice();
    const mode = window.__cheatMode ? "cheat" : "learn";

    const body = {
      prompt:
        `Mode: ${mode}\n` +
        `Subject: ${subject}\n` +
        `Tool: ocr\n\n` +
        "Extract the text from this homework image and return plain text only.",
      task: "ocr",
      model: modelChoice,
      imageData: imageData,
    };

    try {
      const res = await fetch("/api/ocr", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body),
      });

      if (!res.ok) {
        throw new Error("Network error (" + res.status + ")");
      }

      const data = await res.json();
      if (data.error) throw new Error(data.error);

      return data.text || "";
    } catch (err) {
      console.error("OCR error:", err);
      return "⚠️ Error during OCR: " + err.message;
    }
  }
</script>



<!-- BLOCK 5: Tabs / sidenav navigation (with Back + Forward) -->
<script>
  // ---------- TABS (SIDENAV) ----------
  const navBtns = document.querySelectorAll(".nav-btn");
  const tabs = document.querySelectorAll(".tab-content");
  const LAST_TAB_KEY = "studyai-last-tab";

  // History stacks
  let tabHistory = [];        // back stack
  let forwardHistory = [];    // forward stack
  let currentTab = null;
  let isNavigatingBack = false;
  let isNavigatingForward = false;

  const backTabButton = document.getElementById("backTabButton");
  const forwardTabButton = document.getElementById("forwardTabButton");

  function updateBackButtonState() {
    // Back button state
    if (backTabButton) {
      if (tabHistory.length === 0) {
        backTabButton.disabled = true;
        backTabButton.classList.add("tab-nav-btn-disabled");
      } else {
        backTabButton.disabled = false;
        backTabButton.classList.remove("tab-nav-btn-disabled");
      }
    }

    // Forward button state
    if (forwardTabButton) {
      if (forwardHistory.length === 0) {
        forwardTabButton.disabled = true;
        forwardTabButton.classList.add("tab-nav-btn-disabled");
      } else {
        forwardTabButton.disabled = false;
        forwardTabButton.classList.remove("tab-nav-btn-disabled");
      }
    }
  }

  function activateTab(targetId) {
    let found = false;

    navBtns.forEach((b) => {
      const isTarget = b.dataset.target === targetId;
      if (isTarget) found = true;
      b.classList.toggle("active", isTarget);
    });

    tabs.forEach((t) => {
      t.classList.toggle("active", t.id === targetId);
    });

    if (!found && targetId !== "solve") {
      // fallback – don't add fake entries to history
      activateTab("solve");
      return;
    }

    // Only push to history on "normal" navigation (not back/forward)
    if (!isNavigatingBack && !isNavigatingForward && currentTab && currentTab !== targetId) {
      tabHistory.push(currentTab);
      // new navigation clears forward stack
      forwardHistory = [];

      if (tabHistory.length > 25) {
        tabHistory.shift();
      }
    }

    currentTab = targetId;
    localStorage.setItem(LAST_TAB_KEY, targetId);
    updateBackButtonState();
  }

  // Sidenav buttons
  navBtns.forEach((btn) => {
    btn.addEventListener("click", () => {
      const target = btn.dataset.target;
      activateTab(target);
      if (typeof isDesktop === "function" && typeof closeDrawer === "function" && !isDesktop()) {
        closeDrawer();
      }
    });
  });

  // Back: pop from back stack, push current into forward stack
  if (backTabButton) {
    backTabButton.addEventListener("click", () => {
      if (!tabHistory.length) return;

      const prev = tabHistory.pop();
      if (!prev) {
        updateBackButtonState();
        return;
      }

      if (currentTab) {
        forwardHistory.push(currentTab);
        if (forwardHistory.length > 25) {
          forwardHistory.shift();
        }
      }

      isNavigatingBack = true;
      activateTab(prev);
      isNavigatingBack = false;
      updateBackButtonState();
    });
  }

  // Forward: pop from forward stack, push current into back stack
  if (forwardTabButton) {
    forwardTabButton.addEventListener("click", () => {
      if (!forwardHistory.length) return;

      const next = forwardHistory.pop();
      if (!next) {
        updateBackButtonState();
        return;
      }

      if (currentTab) {
        tabHistory.push(currentTab);
        if (tabHistory.length > 25) {
          tabHistory.shift();
        }
      }

      isNavigatingForward = true;
      activateTab(next);
      isNavigatingForward = false;
      updateBackButtonState();
    });
  }

  // Initial tab
  const savedTab = localStorage.getItem(LAST_TAB_KEY) || "solve";
  currentTab = savedTab;
  activateTab(savedTab);
</script>




<!-- BLOCK 6: UI wiring for Snap, Math, Study, Essay -->
<script>
  document.addEventListener("DOMContentLoaded", function () {
    // ---------- UI WIRING ----------

    // SNAP (now with camera + gallery inputs)
    const snapInputGallery = document.getElementById("snapInputGallery");
    const snapInputCamera  = document.getElementById("snapInputCamera");
    const snapOCRBtn       = document.getElementById("snapOCRBtn");
    const snapClearBtn     = document.getElementById("snapClearBtn");
    const snapText         = document.getElementById("snapText");
    const snapResult       = document.getElementById("snapResult");
    const snapSolveBtn     = document.getElementById("snapActionSolveBtn");

    const snapCameraBtn = document.getElementById("snapCameraBtn");
    const snapUploadBtn = document.getElementById("snapUploadBtn");
    const snapPreview   = document.getElementById("snapPreview");

    const refreshOcrButton = document.getElementById("refreshOcrButton");

    // 🔹 subject input for auto-fill
    const saveSubjectInput = document.getElementById("saveSubjectInput");

    // 🔹 helper: read "tell the AI what you want" extra instructions
    function getExtraInstructions() {
      const el =
        document.getElementById("extraInstructionsInput") ||
        document.getElementById("extraInstructions") ||
        document.getElementById("extraPrompt");
      if (!el) return "";
      return (el.value || "").trim();
    }

    // keep track of whichever file was chosen last
    let lastSnapFile = null;

    // 🔹 helper: fill subject from current snapText value
    function maybeFillSubjectFromOcrNow() {
      if (!snapText || !saveSubjectInput) return;

      // don't overwrite if user already set something custom
      const current = (saveSubjectInput.value || "").trim();
      if (current && current.toLowerCase() !== "general") return;

      const raw = snapText.value || "";
      if (!raw.trim()) return;

      let heading = "";

      // Use smarter heading extractor if it exists
      if (typeof extractHeadingFromOcrText === "function") {
        heading = extractHeadingFromOcrText(raw) || "";
      }

      // Fallback: first non-empty line
      if (!heading) {
        const firstLine = raw
          .split(/\r?\n/)
          .map((l) => l.trim())
          .find((l) => l.length > 0);
        if (firstLine) {
          heading = firstLine;
        }
      }

      if (!heading) return;

      // Trim to something reasonable
      if (heading.length > 60) {
        heading = heading.slice(0, 60).trim() + "…";
      }

      saveSubjectInput.value = heading;
    }

    // 🔹 ALSO auto-fill when user types/pastes into snapText
    if (snapText) {
      snapText.addEventListener("input", () => {
        maybeFillSubjectFromOcrNow();
      });
    }

    // simple loading animation for textareas
    function startTextareaLoading(ta, baseText) {
      if (!ta) return;
      stopTextareaLoading(ta);
      let dotCount = 0;
      const maxDots = 3;
      ta.value = baseText;
      if (window.autoResizeTextarea) window.autoResizeTextarea(ta);
      const id = setInterval(() => {
        dotCount = (dotCount + 1) % (maxDots + 1);
        const dots = ".".repeat(dotCount);
        ta.value = baseText + dots;
        if (window.autoResizeTextarea) window.autoResizeTextarea(ta);
      }, 400);
      ta.dataset.loadingIntervalId = String(id);
    }

    function stopTextareaLoading(ta) {
      if (!ta) return;
      const id = ta.dataset.loadingIntervalId;
      if (id) {
        clearInterval(Number(id));
        delete ta.dataset.loadingIntervalId;
      }
    }

    // simple loading animation for result elements
    function startResultLoading(el, baseText) {
      if (!el) return;
      el.classList.add("tool-output");   // 🔹 for styling
      stopResultLoading(el);
      let dotCount = 0;
      const maxDots = 3;
      el.textContent = baseText;
      const id = setInterval(() => {
        dotCount = (dotCount + 1) % (maxDots + 1);
        const dots = ".".repeat(dotCount);
        el.textContent = baseText + dots;
      }, 400);
      el.dataset.loadingIntervalId = String(id);
    }

    function stopResultLoading(el) {
      if (!el) return;
      const id = el.dataset.loadingIntervalId;
      if (id) {
        clearInterval(Number(id));
        delete el.dataset.loadingIntervalId;
      }
    }

    function handleSnapFile(file) {
      if (!file) {
        lastSnapFile = null;
        if (snapPreview) {
          snapPreview.src = "";
          snapPreview.style.display = "none";
        }
        return;
      }

      lastSnapFile = file;

      const reader = new FileReader();
      reader.onload = (e) => {
        if (snapPreview) {
          snapPreview.src = e.target.result;
          snapPreview.style.display = "block";
        }
      };
      reader.readAsDataURL(file);
    }

    // Open CAMERA
    if (snapCameraBtn && snapInputCamera) {
      snapCameraBtn.addEventListener("click", () => {
        snapInputCamera.click();
      });
    }

    // Open GALLERY / FILE PICKER
    if (snapUploadBtn && snapInputGallery) {
      snapUploadBtn.addEventListener("click", () => {
        snapInputGallery.click();
      });
    }

    // When user picks from camera
    if (snapInputCamera) {
      snapInputCamera.addEventListener("change", () => {
        const file = snapInputCamera.files[0];
        handleSnapFile(file);
      });
    }

    // When user picks from gallery
    if (snapInputGallery) {
      snapInputGallery.addEventListener("change", () => {
        const file = snapInputGallery.files[0];
        handleSnapFile(file);
      });
    }

    // Run OCR on whichever file we last picked – DOES NOT affect usage counts
    if (snapOCRBtn) {
      snapOCRBtn.addEventListener("click", async () => {
        if (!lastSnapFile) {
          alert("Choose or take an image first.");
          return;
        }
        startTextareaLoading(snapText, "Reading image");
        const text = await runFakeOCR(lastSnapFile);
        stopTextareaLoading(snapText);
        snapText.value = text;
        if (window.autoResizeTextarea) window.autoResizeTextarea(snapText);

        // 🔹 update subject from OCR text
        maybeFillSubjectFromOcrNow();

        // still fire input for any other listeners you have
        snapText.dispatchEvent(new Event("input"));
      });
    }

    // Refresh OCR on the last image without clearing it
    if (refreshOcrButton) {
      refreshOcrButton.addEventListener("click", async () => {
        if (!lastSnapFile) {
          alert("Choose or take an image first.");
          return;
        }
        const originalText = refreshOcrButton.textContent;
        refreshOcrButton.disabled = true;
        refreshOcrButton.textContent = "Refreshing...";
        startTextareaLoading(snapText, "Reading image");
        const text = await runFakeOCR(null); // reuse last image in runFakeOCR
        stopTextareaLoading(snapText);
        snapText.value = text;
        if (window.autoResizeTextarea) window.autoResizeTextarea(snapText);

        // 🔹 update subject from refreshed OCR
        maybeFillSubjectFromOcrNow();

        // still fire input for any other listeners you have
        snapText.dispatchEvent(new Event("input"));

        refreshOcrButton.textContent = originalText;
        refreshOcrButton.disabled = false;
      });
    }

    // Clear everything
    if (snapClearBtn) {
      snapClearBtn.addEventListener("click", () => {
        if (snapInputCamera)  snapInputCamera.value = "";
        if (snapInputGallery) snapInputGallery.value = "";

        // reset image + OCR state
        lastSnapFile = null;
        try { lastOcrImageDataUrl = null; } catch (e) {}

        // reset main OCR text box
        if (snapText) {
          snapText.value = "";
          if (window.autoResizeTextarea) window.autoResizeTextarea(snapText);
        }

        // reset subject input
        if (saveSubjectInput) {
          saveSubjectInput.value = "";
        }

        // clear Snap result output
        if (snapResult) {
          snapResult.textContent = "";
        }

        // clear preview image
        if (snapPreview) {
          snapPreview.src = "";
          snapPreview.style.display = "none";
        }
      });
    }

    // Solve / Explain (usage counted based on snapText)
    if (snapSolveBtn) {
      snapSolveBtn.addEventListener("click", async () => {
        const text = snapText.value.trim();
        if (!text) {
          alert("No text to solve.");
          return;
        }

        const extra = getExtraInstructions();
        const promptText = extra
          ? text + "\n\nExtra instructions from student (tone/length/format/etc.):\n" + extra
          : text;

        // usage gate
        if (window.__canUseAIOnce) {
          const allowed = await window.__canUseAIOnce();
          if (!allowed) return;
        } else if (window.__canUseAIOnceAnon && !window.__canUseAIOnceAnon()) {
          return;
        }

        // switch to the Solve tool section
        if (typeof activateTab === "function") {
          activateTab("solve");
        }

        // put the text into the Solve tool's textarea if it exists
        const solveInput = document.getElementById("solveInput");
        if (solveInput) {
          solveInput.value = text; // keep original in UI
          if (window.autoResizeTextarea) window.autoResizeTextarea(solveInput);
        }

        startResultLoading(snapResult, "Thinking");
        const ans = await runSnapSolve(promptText);
        stopResultLoading(snapResult);
        const clean = sanitizeAnswerText(ans);
        renderAnswer(snapResult, clean); // 👈 formatting helper
        addNotebookItem("Snap", clean);
      });
    }

    // MATH (usage counted based on snapText)
    const mathInput    = document.getElementById("mathInput");
    const mathSolveBtn = document.getElementById("mathSolveBtn");
    const mathClearBtn = document.getElementById("mathClearBtn");
    const mathResult   = document.getElementById("mathResult");

    if (mathSolveBtn) {
      mathSolveBtn.addEventListener("click", async () => {
        const text = snapText.value.trim();
        if (!text) {
          alert("Type or paste a math problem into the main text box first.");
          return;
        }

        const extra = getExtraInstructions();
        const promptText = extra
          ? text + "\n\nExtra instructions from student (tone/steps/detail/etc.):\n" + extra
          : text;

        // usage gate
        if (window.__canUseAIOnce) {
          const allowed = await window.__canUseAIOnce();
          if (!allowed) return;
        } else if (window.__canUseAIOnceAnon && !window.__canUseAIOnceAnon()) {
          return;
        }

        startResultLoading(mathResult, "Thinking");
        const ans = await runMathSolver(promptText);
        stopResultLoading(mathResult);
        const clean = sanitizeAnswerText(ans);
        renderAnswer(mathResult, clean);   // 👈 formatted
        addNotebookItem("Math", clean);
      });
    }

    if (mathClearBtn) {
      mathClearBtn.addEventListener("click", () => {
        mathResult.textContent = "";
      });
    }

    // STUDY (usage counted based on snapText)
    const studyInput    = document.getElementById("studyInput");
    const studyGuideBtn = document.getElementById("studyGuideBtn");
    const studyClearBtn = document.getElementById("studyClearBtn");
    const studyResult   = document.getElementById("studyResult");

    if (studyGuideBtn) {
      studyGuideBtn.addEventListener("click", async () => {
        const text = snapText.value.trim();
        if (!text) {
          alert("Paste some notes or text into the main text box first.");
          return;
        }

        const extra = getExtraInstructions();
        const promptText = extra
          ? text + "\n\nExtra instructions from student (what to focus on, how short/long, etc.):\n" + extra
          : text;

        // usage gate
        if (window.__canUseAIOnce) {
          const allowed = await window.__canUseAIOnce();
          if (!allowed) return;
        } else if (window.__canUseAIOnceAnon && !window.__canUseAIOnceAnon()) {
          return;
        }

        startResultLoading(studyResult, "Thinking");
        const ans = await runStudyGuide(promptText);
        stopResultLoading(studyResult);
        const clean = sanitizeAnswerText(ans);
        renderAnswer(studyResult, clean);   // 👈 formatted
        addNotebookItem("Study", clean);
      });
    }

    if (studyClearBtn) {
      studyClearBtn.addEventListener("click", () => {
        studyResult.textContent = "";
      });
    }

    // ESSAY (usage counted based on snapText)
    const essayInput    = document.getElementById("essayInput");
    const essayBtn      = document.getElementById("essayBtn");
    const essayClearBtn = document.getElementById("essayClearBtn");
    const essayResult   = document.getElementById("essayResult");

    if (essayBtn) {
      essayBtn.addEventListener("click", async () => {
        const text = snapText.value.trim();
        if (!text) {
          alert("Paste your essay or prompt into the main text box first.");
          return;
        }

        const extra = getExtraInstructions();
        const promptText = extra
          ? text + "\n\nExtra instructions from student (tone, length, structure, citations, etc.):\n" + extra
          : text;

        // usage gate
        if (window.__canUseAIOnce) {
          const allowed = await window.__canUseAIOnce();
          if (!allowed) return;
        } else if (window.__canUseAIOnceAnon && !window.__canUseAIOnceAnon()) {
          return;
        }

        startResultLoading(essayResult, "Thinking");
        const ans = await runEssayHelper(promptText);
        stopResultLoading(essayResult);
        const clean = sanitizeAnswerText(ans);
        renderAnswer(essayResult, clean);   // 👈 formatted
        addNotebookItem("Essay", clean);
      });
    }

    if (essayClearBtn) {
      essayClearBtn.addEventListener("click", () => {
        essayResult.textContent = "";
      });
    }
  });
</script>







<!-- BLOCK 7: Flashcards generation + interactive viewer -->
<script>
  // ---------- FLASHCARDS (interactive) ----------
  const cardsInput = document.getElementById("cardsInput");
  const cardsBtn = document.getElementById("cardsBtn");
  const cardsClearBtn = document.getElementById("cardsClearBtn");
  const cardsResult = document.getElementById("cardsResult");

  const cardsViewer = document.getElementById("cardsViewer");
  const cardsStats = document.getElementById("cardsStats");
  const cardsFront = document.getElementById("cardsFront");
  const cardsBack = document.getElementById("cardsBack");
  const cardsFlipBtn = document.getElementById("cardsFlipBtn");
  const cardsGotItBtn = document.getElementById("cardsGotItBtn");
  const cardsNeedWorkBtn = document.getElementById("cardsNeedWorkBtn");
  const cardsCard = document.getElementById("cardsCard");

  const cardsStorageKey = "studyai-flashcards";

  // Simple flag so you can easily turn the sound on/off
  const ENABLE_FLASHCARD_SOUND = true;
  let gotItAudio = null;
  if (ENABLE_FLASHCARD_SOUND) {
    // Replace this path with your actual sound file
    gotItAudio = new Audio("/sounds/flashcard-success.mp3");
  }

  let flashcards = [];
  let currentCardIndex = 0;
  let showingBack = false;

  // Move flashcards viewer above the source textbox
  (function moveViewerAboveTextarea() {
    if (
      cardsViewer &&
      cardsInput &&
      cardsInput.parentNode &&
      cardsInput.parentNode === cardsViewer.parentNode
    ) {
      cardsInput.parentNode.insertBefore(cardsViewer, cardsInput);
    }
  })();

  // ---------- Encouragement burst for "Got it" ----------

  // Very short, 1–2 word phrases only – no contextual text
  const GOTIT_PHRASES = [
    "Nice!", "Locked in", "Aced it", "So good", "Too easy", "Big win",
    "On fire", "All set", "Got it", "So clean", "Well done", "Great job",
    "So ready", "Study win", "Gold star", "Go you", "Test ready", "Nice work",
    "Brain power", "Level up", "You win", "So sharp", "Top tier", "Dialed in",
    "Memory win", "Clean hit", "Good job", "So strong", "Sharp mind", "Nice one",
    "All good", "Rock on", "Pro move", "Clutch", "Too smart", "Peak form",
    "Max focus", "Laser brain", "Quiz boss", "Exam ace", "Study pro", "Star mode",
    "Big brain", "Full marks", "Perfect", "Textbook", "On point", "All clear",
    "Solid", "So solid", "So smooth", "Pure win", "Nice save", "Yes!", "Sweet",
    "Boom!", "Love it", "Great!", "Done!", "Win!", "Locked!", "Crushed it",
    "Nailed it", "So pro", "Right on", "So right", "Correct", "Exact",
    "Bullseye", "No doubt", "Zero miss", "All right", "Brain boost",
    "High score", "Quiz king", "Clear win", "So crisp", "Nailed that",
    "Spot on", "Nice pull", "Clutch win", "Sharp shot", "Clean win",
    "Test boss", "Quiz star", "Full brain", "Got this", "Big yes", "All win",
    "Brain gold", "Score!", "Top form", "Prime mind"
  ];

  // Bright colors for the phrase, randomized each click
  const GOTIT_COLORS = [
    "#f97316", // orange
    "#22c55e", // green
    "#3b82f6", // blue
    "#ec4899", // pink
    "#eab308", // yellow
    "#a855f7", // purple
    "#06b6d4", // cyan
    "#fb7185"  // rose
  ];

  let gotitRecentIndices = [];

  function pickGotItPhrase() {
    const n = GOTIT_PHRASES.length;
    if (!n) return "Nice!";
    const maxTries = 10;
    let chosen = 0;

    for (let i = 0; i < maxTries; i++) {
      const idx = Math.floor(Math.random() * n);
      if (!gotitRecentIndices.includes(idx)) {
        chosen = idx;
        break;
      }
      chosen = idx;
    }

    gotitRecentIndices.push(chosen);
    if (gotitRecentIndices.length > 10) {
      gotitRecentIndices.shift();
    }

    return GOTIT_PHRASES[chosen];
  }

  function pickGotItColor() {
    const n = GOTIT_COLORS.length;
    if (!n) return "#f97316";
    const idx = Math.floor(Math.random() * n);
    return GOTIT_COLORS[idx];
  }

  // Text burst that starts at the Got it button, goes up, and explodes into little bits
  // UPDATED: only ONE phrase per click + random bright color + MORE EXPLOSION
  function spawnGotItBurst(anchorEl) {
    if (!anchorEl) return;

    const rect = anchorEl.getBoundingClientRect();
    const baseX = rect.left + rect.width / 2;
    const baseY = rect.top + rect.height / 2;

    // Single phrase per click (no overlap of multiple phrases)
    const phrase = pickGotItPhrase();
    const color = pickGotItColor();

    const wordEl = document.createElement("div");
    wordEl.textContent = phrase;

    wordEl.style.position = "fixed";
    wordEl.style.left = baseX + "px";
    wordEl.style.top = baseY + "px";
    wordEl.style.transform = "translate(-50%, -50%) scale(0.9)";
    wordEl.style.pointerEvents = "none";
    wordEl.style.whiteSpace = "nowrap";
    wordEl.style.zIndex = "9999";
    wordEl.style.opacity = "0";
    wordEl.style.fontWeight = "800";

    // Responsive font size
    let fontSizePx = 16;
    if (window.innerWidth < 700) {
      fontSizePx = 14;
    } else if (window.innerWidth > 1000) {
      fontSizePx = 18;
    }
    wordEl.style.fontSize = fontSizePx + "px";

    // Bright random color each time
    wordEl.style.color = color;
    wordEl.style.background = "transparent";
    wordEl.style.textShadow = "none";

    // Slightly longer rise so the explosion feels bigger
    const riseDuration = 700 + Math.random() * 400;
    wordEl.style.transition =
      "transform " +
      riseDuration +
      "ms ease-out, opacity " +
      riseDuration +
      "ms ease-out";

    wordEl.style.display = "inline-block";

    // Container for tiny letter fragments
    const fragContainer = document.createElement("div");
    fragContainer.style.position = "absolute";
    fragContainer.style.left = "50%";
    fragContainer.style.top = "50%";
    fragContainer.style.transform = "translate(-50%, -50%)";
    fragContainer.style.pointerEvents = "none";

    const letters = phrase.replace(/\s+/g, "").split("");

    // MORE EXPLOSION: more fragments
    const fragCount = Math.min(24, Math.max(12, letters.length || 12));

    for (let i = 0; i < fragCount; i++) {
      const ch = letters[i % letters.length] || "•";
      const frag = document.createElement("span");
      frag.textContent = ch;
      frag.style.display = "inline-block";
      frag.style.fontSize = Math.max(10, fontSizePx * 0.75) + "px";
      frag.style.fontWeight = "700";
      frag.style.color = color;
      frag.style.opacity = "1";
      frag.style.transform = "translate(0px, 0px) scale(1)";

      // Longer and slightly staggered duration for fragments
      const dur = 550 + Math.random() * 350;
      frag.style.transition =
        "transform " + dur + "ms ease-out, opacity " + dur + "ms ease-out";

      // MORE EXPLOSION: bigger spread
      const spread = 70 + Math.random() * 60;
      const angle = Math.random() * Math.PI * 2;
      const tx = Math.cos(angle) * spread;
      const ty = Math.sin(angle) * spread - 20;

      // Kick off fragment "explosion"
      setTimeout(() => {
        frag.style.transform =
          "translate(" + tx + "px, " + ty + "px) scale(0.5)";
        frag.style.opacity = "0";
      }, 60 + i * 12);

      fragContainer.appendChild(frag);
    }

    wordEl.appendChild(fragContainer);
    document.body.appendChild(wordEl);

    // Main phrase rises up a bit and fades
    requestAnimationFrame(() => {
      const driftY = -50 - Math.random() * 25;
      wordEl.style.opacity = "1";
      wordEl.style.transform =
        "translate(-50%, calc(-50% + " + driftY + "px)) scale(1.05)";
    });

    // Fade away after the rise
    setTimeout(() => {
      wordEl.style.opacity = "0";
      wordEl.style.transform =
        "translate(-50%, calc(-50% - 70px)) scale(0.95)";
    }, riseDuration);

    // Clean up DOM
    setTimeout(() => {
      if (wordEl.parentNode) {
        wordEl.parentNode.removeChild(wordEl);
      }
    }, riseDuration + 600);
  }

  // Theme-aware styles for the flashcard question + background
  function updateCardStylesForTheme() {
    const theme =
      document.documentElement.getAttribute("data-theme") || "dark";

    if (cardsFront) {
      cardsFront.classList.toggle("flashcard-question-light", theme === "light");
      cardsFront.classList.toggle("flashcard-question-dark", theme !== "light");
    }

    if (cardsCard) {
      cardsCard.classList.toggle("flashcard-card-light", theme === "light");
      cardsCard.classList.toggle("flashcard-card-dark", theme !== "light");
    }
  }

  // Watch for theme changes so the question color / background stay in sync
  (function watchThemeForFlashcards() {
    updateCardStylesForTheme();
    if (typeof MutationObserver === "function") {
      const obs = new MutationObserver(updateCardStylesForTheme);
      obs.observe(document.documentElement, {
        attributes: true,
        attributeFilter: ["data-theme"]
      });
    }
  })();

  function loadFlashcardsStorage() {
    try {
      return JSON.parse(localStorage.getItem(cardsStorageKey) || "[]" );
    } catch {
      return [];
    }
  }

  function saveFlashcards(cards) {
    localStorage.setItem(cardsStorageKey, JSON.stringify(cards));
  }

  function parseFlashcardsFromText(raw) {
    const text = typeof raw === "string" ? raw : String(raw ?? "");
    const lines = text.split(/\r?\n/);
    const temp = [];
    let current = null;

    for (let line of lines) {
      const trimmed = line.trim();
      if (!trimmed) continue;

      const qMatch = trimmed.match(/^Q[\s.:,-]*?(.*)$/i);
      const aMatch = trimmed.match(/^A[\s.:,-]*?(.*)$/i);

      if (qMatch) {
        if (current && current.front && current.back) {
          temp.push(current);
        }
        current = {
          front: qMatch[1].trim(),
          back: "",
        };
      } else if (aMatch && current) {
        const piece = aMatch[1].trim();
        current.back = current.back ? current.back + "\n" + piece : piece;
      } else if (current) {
        if (!current.back) {
          current.front += "\n" + trimmed;
        } else {
          current.back += "\n" + trimmed;
        }
      }
    }

    if (current && current.front && current.back) {
      temp.push(current);
    }

    const now = Date.now();
    return temp.map((c, i) => ({
      id: now + "-" + i,
      front: c.front,
      back: c.back,
      status: "new",
      seen: 0,
      correct: 0,
      lastSeen: now,
    }));
  }

  function updateCardsStats() {
    if (!flashcards.length) {
      cardsStats.textContent = "No cards yet. Create some above.";
      return;
    }
    const total = flashcards.length;
    const got = flashcards.filter((c) => c.status === "got").length;
    const need = flashcards.filter((c) => c.status === "need_work").length;
    const indexLabel = currentCardIndex + 1;

    cardsStats.textContent =
      `Card ${indexLabel} of ${total}` +
      ` • Got it ${got}` +
      ` • Need work ${need}`;
  }

  function renderCurrentCard() {
    if (!cardsViewer) return;

    if (!flashcards.length) {
      cardsViewer.style.display = "none";
      return;
    }

    if (currentCardIndex < 0 || currentCardIndex >= flashcards.length) {
      currentCardIndex = 0;
    }

    const card = flashcards[currentCardIndex];
    cardsViewer.style.display = "block";
    showingBack = false;

    cardsFront.style.display = "block";
    cardsBack.style.display = "none";

    const rawFront = card.front || "[No question]";
    const rawBack  = card.back  || "[No answer]";

    const frontText = cleanSide(rawFront) || "[No question]";
    const backText  = cleanSide(rawBack)  || "[No answer]";

    cardsFront.textContent = frontText;
    cardsBack.textContent  = backText;

    updateCardStylesForTheme();
    updateCardsStats();
  }

  // Restore from storage
  (function initFlashcardsFromStorage() {
    const stored = loadFlashcardsStorage();
    if (stored && stored.length) {
      flashcards = stored;
      currentCardIndex = 0;
      renderCurrentCard();
    }
  })();

  // usage counted based on snapText
  cardsBtn.addEventListener("click", async () => {
    const text = snapText.value.trim();
    if (!text) {
      alert("Paste content into the main text box first.");
      return;
    }

    // usage gate
    if (window.__canUseAIOnce) {
      const allowed = await window.__canUseAIOnce();
      if (!allowed) return;
    } else if (window.__canUseAIOnceAnon && !window.__canUseAIOnceAnon()) {
      return;
    }

    cardsResult.textContent = "Thinking...";

    try {
      if (typeof runFlashcards !== "function") {
        throw new Error(
          "runFlashcards() is not defined. Check your TASK HELPERS section."
        );
      }

      const ans = await runFlashcards(text);
      const answerText = typeof ans === "string" ? ans : String(ans ?? "");

      // styled output with copy button
      renderAnswer(cardsResult, answerText);

      const parsed = parseFlashcardsFromText(answerText);
      if (!parsed.length) {
        cardsViewer.style.display = "none";
        alert("I couldn't detect any Q/A pairs in the AI output.");
        addNotebookItem("Cards", answerText);
        return;
      }

      flashcards = parsed;
      currentCardIndex = 0;
      saveFlashcards(flashcards);
      renderCurrentCard();

      addNotebookItem("Cards", answerText);
    } catch (err) {
      console.error("Flashcards error:", err);
      cardsResult.textContent = "⚠️ Flashcards error: " + err.message;
    }
  });

  cardsClearBtn.addEventListener("click", () => {
    cardsResult.textContent = "";
    flashcards = [];
    currentCardIndex = 0;
    showingBack = false;
    saveFlashcards(flashcards);
    if (cardsViewer) cardsViewer.style.display = "none";
  });

  cardsFlipBtn.addEventListener("click", () => {
    if (!flashcards.length) return;
    showingBack = !showingBack;
    cardsFront.style.display = showingBack ? "none" : "block";
    cardsBack.style.display = showingBack ? "block" : "none";
  });

  function goToNextCard() {
    if (!flashcards.length) return;
    currentCardIndex = (currentCardIndex + 1) % flashcards.length;
    renderCurrentCard();
  }

  cardsGotItBtn.addEventListener("click", () => {
    if (!flashcards.length) return;
    const card = flashcards[currentCardIndex];
    card.status = "got";
    card.seen = (card.seen || 0) + 1;
    card.correct = (card.correct || 0) + 1;
    card.lastSeen = Date.now();
    saveFlashcards(flashcards);

    // optional positive sound on Got It
    if (ENABLE_FLASHCARD_SOUND && gotItAudio) {
      try {
        gotItAudio.currentTime = 0;
        gotItAudio.play();
      } catch (e) {
        // ignore play errors
      }
    }

    // New: single colorful phrase burst from the Got it button
    spawnGotItBurst(cardsGotItBtn);

    goToNextCard();
  });

  cardsNeedWorkBtn.addEventListener("click", () => {
    if (!flashcards.length) return;
    const card = flashcards[currentCardIndex];
    card.status = "need_work";
    card.seen = (card.seen || 0) + 1;
    card.lastSeen = Date.now();
    saveFlashcards(flashcards);
    goToNextCard();
  });
</script>






<!-- BLOCK 9: Simplify and hitn    t “pill” buttons -->
<script>
// SIMPLIFY + HINT BUTTONS (styled with renderAnswer)
document.querySelectorAll(".pill-button").forEach((btn) => {
  btn.addEventListener("click", async () => {
    // no counting here
    const action = btn.dataset.action;
    const targetId = btn.dataset.target;
    if (!action || !targetId) return;

    const outputEl = document.getElementById(targetId);
    if (!outputEl) return;

    // plain text version of whatever is currently shown
    const currentPlain =
      (outputEl.dataset && outputEl.dataset.plainText) ||
      outputEl.textContent.trim();
    if (!currentPlain) {
      alert("Nothing to process yet.");
      return;
    }

    if (action === "simplify") {
      outputEl.textContent = "Simplifying...";
      const ans = await runSimplify(currentPlain);
      const clean = sanitizeAnswerText(ans);
      renderAnswer(outputEl, clean);
      addNotebookItem("Simplified", clean);
    } else if (action === "hint") {
      const questionText = snapText.value || mathInput.value || "";
      const ans = await runHint(questionText, currentPlain);
      const cleanHint = sanitizeAnswerText(ans);

      const combined = currentPlain + "\n\nHint:\n" + cleanHint;
      renderAnswer(outputEl, combined);
      addNotebookItem("Hint", cleanHint);
    }
  });
});
</script>

<!-- BLOCK X: Snap hint row — send OCR text to other tools -->
<script>
  (function () {
    const snapText = document.getElementById("snapText");

    function wireSnapAction(buttonId, inputId, tabId) {
      const btn = document.getElementById(buttonId);
      const input = document.getElementById(inputId);
      if (!btn || !input) return;

      btn.addEventListener("click", () => {
        const text = snapText.value.trim();
        if (!text) {
          alert("No OCR text yet. Run OCR or type something first.");
          return;
        }
        input.value = text;

        // Switch to the corresponding tab if activateTab exists
        if (typeof activateTab === "function" && tabId) {
          activateTab(tabId);
        }
      });
    }

    // Now use the same action buttons that live in the Snap hint row
    wireSnapAction("mathSolveBtn", "mathInput", "math");
    wireSnapAction("studyGuideBtn", "studyInput", "study");
    wireSnapAction("essayBtn", "essayInput", "essay");
    wireSnapAction("cardsBtn", "cardsInput", "flashcards");

  })();
</script>

<!-- BLOCK: Completion animations (non-invasive wrappers) -->
<script>
  (function () {
    function animatePulse(el) {
      if (!el) return;
      el.classList.remove("pulse-once");
      // force reflow so animation can retrigger
      void el.offsetWidth;
      el.classList.add("pulse-once");
    }

    // make available if you ever want to call it manually
    window.__animatePulse = animatePulse;

    // After OCR completes -> highlight snapText
    if (typeof window.runFakeOCR === "function") {
      const _runFakeOCR = window.runFakeOCR;
      window.runFakeOCR = async function (file) {
        const result = await _runFakeOCR(file);
        setTimeout(() => {
          const snapText = document.getElementById("snapText");
          animatePulse(snapText);
        }, 0);
        return result;
      };
    }

    // After Snap & Solve completes -> highlight snapResult
    if (typeof window.runSnapSolve === "function") {
      const _runSnapSolve = window.runSnapSolve;
      window.runSnapSolve = async function (text) {
        const result = await _runSnapSolve(text);
        setTimeout(() => {
          const snapResult = document.getElementById("snapResult");
          animatePulse(snapResult);
        }, 0);
        return result;
      };
    }

    // After Math Solver -> highlight mathResult
    if (typeof window.runMathSolver === "function") {
      const _runMathSolver = window.runMathSolver;
      window.runMathSolver = async function (text) {
        const result = await _runMathSolver(text);
        setTimeout(() => {
          const el = document.getElementById("mathResult");
          animatePulse(el);
        }, 0);
        return result;
      };
    }

    // After Study Guide -> highlight studyResult
    if (typeof window.runStudyGuide === "function") {
      const _runStudyGuide = window.runStudyGuide;
      window.runStudyGuide = async function (text) {
        const result = await _runStudyGuide(text);
        setTimeout(() => {
          const el = document.getElementById("studyResult");
          animatePulse(el);
        }, 0);
        return result;
      };
    }

    // After Essay Helper -> highlight essayResult
    if (typeof window.runEssayHelper === "function") {
      const _runEssayHelper = window.runEssayHelper;
      window.runEssayHelper = async function (text) {
        const result = await _runEssayHelper(text);
        setTimeout(() => {
          const el = document.getElementById("essayResult");
          animatePulse(el);
        }, 0);
        return result;
      };
    }

    // After Quiz Maker -> highlight quizResult
    if (typeof window.runQuiz === "function") {
      const _runQuiz = window.runQuiz;
      window.runQuiz = async function (text) {
        const result = await _runQuiz(text);
        setTimeout(() => {
          const el = document.getElementById("quizResult");
          animatePulse(el);
        }, 0);
        return result;
      };
    }

    // After Flashcards generation -> highlight viewer (or raw result)
    if (typeof window.runFlashcards === "function") {
      const _runFlashcards = window.runFlashcards;
      window.runFlashcards = async function (text) {
        const result = await _runFlashcards(text);
        setTimeout(() => {
          const viewer = document.getElementById("cardsViewer");
          const resultEl = document.getElementById("cardsResult");
          animatePulse(viewer || resultEl);
        }, 0);
        return result;
      };
    }
  })();
</script>

<script>
  (function () {
    // in case __animatePulse isn't defined for some reason
    if (!window.__animatePulse) {
      window.__animatePulse = function (el) {
        if (!el) return;
        el.classList.remove("pulse-once");
        void el.offsetWidth;
        el.classList.add("pulse-once");
      };
    }

    // All the "big action" buttons (now all in Snap hint row + OCR)
    const buttons = document.querySelectorAll([
      "#snapOCRBtn",
      "#snapActionSolveBtn",
      "#mathSolveBtn",
      "#studyGuideBtn",
      "#essayBtn",
      "#cardsBtn",
    ].join(","));

    buttons.forEach((btn) => {
      if (!btn) return;
      btn.addEventListener("click", () => {
        window.__animatePulse(btn);
      });
    });
  })();
</script>

<!--Anonymous usage limiter-->
<script>
  (function () {
    // ---- Anonymous usage limiter (10 total uses before requiring login) ----

    const ANON_LIMIT = 10;
    const STORAGE_KEY = "passinggrade-anon-uses";

    // 🔹 New: monthly free limit for logged-in users
    const FREE_MONTHLY_LIMIT = 10; // change this number whenever you want

    // 🔹 Helper: refresh header label if updateAuthUI exists
    function refreshUsageLabel() {
      try {
        if (typeof window.updateAuthUI === "function") {
          window.updateAuthUI();
        }
      } catch (e) {
        console.error("updateAuthUI from limiter failed", e);
      }
    }

    function getAnonUses() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        return raw ? parseInt(raw, 10) || 0 : 0;
      } catch {
        return 0;
      }
    }

    function setAnonUses(count) {
      try {
        localStorage.setItem(STORAGE_KEY, String(count));
      } catch {
        // ignore
      }
    }

    function showAnonLimitReached() {
      alert(
        "You’ve used PassingGrade 10 times.\n\nTap ‘Sign in’ at the top right to create a free account and get 10 questions every month."
      );
    }

    // Call this before doing any AI action (for guests)
    function canUseAIOnceAnon() {
      const uses = getAnonUses();
      if (uses >= ANON_LIMIT) {
        showAnonLimitReached();
        return false;
      }
      setAnonUses(uses + 1);
      refreshUsageLabel();   // 🔹 update header for guests
      return true;
    }

    // Expose so we can call from existing handlers
    window.__canUseAIOnceAnon = canUseAIOnceAnon;

    // 🔹 Auth-aware helper:
    // - Not logged in            -> use anon localStorage limiter
    // - Logged in & plan='pro'   -> unlimited, but still increments OCR usage
    // - Logged in & plan!='pro'  -> 10/month OCR limit using Supabase
    async function canUseAIOnce() {
      try {
        if (!window.supabaseClient) {
          // No Supabase client available, fall back to anon behavior
          return window.__canUseAIOnceAnon();
        }

        const {
          data: { user },
          error: userError,
        } = await window.supabaseClient.auth.getUser();

        if (userError || !user) {
          // Not logged in -> still use the anon localStorage limit
          return window.__canUseAIOnceAnon();
        }

        // 🔹 Look up this user's plan from user_plans
        let isPaid = false;

        try {
          const { data: planRow, error: planError } = await window.supabaseClient
            .from("user_plans")
            .select("plan")
            .eq("user_id", user.id)
            .maybeSingle();

          if (planError) {
            console.error("error reading user_plans", planError);
          }

          const plan = planRow?.plan || "free";
          isPaid = plan === "pro";
        } catch (planEx) {
          console.error("exception reading user_plans", planEx);
        }

        // 🔹 Pro plan -> no 10/month cap, but still track OCR usage
        if (isPaid) {
          const { error: rpcErrorPaid } = await window.supabaseClient.rpc(
            "increment_usage",
            {
              p_action: "ocr",
              p_amount: 1,
            }
          );

          if (rpcErrorPaid) {
            console.error(
              "increment_usage failed for paid user",
              rpcErrorPaid
            );
          }

          refreshUsageLabel();   // 🔹 update header for Pro users too
          return true;
        }

        // 🔹 Everyone else = 10/month OCR limit

        // Figure out the first day of this month as YYYY-MM-01
        const now = new Date();
        const month = String(now.getMonth() + 1).padStart(2, "0");
        const periodStart = `${now.getFullYear()}-${month}-01`;

        // Read this month's OCR usage row
        const { data: row, error: selectError } = await window.supabaseClient
          .from("usage_counters")
          .select("count")
          .eq("user_id", user.id)
          .eq("period_start", periodStart)
          .eq("action", "ocr")
          .maybeSingle();

        if (selectError) {
          console.error("error reading usage", selectError);
          // Don't block on read error – allow and still try to increment
        }

        const currentCount = row?.count || 0;

        if (currentCount >= FREE_MONTHLY_LIMIT) {
          alert(
            "You’ve used your " +
              FREE_MONTHLY_LIMIT +
              " free questions for this month.\n\nUpgrade your plan to keep using PassingGrade."
          );
          return false;
        }

        // Logged in and under limit -> bump OCR usage in Supabase
        const { error: rpcError } = await window.supabaseClient.rpc(
          "increment_usage",
          {
            p_action: "ocr",
            p_amount: 1,
          }
        );

        if (rpcError) {
          console.error("increment_usage failed", rpcError);
        }

        refreshUsageLabel();   // 🔹 update header for free logged-in users
        return true;
      } catch (err) {
        console.error("canUseAIOnce error", err);
        // On any error, don't break the app – just allow usage
        return true;
      }
    }

    // Expose new async helper
    window.__canUseAIOnce = canUseAIOnce;
  })();
</script>






<!-- Supabase client library (from CDN) -->
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

<!-- PassingGrade auth setup (Supabase) -->
<!-- PassingGrade auth setup (Supabase) -->
<script>
  const SUPABASE_URL = "https://rwjijfffirbpmkhcptrb.supabase.co";
  const SUPABASE_ANON_KEY =
    "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJ3amlqZmZmaXJicG1raGNwdHJiIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjUwMzYxNDgsImV4cCI6MjA4MDYxMjE0OH0.Lfv2HGMbdyyjF_SUA-7rWWN5XpvaLX8I36-upjH8_nQ";

  // Create a single Supabase client for the page
  const supabaseClient = window.supabase.createClient(
    SUPABASE_URL,
    SUPABASE_ANON_KEY
  );
  window.supabaseClient = supabaseClient;

  // Test helper (manual)
  async function testIncrementUsage() {
    const { error } = await supabaseClient.rpc("increment_usage", {
      p_action: "ocr",
      p_amount: 1,
    });

    if (error) {
      console.error("increment_usage failed", error);
    } else {
      console.log("increment_usage succeeded");
    }
  }

  // Read current OCR usage for the logged-in user (console helper)
  async function showCurrentUsage() {
    const {
      data: { user },
      error: userError,
    } = await supabaseClient.auth.getUser();

    if (userError || !user) {
      console.error("no logged-in user", userError);
      return;
    }

    // First day of this month (dynamic)
    const now = new Date();
    const month = String(now.getMonth() + 1).padStart(2, "0");
    const periodStart = `${now.getFullYear()}-${month}-01`;

    const { data, error } = await supabaseClient
      .from("usage_counters")
      .select("*")
      .eq("user_id", user.id)
      .eq("period_start", periodStart)
      .eq("action", "ocr")
      .maybeSingle();

    if (error) {
      console.error("error reading usage", error);
    } else {
      console.log("current usage row:", data);
    }
  }

  // --- handle OAuth tokens in URL (hash OR query) ---
  async function handleAuthFromUrl() {
    // Supabase / Google might put tokens in the hash (#...) or query (?...).
    const raw = window.location.hash || window.location.search || "";
    if (!raw) return;

    const qs = raw.replace(/^[#?]/, "");
    const params = new URLSearchParams(qs);
    const accessToken = params.get("access_token");
    const refreshToken = params.get("refresh_token");

    if (!accessToken || !refreshToken) return;

    try {
      await supabaseClient.auth.setSession({
        access_token: accessToken,
        refresh_token: refreshToken,
      });

      // Clean the URL (remove tokens from address bar)
      window.history.replaceState(
        {},
        document.title,
        window.location.pathname + window.location.search
      );
    } catch (err) {
      console.error("Error setting session from OAuth redirect:", err);
    }
  }

  // Internal helper to read a specific user's plan (by USER_ID now)
  async function fetchUserPlan(userId) {
    try {
      const { data, error } = await supabaseClient
        .from("user_plans")
        .select("plan")
        .eq("user_id", userId)
        .maybeSingle();

      if (error) {
        console.error("error loading user plan", error);
        return "free";
      }

      return data?.plan || "free";
    } catch (e) {
      console.error("fetchUserPlan exception", e);
      return "free";
    }
  }

  // Simple helper to update the header status text + button label
  async function updateAuthUI() {
    const userPlanLabel = document.getElementById("userPlanLabel");
    const authButton = document.getElementById("authButton");

    if (!userPlanLabel || !authButton) return;

    // Check if user is logged in
    const { data, error } = await supabaseClient.auth.getUser();

    // Not logged in
    if (error || !data.user) {
      // 🔹 Read guest usage from the same localStorage key the limiter uses
      let anonUses = 0;
      try {
        const raw = localStorage.getItem("passinggrade-anon-uses");
        anonUses = raw ? parseInt(raw, 10) || 0 : 0;
      } catch (e) {
        anonUses = 0;
      }
      const limit = 10;

      userPlanLabel.textContent =
        `Guest · ${anonUses}/${limit} free OCR scans`;

      authButton.textContent = "Sign in";
      authButton.dataset.authState = "signed-out";
      return;
    }

    const user = data.user;
    const email = user.email || "";
    const namePart = email.split("@")[0] || "your account";

    // Read plan from user_plans (free / pro) BY USER_ID
    const plan = await fetchUserPlan(user.id);
    const isPro = plan === "pro";

    let usageText = "";

    try {
      // Same month logic as limiter: YYYY-MM-01
      const now = new Date();
      const month = String(now.getMonth() + 1).padStart(2, "0");
      const periodStart = `${now.getFullYear()}-${month}-01`;

      // Read this month's OCR usage row
      const { data: row, error: usageError } = await supabaseClient
        .from("usage_counters")
        .select("count")
        .eq("user_id", user.id)
        .eq("period_start", periodStart)
        .eq("action", "ocr")
        .maybeSingle();

      if (usageError) {
        console.error("usage label read error", usageError);
      }

      const currentCount = row?.count || 0;

      if (isPro) {
        // Pro: no /10 cap
        usageText = ` · ${currentCount} uses this month`;
      } else {
        // Free: show count out of 10
        usageText = ` · ${currentCount}/10 uses this month`;
      }
    } catch (e) {
      console.error("usage label exception", e);
    }

    // Build label: no "Pro plan" text for Pro users
    let label = `signed in as ${namePart}`;
    if (!isPro) {
      label = `Free plan · ${label}`;
    }

    userPlanLabel.textContent = `${label}${usageText}`;
    authButton.textContent = "Sign out";
    authButton.dataset.authState = "signed-in";
  }

  // Handle click on the auth button (Sign in / Sign out) – GOOGLE OAUTH
  async function handleAuthButtonClick() {
    const authButton = document.getElementById("authButton");
    if (!authButton) return;

    const state = authButton.dataset.authState || "signed-out";

    if (state === "signed-in") {
      // Sign out
      await supabaseClient.auth.signOut();
      await updateAuthUI();
      alert("Signed out.");
      return;
    }

    // Signed out → Google OAuth sign-in
    try {
      const { error } = await supabaseClient.auth.signInWithOAuth({
        provider: "google",
        options: {
          // Must match your Supabase Auth "Site URL"
          redirectTo: "https://passinggrade.app",
        },
      });

      if (error) {
        console.error("Google sign-in error:", error);
        alert("Error starting Google sign-in. Please try again.");
        return;
      }
    } catch (err) {
      console.error("OAuth error:", err);
      alert("Error starting sign-in. Please try again.");
    }
  }

  // Wire things up once the DOM is ready
  document.addEventListener("DOMContentLoaded", async () => {
    // 1) If we just came back from Google/Supabase, set the session
    await handleAuthFromUrl();

    // 2) Wire the button
    const authButton = document.getElementById("authButton");
    if (authButton) {
      authButton.addEventListener("click", handleAuthButtonClick);
    }

    // 3) Update header (will now see the session if it was set)
    updateAuthUI();
  });

  // Global helper: check the current logged-in user's plan (free/pro)
  window.getCurrentUserPlan = async function () {
    try {
      const { data, error } = await supabaseClient.auth.getUser();
      if (error || !data.user) {
        console.warn("no logged-in user for getCurrentUserPlan", error);
        return null;
      }

      const user = data.user;
      return await fetchUserPlan(user.id);
    } catch (e) {
      console.error("getCurrentUserPlan exception", e);
      return "free";
    }
  };
</script>

<script>
  document.addEventListener("DOMContentLoaded", () => {
    const upgradeBtn = document.getElementById("upgradeButton");
    const proBadge = document.getElementById("proBadge");

    // 🔹 1) Check plan on page load
    (async () => {
      try {
        const { data, error } = await supabaseClient.auth.getUser();
        if (error || !data.user) {
          // not logged in -> leave button visible, they can click & get "please sign in" message
          return;
        }

        const user = data.user;

        // Look up their plan by email
        // Look up their plan by user_id
        const { data: planRow, error: planError } = await supabaseClient
          .from("user_plans")
          .select("plan")
          .eq("user_id", user.id)
          .maybeSingle();

        if (!planError && planRow && planRow.plan === "pro") {
          // ✅ Already Pro: hide Upgrade button, show badge
          if (upgradeBtn) upgradeBtn.style.display = "none";
          if (proBadge) proBadge.style.display = "inline-block";
        }
      } catch (e) {
        console.error("Error checking user plan", e);
      }
    })();

    // 🔹 2) Upgrade click handler
    if (!upgradeBtn) return;

    upgradeBtn.addEventListener("click", async () => {
      // Require login
      let user;
      try {
        const { data, error } = await supabaseClient.auth.getUser();

        if (error || !data.user) {
          alert("Please sign in first before upgrading to Pro.");
          return;
        }

        user = data.user;
      } catch (e) {
        console.error("Error checking auth before upgrade", e);
        alert("Could not verify your login. Please sign in again and try.");
        return;
      }

      const originalText = upgradeBtn.textContent;
      upgradeBtn.disabled = true;
      upgradeBtn.textContent = "Opening checkout...";

      try {
        const res = await fetch("/api/create-checkout-session", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            userId: user.id,
            email: user.email,
          }),
        });

        if (!res.ok) {
          throw new Error("Network error: " + res.status);
        }

        const data = await res.json();
        if (!data.url) {
          throw new Error("No checkout URL returned");
        }

        window.location.href = data.url;
      } catch (err) {
        console.error("Upgrade error", err);
        alert("Could not start checkout. Please try again in a moment.");
        upgradeBtn.disabled = false;
        upgradeBtn.textContent = originalText;
      }
    });
  });
</script>



<!-- MAKE TEXT AREAS GROW -->
<script>
  (function () {
    function autoResize(ta) {
      if (!ta) return;
      ta.style.height = "auto";
      ta.style.overflowY = "hidden";
      ta.style.height = ta.scrollHeight + "px";
    }

    // expose so other scripts can call it
    window.autoResizeTextarea = autoResize;

    document.addEventListener("DOMContentLoaded", () => {
      const textareas = document.querySelectorAll("textarea");
      textareas.forEach((ta) => {
        autoResize(ta);
        ta.addEventListener("input", () => autoResize(ta));
      });
    });
  })();
</script>


<!--copy icons for text boxes-->
<script>
  document.addEventListener("DOMContentLoaded", () => {
    const copySnapTextBtn = document.getElementById("copySnapTextBtn");
    const snapText = document.getElementById("snapText");

    if (!copySnapTextBtn || !snapText) return;

    const labelSpan = copySnapTextBtn.querySelector(".copy-label");

    copySnapTextBtn.addEventListener("click", async () => {
      try {
        await navigator.clipboard.writeText(snapText.value || "");

        if (labelSpan) {
          const old = labelSpan.textContent;
          labelSpan.textContent = "Copied!";
          setTimeout(() => {
            labelSpan.textContent = old;
          }, 1200);
        }
      } catch (err) {
        console.error("Copy failed", err);
      }
    });
  });
</script>


<!--OCR BUTTONS DROPDOWN MENU-->
<script>
  document.addEventListener("DOMContentLoaded", () => {
    const toggle = document.getElementById("snapActionsToggle");
    const menu = document.getElementById("snapActionsMenu");
    if (!toggle || !menu) return;

    toggle.addEventListener("click", (e) => {
      e.stopPropagation();
      const open = menu.style.display === "block";
      menu.style.display = open ? "none" : "block";
    });

    document.addEventListener("click", (e) => {
      if (!menu.contains(e.target) && !toggle.contains(e.target)) {
        menu.style.display = "none";
      }
    });
  });
</script>


<!--closes header menu drop down-->
<script>
  document.addEventListener("DOMContentLoaded", () => {
    const menu = document.querySelector(".header-menu");
    if (!menu) return;

    const inner = menu.querySelector(".header-menu-inner");
    if (!inner) return;

    inner.addEventListener("click", (e) => {
      const clickable = e.target.closest("button, .chip");
      if (!clickable) return;

      const details = clickable.closest("details");
      if (details) {
        details.removeAttribute("open"); // closes the <details>
      }
    });
  });
</script>
<!--TEXT ACTIONS DROP DOWN-->
<script>
  // Text actions dropdown (Solve / Math / Study / Essay / Flashcards)
  const textActionsToggle = document.getElementById("textActionsToggle");
  const textActionsMenu   = document.getElementById("textActionsMenu");

  if (textActionsToggle && textActionsMenu) {
    // Toggle open/close when clicking the summary button
    textActionsToggle.addEventListener("click", (e) => {
      e.stopPropagation();
      const isOpen = textActionsMenu.style.display === "block";
      textActionsMenu.style.display = isOpen ? "none" : "block";
    });

    // Close when any action button inside the menu is clicked
    textActionsMenu.addEventListener("click", (e) => {
      const btn = e.target.closest("button");
      if (!btn) return;
      textActionsMenu.style.display = "none";
      // let the existing click handler for that button run as normal
    });

    // Close when clicking anywhere outside
    document.addEventListener("click", (e) => {
      if (
        !textActionsMenu.contains(e.target) &&
        !textActionsToggle.contains(e.target)
      ) {
        textActionsMenu.style.display = "none";
      }
    });
  }
</script>

<!--Notebook drop downs-->
<script>
  document.querySelectorAll('.nb-dropdown').forEach((dd) => {
    dd.addEventListener('click', (e) => {
      const btn = e.target.closest('button');
      if (btn && !btn.classList.contains('nb-dropdown-toggle')) {
        // close the dropdown after choosing something
        dd.removeAttribute('open');
      }
    });
  });
</script>
<!-- AUTOFILL HELPER -->
<script>
  // Helper: pull a reasonable "heading" out of the OCR text
  function extractHeadingFromOcrText(ocrText) {
    if (!ocrText) return "";

    // Split into lines, trim, and drop empty lines
    const lines = String(ocrText)
      .split(/\r?\n/)
      .map(line => line.trim())
      .filter(Boolean);

    if (!lines.length) return "";

    let first = lines[0];

    // Normalize whitespace
    first = first.replace(/\s+/g, " ");

    // Optional: cap length so subjects don't get huge
    const MAX_LEN = 80;
    if (first.length > MAX_LEN) {
      first = first.slice(0, MAX_LEN - 3) + "...";
    }

    return first;
  }

  function initAutoSubjectFromSnap() {
    const snapTextEl = document.getElementById("snapText");
    const subjectEl  = document.getElementById("saveSubjectInput");
    if (!snapTextEl || !subjectEl) return;

    // Track if the user has actually edited the subject
    let userEditedSubject = false;

    // If user types anything (not just "General"), stop auto-overwriting
    subjectEl.addEventListener("input", () => {
      const v = (subjectEl.value || "").trim();
      if (v && v.toLowerCase() !== "general") {
        userEditedSubject = true;
      } else if (!v) {
        // If they clear it completely, allow auto-fill again
        userEditedSubject = false;
      }
    });

    function maybeAutoFillSubject() {
      if (userEditedSubject) return;

      const heading = extractHeadingFromOcrText(snapTextEl.value || "");
      if (heading) {
        subjectEl.value = heading;
      }
    }

    // When OCR puts text in (or user pastes/types)
    snapTextEl.addEventListener("input", () => {
      maybeAutoFillSubject();
    });

    // Run once on load in case text is already there
    maybeAutoFillSubject();

    // Expose for other scripts to call directly if they want
    window.maybeAutoFillSubjectFromOcr = maybeAutoFillSubject;
    // Also expose under the alternate name some code might be using
    window.maybeFillSubjectFromOcrNow = maybeAutoFillSubject;
  }

  document.addEventListener("DOMContentLoaded", initAutoSubjectFromSnap);
</script>


<script>
  // ==========================================================
  // Extract Notes tool
  // - Uses #snapText as input (OCR or pasted)
  // - Shows result in #notesResult (Notes tool tab)
  // - Triggered by #notesBtn in the Text actions dropdown
  // ==========================================================

  // AI helper: ask backend to extract key bullet-point notes
  async function runExtractNotes(text) {
    const cheat = window.__cheatMode; // your existing global

    const basePrompt =
      "You are helping a student turn messy homework/textbook text into short, high-yield notes.\n" +
      "From the text below, extract ONLY the most important points as a bullet list.\n" +
      "- Prefer short bullets\n" +
      "- Focus on key facts, definitions, steps, formulas, dates, and names\n" +
      "- Do NOT rewrite the whole passage\n" +
      "- Return plain text only. Use '-' or '•' at the start of each bullet.\n\n" +
      "Text:\n" +
      text.trim();

    const cheatPrompt =
      "From this text, return ONLY the most important bullet-point notes.\n" +
      "Make 5–20 very short bullets. No intro, no conclusion.\n\n" +
      "Text:\n" +
      text.trim();

    const prompt = cheat ? cheatPrompt : basePrompt;

    const result = await callAI({
      prompt,
      task: "extract_notes",   // new task name for your backend if you want
    });

    return typeof result === "string" ? result : String(result ?? "");
  }

  document.addEventListener("DOMContentLoaded", () => {
    const snapText    = document.getElementById("snapText");
    const notesInput  = document.getElementById("notesInput");
    const notesResult = document.getElementById("notesResult");
    const notesBtn    = document.getElementById("notesBtn");
    const notesClear  = document.getElementById("notesClearBtn");

    if (!snapText || !notesInput || !notesResult || !notesBtn) {
      console.warn("[Extract Notes] Missing elements; not wired up.");
      return;
    }

    // Simple loading wrapper using your existing helpers if present
    function startNotesLoading(label) {
      if (typeof startResultLoading === "function") {
        startResultLoading(notesResult, label || "Finding key points");
      } else {
        notesResult.textContent = label || "Finding key points...";
      }
    }

    function stopNotesLoading() {
      if (typeof stopResultLoading === "function") {
        stopResultLoading(notesResult);
      }
    }

    // Main button (in Text actions dropdown)
    notesBtn.addEventListener("click", async () => {
      const text = snapText.value.trim();
      if (!text) {
        alert("Paste or OCR some text into the main Snap box first.");
        return;
      }

      // copy into hidden textarea (for consistency with other tools)
      notesInput.value = text;

      // switch to Notes tab
      if (typeof activateTab === "function") {
        activateTab("notes");
      }

      // usage limiter (same pattern as other tools)
      if (window.__canUseAIOnce) {
        const allowed = await window.__canUseAIOnce();
        if (!allowed) return;
      } else if (window.__canUseAIOnceAnon && !window.__canUseAIOnceAnon()) {
        return;
      }

      startNotesLoading("Finding key points");

      try {
        const raw = await runExtractNotes(text);
        stopNotesLoading();

        const clean = raw.trim(); // keep bullets, don't sanitize them away

        // render with your styled output helper if available
        if (typeof renderAnswer === "function") {
          renderAnswer(notesResult, clean);
        } else {
          notesResult.textContent = clean;
        }

        // save to Notebook as a separate type
        if (typeof addNotebookItem === "function") {
          addNotebookItem("Notes", clean);
        }
      } catch (err) {
        console.error("[Extract Notes] error:", err);
        stopNotesLoading();
        notesResult.textContent = "⚠️ Error extracting notes: " + err.message;
      }
    });

    // Clear button inside Notes tool
    if (notesClear) {
      notesClear.addEventListener("click", () => {
        notesInput.value = "";
        notesResult.textContent = "";
      });
    }
  });
</script>




<script>
  // When "Run OCR" is clicked:
  // 1) close the Image actions dropdown
  // 2) scroll to the Snap text box
  document.addEventListener("DOMContentLoaded", () => {
    const snapOCRBtn       = document.getElementById("snapOCRBtn");
    const snapText         = document.getElementById("snapText");
    const snapActionsMenu  = document.getElementById("snapActionsMenu");

    if (!snapOCRBtn || !snapText) return;

    snapOCRBtn.addEventListener("click", () => {
      // Close the dropdown
      if (snapActionsMenu) {
        snapActionsMenu.style.display = "none";
      }

      // Smooth-scroll to the Snap textbox
      setTimeout(() => {
        snapText.scrollIntoView({
          behavior: "smooth",
          block: "center"
        });
      }, 50);
    });
  });
</script>




<script>
  // Simple formatter templates for college styles
  const OUTPUT_FORMATTERS = {
    plain: function (text) {
      return text;
    },

    mla: function (text) {
      return [
        "Your Name",
        "Professor Lastname",
        "Course Name",
        "Day Month Year",
        "",
        "(Double-spaced, Times New Roman 12, 1\" margins when you paste into Word/Docs.)",
        "",
        text
      ].join("\n");
    },

    apa: function (text) {
      return [
        "Title of Paper",
        "",
        "Your Name",
        "Department, University Name",
        "Course Name and Number",
        "Instructor Name",
        "Due Date",
        "",
        "(APA 7 student paper – double-spaced, 1\" margins, page number in header.)",
        "",
        text
      ].join("\n");
    },

    chicago: function (text) {
      return [
        "Title of Paper",
        "",
        "Your Name",
        "",
        "(Chicago / Turabian – set 1\" margins, double-space, and add notes/bibliography in your doc.)",
        "",
        text
      ].join("\n");
    },

    ieee: function (text) {
      return [
        "Paper Title",
        "",
        "Author Name, Department, University",
        "",
        "(IEEE – usually two-column layout, numbered references; adjust in your editor.)",
        "",
        text
      ].join("\n");
    }
  };

  function setupOutputFormatControls() {
    const applyButtons = document.querySelectorAll(".output-format-apply");

    applyButtons.forEach(function (btn) {
      btn.addEventListener("click", function () {
        const targetId = btn.getAttribute("data-target");
        if (!targetId) return;

        const pre = document.getElementById(targetId);
        if (!pre) return;

        const select = document.querySelector(
          '.output-format-select[data-target="' + targetId + '"]'
        );
        if (!select) return;

        const formatKey  = select.value || "plain";
        const formatter  = OUTPUT_FORMATTERS[formatKey] || OUTPUT_FORMATTERS.plain;
        const currentTxt = pre.textContent || "";

        // (Re)capture original text whenever we finally have some content
        if (
          (!pre.dataset.originalText || !pre.dataset.originalText.trim()) &&
          currentTxt.trim()
        ) {
          pre.dataset.originalText = currentTxt;
        }

        const base =
          (pre.dataset.originalText && pre.dataset.originalText.trim())
            ? pre.dataset.originalText
            : currentTxt;

        // Apply chosen format to the base text (not to already formatted text)
        pre.textContent = formatter(base);
      });
    });
  }

  // Run once when the page is ready
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", setupOutputFormatControls);
  } else {
    setupOutputFormatControls();
  }
</script>


<script>
  (function () {
    function onReady(fn) {
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", fn);
      } else {
        fn();
      }
    }

    onReady(function () {
      setupStickyLoop();
      setupProgressMetrics();
      wireMobileToggles();
    });

    /* ---------- 1. Generic looping behavior for [data-sticky-loop] containers ---------- */

    function setupStickyLoop() {
      var containers = document.querySelectorAll("[data-sticky-loop]");
      containers.forEach(function (container) {
        var rotator = container.querySelector("#pg-loop-metrics-rotator");
        if (!rotator) return;

        var items = Array.from(rotator.querySelectorAll(".pg-loop-item"));
        if (items.length <= 1) return;

        var intervalMs = parseInt(
          container.getAttribute("data-loop-interval") || "6000",
          10
        );
        var index = 0;

        setInterval(function () {
          items[index].classList.remove("pg-loop-item--active");
          index = (index + 1) % items.length;
          items[index].classList.add("pg-loop-item--active");
        }, intervalMs);
      });
    }

    /* ---------- 2. Streaks + weekly recap + session count ---------- */

    function setupProgressMetrics() {
      try {
        var now = new Date();
        var todayKey = now.toISOString().slice(0, 10); // YYYY-MM-DD

        var lastVisit = localStorage.getItem("pg_last_visit");
        var streakStr = localStorage.getItem("pg_streak") || "0";
        var streak = parseInt(streakStr, 10) || 0;

        if (!lastVisit) {
          streak = 1;
        } else if (lastVisit !== todayKey) {
          var lastDate = new Date(lastVisit + "T00:00:00");
          var diff =
            (Date.UTC(now.getFullYear(), now.getMonth(), now.getDate()) -
              Date.UTC(
                lastDate.getFullYear(),
                lastDate.getMonth(),
                lastDate.getDate()
              )) /
            (1000 * 60 * 60 * 24);

          if (diff === 1) {
            streak += 1;
          } else if (diff > 1) {
            streak = 1; // streak broken
          }
        }

        localStorage.setItem("pg_last_visit", todayKey);
        localStorage.setItem("pg_streak", String(streak));

        // Weekly active days (Mon–Sun)
        var activeDaysRaw = localStorage.getItem("pg_active_days");
        var activeDays = activeDaysRaw ? JSON.parse(activeDaysRaw) : {};
        activeDays[todayKey] = true;
        localStorage.setItem("pg_active_days", JSON.stringify(activeDays));

        var weeklyCount = countActiveDaysThisWeek(activeDays, now);

        // Simple “session count”: increment when page is loaded
        var sessionsRaw = localStorage.getItem("pg_sessions_this_week") || "0";
        var sessions = parseInt(sessionsRaw, 10) || 0;
        var weekKey = getWeekKey(now);
        var lastWeekKey = localStorage.getItem("pg_sessions_week_key");

        if (lastWeekKey !== weekKey) {
          // new week -> reset
          sessions = 0;
        }
        sessions += 1;

        localStorage.setItem("pg_sessions_this_week", String(sessions));
        localStorage.setItem("pg_sessions_week_key", weekKey);

        // Write into the pills
        var streakNode = document.querySelector("[data-pg-streak-value]");
        if (streakNode) {
          streakNode.textContent =
            streak + " day" + (streak === 1 ? "" : "s") + " in a row";
        }

        var weeklyNode = document.querySelector("[data-pg-weekly-summary]");
        if (weeklyNode) {
          weeklyNode.textContent =
            weeklyCount +
            " active day" +
            (weeklyCount === 1 ? "" : "s") +
            " this week";
        }

        var sessionsNode = document.querySelector("[data-pg-session-count]");
        if (sessionsNode) {
          sessionsNode.textContent =
            sessions + " session" + (sessions === 1 ? "" : "s");
        }
      } catch (e) {
        // Fail silently; this is just for engagement
        console.warn("PassingGrade progress metrics error", e);
      }
    }

    function getWeekKey(date) {
      var d = new Date(
        Date.UTC(date.getFullYear(), date.getMonth(), date.getDate())
      );
      var dayNum = d.getUTCDay() || 7;
      d.setUTCDate(d.getUTCDate() + 4 - dayNum);
      var yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
      var weekNo = Math.ceil(((d - yearStart) / 86400000 + 1) / 7);
      return d.getUTCFullYear() + "-W" + weekNo;
    }

    function countActiveDaysThisWeek(activeDaysObj, now) {
      var count = 0;
      var today = new Date(
        Date.UTC(now.getFullYear(), now.getMonth(), now.getDate())
      );
      var dayNum = today.getUTCDay() || 7; // 1-7 (Mon-Sun)
      var monday = new Date(today);
      monday.setUTCDate(today.getUTCDate() - (dayNum - 1)); // go back to Monday

      for (var i = 0; i < 7; i++) {
        var d = new Date(monday);
        d.setUTCDate(monday.getUTCDate() + i);
        var key = d.toISOString().slice(0, 10);
        if (activeDaysObj[key]) count++;
      }
      return count;
    }

    /* ---------- 3. Wire Menu & Tools toggles into the sticky loop (mobile) ---------- */

    function wireMobileToggles() {
      var loopMenuButton = document.getElementById("pg-loop-menu-toggle");
      var loopToolsButton = document.getElementById("pg-loop-tools-toggle");

      if (!loopMenuButton && !loopToolsButton) return;

      // Find existing Menu / Tools controls by text (keeps your current behavior)
      var allButtons = Array.prototype.slice.call(
        document.querySelectorAll("button, [role='button']")
      );

      var menuOriginal = findByText(allButtons, "Menu");
      var toolsOriginal = findByText(allButtons, "Tools");

      // Mark originals as "mobile-hide" without changing desktop behavior
      [menuOriginal, toolsOriginal].forEach(function (el) {
        if (el && !el.classList.contains("pg-mobile-hide-original-toggle")) {
          el.classList.add("pg-mobile-hide-original-toggle");
        }
      });

      if (loopMenuButton && menuOriginal) {
        loopMenuButton.addEventListener("click", function () {
          menuOriginal.click();
        });
      }

      if (loopToolsButton && toolsOriginal) {
        loopToolsButton.addEventListener("click", function () {
          toolsOriginal.click();
        });
      }
    }

    function findByText(nodes, text) {
      text = text.toLowerCase();
      for (var i = 0; i < nodes.length; i++) {
        var t = (nodes[i].textContent || "").toLowerCase();
        if (t.indexOf(text) !== -1) return nodes[i];
      }
      return null;
    }
  })();
</script>



<script>
  (function () {
    function onReady(fn) {
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", fn);
      } else {
        fn();
      }
    }

    onReady(function () {
      var header = document.querySelector("header");
      var sticky = document.getElementById("pg-sticky-loop-shell");
      if (!header || !sticky) return;

      var observer = new IntersectionObserver(
        function (entries) {
          entries.forEach(function (entry) {
            if (entry.isIntersecting) {
              // header visible -> not stuck
              sticky.classList.remove("pg-is-stuck");
            } else {
              // header scrolled off -> sticky bar is stuck
              sticky.classList.add("pg-is-stuck");
            }
          });
        },
        {
          threshold: 0
        }
      );

      observer.observe(header);
    });
  })();
</script>

</body>



</html>
