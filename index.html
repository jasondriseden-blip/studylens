<!DOCTYPE html>
<html lang="en">
<head>

  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <script>
    (function () {
      try {
        const savedTheme = localStorage.getItem("studyai-theme");
        const prefersDark =
          window.matchMedia &&
          window.matchMedia("(prefers-color-scheme: dark)").matches;

        const theme = savedTheme || (prefersDark ? "dark" : "light");
        document.documentElement.setAttribute("data-theme", theme);
      } catch (e) {
        // fallback if localStorage is blocked
        document.documentElement.setAttribute("data-theme", "dark");
      }
    })();
  </script>
  
  <title>Passing Grade</title>
   <!-- Tell Safari/Chrome we support both themes -->
  <meta name="color-scheme" content="light dark" />

  <!-- Browser / status bar color (will be updated by JS) -->
  <meta name="theme-color" content="#020617" id="meta-theme-color" />

  <!-- Optional iOS standalone app styling -->
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />


  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Passing Grade</title>

  <!-- Google Fonts + Material Icons -->
  <link
    rel="stylesheet"
    href="https://fonts.googleapis.com/css2?family=Outfit:wght@500;600;700&family=DM+Sans:wght@400;500;600&family=Material+Symbols+Outlined:wght@400&display=swap"
  />
<!-- FAVICONS -->
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/icon-16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/icon-32.png">
<link rel="icon" type="image/png" sizes="48x48" href="/icon-48.png">
<link rel="apple-touch-icon" sizes="180x180" href="/icon-180.png">
<link rel="icon" type="image/png" sizes="192x192" href="/icon-192.png">




<style>
  :root {
    /* ===== Design tokens: easy to tweak ===== */
    /* Core colors (Vercel-ish, neutral) */
    --primary: #111827;
    --primary-variant: #000000;
    --on-primary: #ffffff;

    --surface-dark: #020617;
    --surface-light: #fafafa;
    --surface-elevated-dark: #020617;
    --surface-elevated-light: #ffffff;

    --on-surface-dark: #e5e7eb;
    --on-surface-light: #0f172a;

    --outline-dark: rgba(148, 163, 184, 0.35);
    --outline-light: #e4e4e7;

    --radius-lg: 6px;
    --radius-md: 6px;
    --radius-pill: 6px;
    --transition-fast: 0.16s ease-out;

    /* Buttons – outline (white) + solid (black) */
    --btn-bg-light: #ffffff;
    --btn-fg-light: #111827;
    --btn-bg-dark: #111827;
    --btn-fg-dark: #f9fafb;

    --btn-bg-active-light: #f4f4f5;
    --btn-fg-active-light: #111827;
    --btn-bg-active-dark: #030712;
    --btn-fg-active-dark: #f9fafb;

    --btn-solid-bg: #111827;  /* Vercel black button */
    --btn-solid-fg: #f9fafb;
    --btn-solid-hover-bg: #000000;

    --font-sans: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
      sans-serif;
  }

  [data-theme="dark"] {
    --surface: var(--surface-dark);
    --card-bg: var(--surface-elevated-dark);
    --on-surface: var(--on-surface-dark);
    --outline: var(--outline-dark);
    --field-bg: rgba(15, 23, 42, 0.95);
    --chip-bg: #020617;
    --code-bg: #020617;
    --code-fg: #e5e7eb;
    --muted: #9ca3af;
    --header-bg: radial-gradient(circle at top left, #111827, #020617);
    --sidebar-bg: #020617;

    --btn-bg: var(--btn-bg-dark);
    --btn-fg: var(--btn-fg-dark);
    --btn-bg-active: var(--btn-bg-active-dark);
    --btn-fg-active: var(--btn-fg-active-dark);
  }

  [data-theme="light"] {
    --surface: var(--surface-light);
    --card-bg: var(--surface-elevated-light);
    --on-surface: var(--on-surface-light);
    --outline: var(--outline-light);
    --field-bg: #ffffff;
    --chip-bg: #f4f4f5;
    --code-bg: #ffffff;
    --code-fg: #020617;
    --muted: #000;
    --header-bg: #ffffff;
    --sidebar-bg: #f9fafb;

    --btn-bg: var(--btn-bg-light);          /* white outline style */
    --btn-fg: var(--btn-fg-light);          /* black text */
    --btn-bg-active: var(--btn-bg-active-light);
    --btn-fg-active: var(--btn-fg-active-light);
  }

  * {
    box-sizing: border-box;
  }

  body {
    margin: 0;
    font-family: var(--font-sans);
    background: var(--surface);
    color: var(--on-surface);
    min-height: 100vh;
    display: flex;
    justify-content: center;
    padding-top: 0.75rem;
  }

  .app {
    width: 100%;
    max-width: 980px;
    min-height: 100vh;
    padding: 14px 14px 18px;
    display: flex;
    flex-direction: column;
    gap: 10px;
  }

  header {
    background: var(--card-bg);
    border-radius: var(--radius-lg);
    padding: 20px 18px;
    border: 1px solid var(--outline);
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 10px;
  }

  .title-block {
    display: flex;
    flex-direction: column;
    gap: 5px;
  }

  .title-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 1rem;
  }

  .title-block h1 {
    margin: 0;
    font-family: var(--font-sans);
    font-size: 1.4rem;
    letter-spacing: 0.02em;
    display: flex;
    align-items: center;
    gap: 8px;
    font-weight: 600;
  }

  .visually-hidden {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
  }

  /* Show correct logo per theme */
  html[data-theme="light"] .brand-logo-light {
    display: block;
  }
  html[data-theme="light"] .brand-logo-dark {
    display: none;
  }
  html[data-theme="dark"] .brand-logo-light {
    display: none;
  }
  html[data-theme="dark"] .brand-logo-dark {
    display: block;
  }

  .brand-logo-wrap {
    display: flex;
    align-items: center;
    flex: 0 1 auto;
  }

  .brand-logo {
    display: block;
    height: 40px;
    width: auto;
  }

  .header-subline {
    margin-top: 0.35rem;
    font-size: 0.9rem;
    line-height: 1.4;
    color: #4b5563;
  }

  .header-right {
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 6px;
  }

  .header-top-row {
    display: flex;
    align-items: center;
    gap: 10px;
  }

  /* ---- Auth status + sign-in button ---- */
  .auth-row {
    margin-top: 4px;
    display: flex;
    align-items: center;
    justify-content: flex-end;
    gap: 8px;
    flex-wrap: wrap;
    font-size: 0.75rem;
    color: var(--muted);

  }

  .user-plan-label {
    white-space: nowrap;
  }

  .auth-button {
    border-radius: var(--radius-pill);
    border: 1px solid var(--outline);
    padding: 6px 12px;
    font-size: 0.78rem;
    background: transparent;
    color: var(--on-surface);
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    gap: 6px;
    box-shadow: none;
  }

  .auth-button:hover {
    border-color: var(--primary);
    background: rgba(15, 23, 42, 0.04);
  }

  .chip {
    font-size: 0.74rem;
    padding: 5px 12px;
    border-radius: var(--radius-pill);
    border: 1px solid var(--outline);
    background: var(--chip-bg);
    color: var(--muted);
    display: inline-flex;
    align-items: center;
    gap: 7px;
    white-space: nowrap;
    cursor: pointer;
    user-select: none;
  }

  .chip-dot {
    width: 9px;
    height: 9px;
    border-radius: var(--radius-pill);
    background: #22c55e;
    box-shadow: 0 0 6px rgba(34, 197, 94, 0.7);
  }

  .theme-toggle,
  .drawer-toggle {
    border-radius: var(--radius-pill);
    border: 1px solid var(--outline);
    padding: 7px 13px;
    background: var(--card-bg);
    display: inline-flex;
    align-items: center;
    gap: 8px;
    font-size: 0.78rem;
    color: var(--on-surface);
    cursor: pointer;
    transition:
      border-color var(--transition-fast),
      color var(--transition-fast),
      background var(--transition-fast),
      transform 0.08s ease-out;
  }

  .theme-toggle svg {
    width: 18px;
    height: 18px;
  }

  .drawer-toggle .material-symbols-outlined {
    font-size: 20px;
  }

  .theme-toggle:hover,
  .drawer-toggle:hover {
    border-color: transparent;
    background: var(--btn-bg-active);
    color: var(--btn-fg-active);
    transform: translateY(-1px);
  }

  .top-bar {
    display: flex;
    gap: 8px;
    margin: 2px 0 4px;
  }

  select {
    border-radius: var(--radius-pill);
    border: 1px solid var(--outline);
    background: var(--card-bg);
    color: var(--on-surface);
    font-size: 0.9rem;
    padding: 11px 12px;
    outline: none;
  }

  .top-bar select {
    flex: 1;
  }

  .main-layout {
    display: flex;
    gap: 12px;
    flex: 1;
    min-height: 0;
    margin-top: 4px;
  }

  .content {
    flex: 1;
    min-width: 0;
  }

  .card {
    background: var(--card-bg);
    border-radius: var(--radius-md);
    border: 1px solid var(--outline);
    padding: 14px;
    margin-bottom: 10px;
  }

  .card h2 {
    margin: 0 0 4px;
    font-family: var(--font-sans);
    font-size: 1.05rem;
    font-weight: 600;
    letter-spacing: 0.01em;
  }

  .desc {
        font-size: 0.78rem;
    margin-bottom: 15px;
    opacity: 0.85;
    text-align: left;
  }

  .tab-content {
    display: none;
  }

  .tab-content.active {
    display: block;
  }

  label {
    display: block;
    font-size: 0.78rem;
    color: var(--muted);
    margin-bottom: 4px;
  }

  /* ===== Text inputs ===== */

  textarea {
    width: 100%;
    font-family: inherit;
    font-size: 0.9rem;
    padding: 10px 12px;
    border-radius: 6px;
    border: 1px solid var(--outline);
    background: var(--field-bg);
    color: var(--on-surface);
    outline: none;
    resize: vertical;
    min-height: 120px;
    transition:
      border-color var(--transition-fast),
      box-shadow var(--transition-fast),
      background var(--transition-fast);
  }

  input[type="file"],
  input[type="text"] {
    margin-top: 0.5em;
    width: 100%;
    font-family: inherit;
    font-size: 0.9rem;
    padding: 10px 12px;
    border-radius: 6px;
    border: 1px solid var(--outline);
    background: var(--field-bg);
    color: var(--on-surface);
    outline: none;
    min-height: 44px;
    transition:
      border-color var(--transition-fast),
      box-shadow var(--transition-fast),
      background var(--transition-fast);
  }

  .text-input {
    background: var(--field-bg);
    color: var(--on-surface);
  }

  input[type="file"] {
    min-height: auto;
    padding: 8px;
    cursor: pointer;
    font-size: 0.8rem;
  }

  textarea:focus,
  input:focus {
    border-color: var(--primary);
    box-shadow: 0 0 0 1px rgba(15, 23, 42, 0.12);
    background: #ffffff05;
  }

  .btn-row {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-top: 9px;
    margin-bottom: 15px;
    justify-content: flex-end;
  }

  /* ===== Base button (white outline style) ===== */
  button {
    border-radius: var(--radius-pill);
    border: 1px solid var(--outline);
    padding: 9px 16px;
    font-size: 0.85rem;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    gap: 7px;
    background: var(--btn-bg);
    color: var(--btn-fg);
    transition:
      transform 0.08s ease-out,
      box-shadow 0.08s ease-out,
      opacity 0.08s,
      background 0.12s ease-out,
      color 0.12s ease-out,
      border-color 0.12s ease-out;
    font-weight: 500;
  }

  button:hover {
    background: var(--btn-bg-active);
    color: var(--btn-fg-active);
    border-color: #d4d4d8;
    box-shadow: 0 6px 18px rgba(15, 23, 42, 0.06);
  }

  button.secondary {
    background: var(--btn-bg);
    color: var(--btn-fg);
    box-shadow: none;
    border: 1px solid var(--outline);
  }

  button:active {
    transform: translateY(1px) scale(0.99);
    opacity: 0.96;
    box-shadow: 0 6px 14px rgba(15, 23, 42, 0.25);
  }

  .hint-row {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    margin-top: 6px;
    justify-content: flex-end;
  }

  .hint-row button {
        font-size: 0.9rem;
    padding: 12px;
  }

  /* ===== Text outputs ===== */

  pre {
    margin-top: 8px;
    background: var(--code-bg);
    color: var(--code-fg);
    border-radius: 6px;
    padding: 14px 16px;
    font-size: 0.9rem;
    line-height: 1.6;
    max-height: 260px;
    overflow: auto;
    border: 1px solid rgba(148, 163, 184, 0.4);
    white-space: pre-wrap;
    word-wrap: break-word;
  }

  .text-output {
    background: var(--code-bg);
    color: var(--code-fg);
  }

  pre .step-line {
    display: block;
    font-weight: 700;
    margin: 6px 0 2px;
  }

  pre .answer-label {
    font-weight: 600;
  }

  pre .answer-value {
    font-weight: 700;
  }

  pre .hint-label {
    display: block;
    margin-top: 10px;
    font-size: 0.8rem;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    opacity: 0.8;
  }

  pre .section-heading {
    display: block;
    margin-top: 10px;
    margin-bottom: 4px;
    font-weight: 700;
    font-size: 0.85rem;
    text-transform: uppercase;
    letter-spacing: 0.08em;
  }

  .pill-button {
    border-radius: var(--radius-pill);
    border: 1px solid var(--outline);
    padding: 12px;
    font-size: 0.9rem;
    background: var(--btn-bg);
    color: var(--btn-fg);
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    gap: 5px;
  }

  .pill-button.active,
  .nav-btn.active,
  .notebook-filter.active {
    background: var(--btn-bg-active);
    color: var(--btn-fg-active);
  }

  .material-symbols-outlined {
    font-family: "Material Symbols Outlined";
    font-weight: normal;
    font-style: normal;
    font-size: 20px;
    line-height: 1;
    letter-spacing: normal;
    text-transform: none;
    display: inline-block;
    white-space: nowrap;
    word-wrap: normal;
    direction: ltr;
    -webkit-font-feature-settings: "liga";
    -webkit-font-smoothing: antialiased;
    font-variation-settings:
      "FILL" 0,
      "wght" 400,
      "GRAD" 0,
      "opsz" 24;
  }

  .hint-footer {
    margin-top: 8px;
    font-size: 0.7rem;
    color: var(--muted);
    text-align: left;
  }

  .notebook-item {
    padding: 8px;
    border-radius: 6px;
    border: 1px solid rgba(148, 163, 184, 0.7);
    margin-bottom: 6px;
    font-size: 0.8rem;
    background: rgba(15, 23, 42, 0.03);
    line-height: 1.5;
  }

  [data-theme="light"] .notebook-item {
    background: #f9fafb;
  }

  .notebook-item small {
    display: block;
    color: var(--muted);
    margin-bottom: 2px;
    font-size: 0.7rem;
  }

  .notebook-item-header {
    display: flex;
    justify-content: space-between;
    gap: 6px;
    margin-bottom: 6px;
  }

  .notebook-meta {
    font-size: 0.9rem;
    text-transform: uppercase;
    letter-spacing: 0.09em;
    font-weight: 600;
    color: var(--muted);
  }

  .notebook-actions {
    display: inline-flex;
    gap: 4px;
    flex-wrap: wrap;
  }

  .notebook-actions button {
    box-shadow: none;
    padding: 3px 8px;
    font-size: 0.7rem;
  }

  .notebook-item > div:last-child {
    font-size: 0.82rem;
    color: var(--on-surface);
    white-space: pre-wrap;
  }

  .flashcard {
    margin-top: 8px;
	margin-bottom: 15px;
    padding: 14px 12px;
    border-radius: 6px;
    background: var(--field-bg);
    min-height: 80px;
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
    transition: transform 0.3s ease;
    transform-origin: center;
  }

  .flashcard.flipping {
    transform: rotateY(180deg);
  }

  .flashcard-side {
    font-size: 0.9rem;
    white-space: pre-wrap;
    word-wrap: break-word;
    width: 100%;
    line-height: 1.6;
    text-align: center;
  }

  #cardsStats {
    font-size: 0.78rem;
    margin-bottom: 15px;
    opacity: 0.85;
    text-align: right;
  }
  #cardsCard.flashcard {
    border-width: 1px;
    padding: 5em 1em;
  }

  #cardsFront {
    font-weight: 700;
    color: #25ae4a;
    font-size: 1.02em;
  }

  #cardsBack {
    font-weight: 500;
    color: var(--on-surface);
    opacity: 1;
  }

  .side-drawer {
    width: 220px;
    background: var(--sidebar-bg);
    border-left: 1px solid rgba(148, 163, 184, 0.5);
    border-radius: 6px;
    box-shadow: 0 0 30px rgba(0, 0, 0, 0.45);
    position: fixed;
    top: 10px;
    right: 10px;
    height: calc(100vh - 20px);
    transform: translateX(110%);
    transition: transform 0.18s ease-out;
    z-index: 30;
    display: flex;
    flex-direction: column;
  }

  .side-drawer.open {
    transform: translateX(0);
  }

  .side-drawer-inner {
    padding: 12px 10px 10px;
    display: flex;
    flex-direction: column;
    height: 100%;
  }

  .side-drawer-header {
    font-size: 0.7rem;
    text-transform: uppercase;
    letter-spacing: 0.09em;
    color: var(--muted);
    margin-bottom: 6px;
    padding: 0 6px;
  }

  .side-nav {
    display: flex;
    flex-direction: column;
    gap: 4px;
    overflow-y: auto;
    padding-right: 4px;
    margin-top: 2px;
  }

  .nav-btn {
    border-radius: var(--radius-pill);
    border: 1px solid var(--outline);
    background: var(--btn-bg);
    color: var(--btn-fg);
    font-size: 0.9rem;
    display: flex;
    align-items: center;
    gap: 9px;
    padding: 11px 12px;
    cursor: pointer;
    text-align: left;
    transition:
      background var(--transition-fast),
      color var(--transition-fast),
      transform 0.06s ease-out;
  }

  .nav-btn .material-symbols-outlined {
    font-size: 20px;
  }

  .nav-btn span.label {
    flex: 1;
  }

  .drawer-backdrop.show {
    display: block;
  }

  @media (min-width: 700px) {
    .app {
      padding-bottom: 18px;
    }

    .main-layout {
      display: flex;
    }


    .side-drawer {
      position: static;
      height: auto;
      transform: none !important;
      box-shadow: none;
      border-radius: 6px;
      max-height: none;
      width: 230px;
    }

    .side-drawer-inner {
      height: auto;
      max-height: calc(100vh - 120px);
    }

    .drawer-backdrop {
      display: none !important;
    }

    .drawer-toggle {
      display: none;
    }
  }

  [data-theme="light"] .side-drawer {
    background: #ffffff;
  }

  [data-theme="dark"] .side-drawer {
    background: #020617;
  }

  .mobile-break {
    display: none;
  }

 .header-menu-inner{
            position:absolute;
            top:calc(-100%);
            left:-100%;
            transform:translateX(-50%);
            display:flex;
            flex-direction:column;
            gap:6px;
            align-items:stretch;
            z-index:30;
            background: var(--card-bg);
            padding: 16px;
            border-radius: 6px;
            box-shadow: 0 10px 24px rgba(15, 23, 42, 0.35);
    }
  @media (max-width: 700px) {
    header {
      position: relative;
      flex-direction: column;
      align-items: stretch;
      gap: 8px;
      padding: 16px 12px 12px;
    }

    .title-block {
      width: 100%;
    }

    .title-row {
      justify-content: flex-start;
    }

    .brand-logo {
      display: block;
      height: 33px;
      width: auto;
    }

    .brand-logo-wrap {
      display: inline-flex;
      align-items: center;
      justify-content: flex-start;
      background: transparent;
      box-shadow: none;
      height: auto;
      margin: 11px  0 6px 0;
    }

    .subtitle {
      font-size: 0.85rem;
      color: var(--muted);
    }

    .header-right {
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin-top: 4px;
      padding-top: 10px;
    }

    .auth-row {
      width: 100%;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: flex-end;
      gap: 6px;
      font-size: 0.75rem;
    }

    #userPlanLabel {
      flex: 1 1 100%;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      text-align: right;
      line-height: 1.3;
    }



    .chip.learn-mode {
      flex: 0 0 auto;
      padding: 4px 10px;
      font-size: 0.74rem;
      white-space: nowrap;
    }

    .theme-toggle,
    .drawer-toggle {
      flex: 0 0 auto;
      padding: 6px;
      min-width: 40px;
      justify-content: center;
      font-size: 0.8rem;
    }

    [data-theme="dark"] .brand-logo {
      filter: brightness(1.08);
    }
  }

  /* ---- Subtle "completed" pulse animation ---- */
  @keyframes pulse-highlight {
    0% {
      box-shadow: 0 0 0 0 rgba(15, 23, 42, 0);
      transform: scale(1);
    }
    35% {
      box-shadow: 0 0 0 4px rgba(15, 23, 42, 0.25);
      transform: scale(1.01);
    }
    100% {
      box-shadow: 0 0 0 0 rgba(15, 23, 42, 0);
      transform: scale(1);
    }
  }

  .pulse-once {
    animation: pulse-highlight 0.7s ease-out;
  }

  .notebook-filter {
    opacity: 0.85;
  }

  .notebook-filter.active {
    opacity: 1;
    box-shadow: 0 0 0 1px rgba(59, 130, 246, 0.4);
  }

  .notebook-filter.active .material-symbols-outlined {
    color: inherit;
  }

  .notebook-subject-row {
    position: relative;
    display: inline-flex;
    align-items: center;
    gap: 4px;
    margin-bottom: 4px;
  }

  .notebook-subject-btn {
    padding: 4px 10px;
    border-radius: var(--radius-pill);
    border: 1px solid var(--outline);
    background: var(--field-bg);
    font-size: 0.78rem;
    cursor: pointer;
  }

  .notebook-subject-btn.active {
    border-color: var(--primary);
    background: var(--btn-bg-active);
    color: var(--btn-fg-active);
  }

  .notebook-subject-menu {
    padding: 2px 8px;
    min-width: auto;
  }

  .notebook-subject-edit,
  .notebook-subject-delete {
    display: none;
    padding: 2px 6px;
    border-radius: var(--radius-pill);
    border: 1px solid transparent;
    background: transparent;
    font-size: 0.7rem;
    opacity: 0.7;
    cursor: pointer;
  }

  .notebook-subject-dropdown {
    display: none;
    position: absolute;
    right: 0;
    top: 110%;
    background: var(--surface);
    border: 1px solid var(--outline);
    border-radius: 6px;
    padding: 6px;
    box-shadow: 0 8px 20px rgba(15, 23, 42, 0.25);
    z-index: 30;
    min-width: 170px;
    flex-direction: column;
    gap: 6px;
  }

  .notebook-subject-dropdown .notebook-subject-edit,
  .notebook-subject-dropdown .notebook-subject-delete {
    display: flex;
    width: 100%;
    justify-content: flex-start;
    font-size: 0.78rem;
    padding: 6px 10px;
    border-radius: var(--radius-pill);
    border: 1px solid transparent;
    background: var(--btn-bg);
    gap: 6px;
  }

  .notebook-subject-edit {
    color: var(--on-surface);
  }

  .notebook-subject-delete {
    color: #dc2626;
  }

  .notebook-subject-edit:hover,
  .notebook-subject-delete:hover {
    opacity: 1;
    border-color: rgba(148, 163, 184, 0.5);
    background: var(--btn-bg-active);
  }

  #saveSubjectInput {
    width: 100%;
    font-family: inherit;
    font-size: 0.9rem;
    padding: 8px 10px;
    border-radius: var(--radius-pill);
    border: 1px solid var(--outline);
    background: var(--field-bg);
    color: #bbbbbb;
    outline: none;
    min-height: auto;
    height: auto;
    transition:
      border-color var(--transition-fast),
      box-shadow var(--transition-fast),
      background var(--transition-fast);
  }

  label[for="saveSubjectInput"] {
    display: block;
    width: 100%;
    text-align: left;
  }

  /* Let result boxes grow full height */
  #snapResult,
  #mathResult,
  #studyResult,
  #flashcardsResult,
  #essayResult {
    max-height: none !important;
    overflow: visible !important;
  }

  #snapText,
  #mathInput,
  #studyInput,
  #essayInput {
    max-height: none !important;
    overflow-y: hidden !important;
    resize: none;
	margin-top:.5em;
  }

  #copySnapTextBtn {
    border: 1px solid rgba(148, 163, 184, 0.6);
    background: rgba(148, 163, 184, 0.08);
    border-radius: var(--radius-pill);
    padding: 4px 6px;
    font-size: 0.7rem;
    display: inline-flex;
    align-items: center;
    gap: 4px;
    cursor: pointer;
    color: inherit;
  }

  #copySnapTextBtn .material-symbols-outlined {
    font-size: 14px;
    color: inherit;
  }

  .snap-text-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 8px;
  }

  .snap-actions-wrapper {
    justify-content: flex-start;
  }

  .snap-actions-dropdown {
    position: relative;
    display: inline-block;
    margin-left: auto;
  }

  .snap-actions-toggle {
    display: inline-flex;
    align-items: center;
    gap: 4px;
  }

  .snap-actions-menu {
    position: absolute;
    top: 100%;
    right: 0;
    margin-top: 4px;
    padding: 6px 0;
    border-radius: 6px;
    border: 1px solid var(--outline);
    background: var(--card-bg);
    box-shadow: 0 8px 20px rgba(15, 23, 42, 0.4);
    min-width: 180px;
    display: none;
    z-index: 30;
  }

  .snap-actions-menu button {
    width: 100%;
    justify-content: flex-start;
    border-radius: 6px;
    border: none;
    background: var(--btn-bg);
    color: var(--btn-fg);
  }

  .snap-actions-menu button:hover {
    background: var(--btn-bg-active);
  }

  #snapPreview {
    margin-bottom: 1em;
  }

  #textActionsDropdown .snap-actions-menu {
    top: auto;
    bottom: 100%;
    margin-top: 0;
    margin-bottom: 4px;
  }

  /* Notebook dropdown layout */
  .notebook-top-row {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-bottom: 6px;
  }

  .nb-dropdown {
    position: relative;
    display: inline-flex;
  }

  .nb-dropdown-toggle {
    display: inline-flex;
    align-items: center;
    gap: 6px;
  }

  .nb-dropdown-toggle::-webkit-details-marker {
    display: none;
  }

  .nb-dropdown-menu {
    position: absolute;
    top: calc(100% + 6px);
    left: 0;
    transform: none;
    min-width: 220px;
    padding: 10px;
    border-radius: 6px;
    background: var(--card-bg);
    border: 1px solid var(--outline);
    box-shadow: 0 10px 24px rgba(15, 23, 42, 0.35);
    z-index: 40;
    display: none;
  }

  .nb-dropdown[open] .nb-dropdown-menu {
    display: block;
  }

  .nb-dropdown-menu .hint-row {
    margin: 0;
    justify-content: flex-start;
  }

  .nb-dropdown-menu .pill-button {
    font-size: 0.86rem;
    padding: 6px 10px;
  }

  /* ==== Back / Forward tool navigation buttons ==== */
  #tabNavButtons {
    position: fixed;
    bottom: 0.75rem;
    left: 50%;
    transform: translateX(-50%);
    z-index: 50;
    display: flex;
    gap: 0.5rem;
  }

  .tab-nav-btn {
    padding: 0.35rem 0.9rem;
    border-radius: var(--radius-pill);
    border: 1px solid #e5e7eb;
    background: var(--btn-solid-bg);
    color: var(--btn-solid-fg);
    font-size: 0.8rem;
    font-weight: 500;
    display: inline-flex;
    align-items: center;
    gap: 0.25rem;
    box-shadow: 0 6px 18px rgba(15, 23, 42, 0.22);
    cursor: pointer;
  }

  .tab-nav-btn:hover {
    background: var(--btn-solid-hover-bg);
  }

  .tab-nav-btn.tab-nav-btn-disabled {
    opacity: 0.4;
    cursor: default;
    box-shadow: none;
  }

  /* ==== Extract Notes tool tweaks ==== */
  #notesResult {
    max-height: none !important;
    overflow: visible !important;
  }

  .notes-hint {
    font-size: 0.78rem;
    color: var(--muted);
    margin: 4px 0 10px;
  }

  .text-output.tool-output {
    background: var(--code-bg);
    color: var(--code-fg);
    border-color: rgba(148, 163, 184, 0.4);
  }

  .text-output.tool-output .tool-output-body {
    color: var(--code-fg);
  }

  .text-output.tool-output .tool-output-copy {
    border: 1px solid rgba(148, 163, 184, 0.6);
    background: var(--btn-bg);
    color: var(--btn-fg);
  }

  .text-output.tool-output .tool-output-copy:hover {
    background: var(--btn-bg-active);
    color: var(--btn-fg-active);
  }

  .text-output.tool-output .section-heading,
  .text-output.tool-output .step-line,
  .text-output.tool-output .answer-label,
  .text-output.tool-output .answer-value,
  .text-output.tool-output .hint-label {
    color: var(--code-fg);
  }
  /* ============================================
   DROPDOWN POSITIONING + STACKING + ANIMATION
   ============================================ */

/* Keep all dropdown panels inside the viewport */
.header-menu-inner,
.snap-actions-menu,
.nb-dropdown-menu,
.notebook-subject-dropdown {
  max-width: calc(100vw - 24px);
}

/* ----- Header "Menu" dropdown (little menu) ----- */
/* Make sure it sits on top of the big Tools menu
   and opens directly under the Menu button. */
.header-menu {
  position: relative;
}

.header-menu-inner {
  top: calc(100% + 8px) !important; /* just under the summary */
  right: 0 !important;
  left: auto !important;
  z-index: 60;                       /* above side-drawer (30) and others */
  opacity: 0;
  pointer-events: none;
  transform: translateY(4px) !important;
  transform-origin: top right;
  transition:
    opacity 0.16s ease-out,
    transform 0.16s ease-out;
}

/* Animate open/close via the <details open> state */
.header-menu[open] .header-menu-inner {
  opacity: 1;
  pointer-events: auto;
  transform: translateY(0) !important;
}

/* ----- Snap / Text actions dropdowns ----- */
/* Always open directly under their toggle and above other UI. */
.snap-actions-menu {
  top: calc(100% + 4px);
  left: 0;
  right: auto;
  z-index: 70;
  transform-origin: top left;
  transition:
    opacity 0.16s ease-out,
    transform 0.16s ease-out;
}

/* Make the Text actions dropdown open *below* as well */
#textActionsDropdown .snap-actions-menu {
  top: calc(100% + 4px);
  bottom: auto;
  margin-top: 4px;
  margin-bottom: 0;
}

/* ----- Notebook: Saved Subjects / Subjects by tools dropdowns ----- */
/* These are <details> menus, so we can animate them cleanly. */
.nb-dropdown-menu {
  top: calc(100% + 6px);
  left: 0;
  right: auto;
  z-index: 70;
  display: block;            /* show/hide handled by opacity/visibility */
  opacity: 0;
  visibility: hidden;
  pointer-events: none;
  transform: translateY(4px);
  transform-origin: top left;
  transition:
    opacity 0.16s ease-out,
    transform 0.16s ease-out,
    visibility 0.16s ease-out;
}

.nb-dropdown[open] .nb-dropdown-menu {
  opacity: 1;
  visibility: visible;
  pointer-events: auto;
  transform: translateY(0);
}

/* ----- Notebook subject "⋯" dropdown ----- */
/* Open right under the subject row, on top of everything. */
.notebook-subject-dropdown {
  top: calc(100% + 4px);
  right: 0;
  left: auto;
  z-index: 70;
  transform-origin: top right;
  transition:
    opacity 0.16s ease-out,
    transform 0.16s ease-out;
}
/* --- Ensure header mini-menu is above the side drawer --- */
.side-drawer {
  z-index: 20 !important;      /* still above page, below header menu & tab nav */
}

.header-menu-inner {
  z-index: 120 !important;     /* above side drawer and other UI */
}

/* --- Shared dropdown open animation (all menus) --- */
@keyframes dropdownFade {
  from {
    opacity: 0;
    transform: translateY(4px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Apply the same open animation to every dropdown panel */
.header-menu-inner,
.snap-actions-menu,
.nb-dropdown-menu,
.notebook-subject-dropdown {
  animation: dropdownFade 0.16s ease-out;
}

/* Keep them under their toggles & inside viewport */
.header-menu-inner,
.snap-actions-menu,
.nb-dropdown-menu,
.notebook-subject-dropdown {
  max-width: calc(100vw - 24px);
}

/* Header menu: directly under “Menu” button */
.header-menu {
  position: relative;
}

/* Snap / Text actions: always under their toggles */
.snap-actions-menu {
  top: calc(100% + 4px);
  left: 0;
  right: auto;
  transform-origin: top left;
}

/* Text actions specifically should also open below the button */
#textActionsDropdown .snap-actions-menu {
  top: calc(-700% + 4px);
  bottom: auto;
  margin-top: 4px;
  margin-bottom: 0;
}

/* Notebook details dropdowns: open under the pills */
.nb-dropdown-menu {
  top: calc(100% + 6px);
  left: 0;
  right: auto;
  transform-origin: top left;
}

/* Notebook subject “⋯” menu: under the subject row, right-aligned */
.notebook-subject-dropdown {
  top: calc(100% + 4px);
  right: 0;
  left: auto;
  transform-origin: top right;
}
/* Global text sizing for basic elements */
label,
p,
ul,
li {
  font-size: 1em;
}
/* Flashcard question text: black in light, white in dark */
:root[data-theme="light"] .pg-loop-pill-label, #cardsFront.flashcard-question-light {
  color: #000000;
}

:root[data-theme="dark"] .pg-loop-pill-label,  #cardsFront.flashcard-question-dark {
  color: #ffffff;
}



:root[data-theme="dark"] #cardsCard.flashcard-card-dark {
      background-color: #0e1629;
    border: 1px solid var(--outline);
    border-bottom: border: 1px solid var(--outline);
    border-top: border: 1px solid var(--outline);
}
:root[data-theme="light"] #cardsCard.flashcard-card-light {
      background-color: #fafafa;
    border: 2px solid var(--outline);
border-bottom: border: 1px solid var(--outline);
    border-top: border: 1px solid var(--outline);
}
/* ============================
   FLASHCARD "GOT IT" BURST TEXT
   ============================ */

.gotit-burst-word {
  position: fixed;
  left: 0;
  top: 0;
  transform: translate(-50%, -50%);
  font-family: var(--font-sans);
  font-weight: 800;
  font-size: 1rem;
  color: inherit;              /* inherit theme text color */
  pointer-events: none;
  z-index: 9999;
  opacity: 0;
  white-space: nowrap;
  user-select: none;
}

/* main rise + fade animation for the phrase */
@keyframes gotit-rise {
  0% {
    transform: translate(-50%, 0) scale(0.9);
    opacity: 0;
  }
  20% {
    opacity: 1;
    transform: translate(-50%, -10px) scale(1.05);
  }
  60% {
    opacity: 1;
  }
  100% {
    transform: translate(-50%, -40px) scale(0.95);
    opacity: 0;
  }
}

/* fragment "explosion" outward */
@keyframes gotit-frag {
  0% {
    transform: translate(0, 0) scale(1);
    opacity: 1;
  }
  100% {
    transform: translate(var(--gx), var(--gy)) scale(0.5);
    opacity: 0;
  }
}

/* container for fragments so we can position relative to phrase */
.gotit-burst-frag-container {
  position: absolute;
  left: 50%;
  top: 0;
  transform: translateX(-50%);
  pointer-events: none;
}

/* each tiny fragment (a part of the letters) */
.gotit-burst-frag {
  display: inline-block;
  font-size: 0.75rem;
  font-weight: 700;
  opacity: 0;
}


/* ===== Responsive tweaks ===== */
@media (max-width: 700px) {
  .gotit-burst-word {
    font-size: 0.9rem;
  }

  .gotit-burst-frag {
    font-size: 0.7rem;
  }
}

@media (min-width: 1000px) {
  .gotit-burst-word {
    font-size: 1.05rem;
  }

  .gotit-burst-frag {
    font-size: 0.8rem;
  }
}

/* ---------- Sticky Loop Bar ---------- */

#pg-sticky-loop-shell {
  position: sticky;
  top: 0;
  z-index: 40;
  padding: 0.5rem 0;
  margin-bottom: 0.75rem;
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
    border-radius: var(--radius-lg);;
  border: 1px solid rgba(125, 125, 255, 0.22);
  background: background: var(--card-bg);
}

/* Light / dark friendly subtle color */
#pg-sticky-loop-shell-inner {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.5rem 0.75rem;

}

/* Respect dark mode if you already flip background/text colors */
@media (prefers-color-scheme: dark) {
  #pg-sticky-loop-shell-inner {
    border-color: rgba(165, 180, 252, 0.4);
    background: linear-gradient(
      120deg,
      rgba(129, 140, 248, 0.35),
      rgba(56, 189, 248, 0.22),
      rgba(15, 23, 42, 0.7)
    );
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
  }
}

/* Pills inside loop */
.pg-loop-pill {
  display: inline-flex;
  align-items: center;
  gap: 0.35rem;
padding: 0.5rem 1rem;  border-radius: 999px;
  font-size: 0.8rem;
  line-height: 1.2;
  white-space: nowrap;
border: 1px solid var(--outline);  
background: var(--surface);
  cursor: default;
  user-select: none;

}

@media (prefers-color-scheme: dark) {
  .pg-loop-pill {
    border-color: rgba(148, 163, 184, 0.7);
    background: rgba(15, 23, 42, 0.75);
  }
}
/* Action pills (Menu / Tools used elsewhere too) */
.pg-loop-pill--action {
  cursor: pointer;
  font-weight: 600;
  border-style: solid;
  border-width: 1px;
  border-color: rgba(96, 165, 250, 0.9);
  background: rgba(37, 99, 235, 0.08);
  transition:
    transform 0.12s ease-out,
    box-shadow 0.12s ease-out,
    background 0.12s ease-out;
}

.pg-loop-pill--action:active {
  transform: translateY(1px) scale(0.99);
  box-shadow: 0 0 0 rgba(0, 0, 0, 0);
}

/* Metric pills (streak, weekly recap) */
.pg-loop-pill-label {
  opacity: 0.7;
  font-weight: 500;
  color: #000;
}

.pg-loop-pill-value {
  font-weight: 700;
}

/* Loop animation: items fade/slide in sequence */
.pg-loop-items {
  display: inline-flex;
  position: relative;
  overflow: hidden;
}

.pg-loop-item {
  opacity: 0;
  transform: translateY(8px);
  transition:
    opacity 0.3s ease-out,
    transform 0.3s ease-out;
  position: absolute;
  left: 0;
}

.pg-loop-item.pg-loop-item--active {
  opacity: 1;
  transform: translateY(0);
  position: relative;
}

/* --------- STICKY BAR: just the two buttons, styled like .card --------- */

#pg-sticky-loop-shell {
  position: sticky;
  top: 0;
  z-index: 30;
  margin: 0 0 12px;
  padding: 8px 12px;
  background: var(--card-bg);
  border-radius: var(--card-radius, 6px);

}

/* Row inside sticky bar = Menu + Tools */
.pg-loop-row {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.pg-loop-row--actions {
  justify-content: flex-end;
  flex-wrap: nowrap; /* keep buttons side by side */
}

/* Make sure Menu wrapper & Tools button don't become full-width on mobile */
.pg-loop-row--actions .header-top-row {
  display: flex;
  align-items: center;
  width: auto !important;
  flex: 0 0 auto !important;
}

.pg-loop-row--actions summary.pill-button,
.pg-loop-row--actions #pg-loop-tools-toggle {
  width: auto !important;
  flex: 0 0 auto !important;
}

/* ---------- Reusable "loop" behavior: NOT sticky anymore ---------- */
/* (used for the header metrics container) */

[data-sticky-loop] {
  position: relative; /* was sticky before – now only used for JS loop */
  z-index: 1;
  margin-top:10px;
}

/* Mobile tweaks: keep Menu + Tools on one line */
@media (max-width: 700px) {
  #pg-sticky-loop-shell {
	z-index: 20;
  }
.header-menu .pill-button, #pg-loop-tools-toggle{
padding: 8px;
}
  .pg-loop-row--actions {
    justify-content: flex-end;
    flex-wrap: nowrap;
  }
}

/* Utility: hide original toggles on mobile ONLY when we've wired the loop */
.pg-mobile-hide-original-toggle {
  display: inline-flex;
}


/* Mobile: stack metric pills (Today / Weekly recap) on their own lines */
@media (max-width: 500px) {
  .pg-loop-row--metrics {
    flex-direction: column;      /* stack instead of row */
    align-items: flex-start;
	margin-top:10px;
  }

  .pg-loop-row--metrics .pg-loop-pill {
    width: 100%;                 /* optional: make each pill full-width */
  }
}

/* Smooth transform for the Menu + Tools buttons */
#pg-sticky-loop-shell summary.pill-button,
#pg-sticky-loop-shell #pg-loop-tools-toggle {
  transition:
    transform 0.15s ease-out,
    padding 0.15s ease-out;
}

/* When sticky bar is "stuck", shrink the buttons slightly */
#pg-sticky-loop-shell.pg-is-stuck summary.pill-button,
#pg-sticky-loop-shell.pg-is-stuck #pg-loop-tools-toggle {
  transform: scale(0.9);
  padding-block: 0.5rem;

}

/* Default: hide sticky Tools button */
#pg-loop-tools-toggle {
  display: none !important;
}

/* Mobile: show sticky Tools button */
@media (max-width: 700px) {
  #pg-loop-tools-toggle {
    display: inline-flex !important;
    align-items: center;
    gap: 0.25rem;
  }
}

</style>



<!-- BLOCK: Desktop sticky aside nav (CSS only) ------------------------------------------------
--------------------------------------------------------------------------------------=----
===========================================================================================
===========================================================================================
------------------------------------------------------------------------------------------->
<style>
@media (min-width: 700px) {
  /* set your offset once */
  :root { --pg-sticky-offset: 85px; } 

  #sideDrawer {
    position: sticky;
    top: var(--pg-sticky-offset);
    align-self: flex-start;

    /* IMPORTANT: height must shrink when top grows */
    height: calc(100vh - var(--pg-sticky-offset));
  }

  #sideDrawer .side-drawer-inner {
    height: 100%;
    overflow-y: auto;
  }

  #drawerBackdrop {
    display: none !important;
  }
}
</style>

<style>
/* =========================================================
   Pro dropdown styling for:
   - #snapActionsMenu  (OCR dropdown)
   - #textActionsMenu  (Text actions dropdown)
   NO ID/class changes required.
========================================================= */

/* Theme-aware defaults */
:root {
  --pg-menu-bg: #ffffff;
  --pg-menu-border: rgba(15, 23, 42, 0.12);
  --pg-menu-shadow: 0 16px 40px rgba(2, 6, 23, 0.18);
  --pg-menu-item-hover: rgba(2, 6, 23, 0.05);
  --pg-menu-text: #0f172a;
  --pg-menu-muted: rgba(15, 23, 42, 0.6);
}

html[data-theme="dark"] {
  --pg-menu-bg: rgba(2, 6, 23, 0.95);
  --pg-menu-border: rgba(148, 163, 184, 0.22);
  --pg-menu-shadow: 0 18px 44px rgba(0, 0, 0, 0.55);
  --pg-menu-item-hover: rgba(148, 163, 184, 0.12);
  --pg-menu-text: #e5e7eb;
  --pg-menu-muted: rgba(229, 231, 235, 0.65);
}

/* Shared dropdown panel styling */
#snapActionsMenu,
#textActionsMenu {
  /* Your JS toggles display: block/none — keep that */
  min-width: 240px;
  max-width: 320px;

  background: var(--pg-menu-bg);
  color: var(--pg-menu-text);
  border: 1px solid var(--pg-menu-border);
  border-radius: 12px;
  box-shadow: var(--pg-menu-shadow);

  padding: 8px;
  margin-top: 8px;

  z-index: 9999;
}

/* Optional: a tiny arrow pointer */
#snapActionsMenu::before,
#textActionsMenu::before {
  content: "";
  position: absolute;
  width: 12px;
  height: 12px;
  transform: rotate(45deg);
  background: var(--pg-menu-bg);
  border-left: 1px solid var(--pg-menu-border);
  border-top: 1px solid var(--pg-menu-border);
  top: -7px;
  right: 18px;
}

/* Make menu buttons look consistent, aligned, and clickable */
#snapActionsMenu button,
#textActionsMenu button {
  width: 100%;
  display: flex;
  align-items: center;
  justify-content: flex-start;

  gap: 10px;
  padding: 10px 10px;

  border: 0;
  background: transparent;
  color: inherit;
  border-radius: 10px;

  cursor: pointer;
  text-align: left;
  line-height: 1.2;
  font-size: 14px;
}

/* Hover/active states */
#snapActionsMenu button:hover,
#textActionsMenu button:hover {
  background: var(--pg-menu-item-hover);
}

#snapActionsMenu button:active,
#textActionsMenu button:active {
  transform: translateY(1px);
}

/* If your buttons have icons inside, keep them aligned */
#snapActionsMenu .material-symbols-outlined,
#textActionsMenu .material-symbols-outlined {
  font-size: 18px;
  opacity: 0.9;
}

/* Optional: separators if you add <hr> or want spacing */
#snapActionsMenu hr,
#textActionsMenu hr {
  border: 0;
  border-top: 1px solid var(--pg-menu-border);
  margin: 8px 6px;
}

/* Mobile: slightly wider touch targets */
@media (max-width: 799px) {
  #snapActionsMenu,
  #textActionsMenu {
    min-width: 220px;
  }

  #snapActionsMenu button,
  #textActionsMenu button {
    padding: 12px 10px;
    font-size: 15px;
  }
}
</style>
<style>
/* =========================================================
   NOTEBOOK DROPDOWNS (details.nb-dropdown)
   Styles:
   - summary looks like a pro button
   - panel is a floating card with clean items
========================================================= */

/* theme vars */
:root{
  --pg-dd-bg: #ffffff;
  --pg-dd-border: rgba(15,23,42,.12);
  --pg-dd-shadow: 0 16px 40px rgba(2,6,23,.18);
  --pg-dd-hover: rgba(2,6,23,.05);
  --pg-dd-text: #0f172a;
}
html[data-theme="dark"]{
  --pg-dd-bg: rgba(2,6,23,.96);
  --pg-dd-border: rgba(148,163,184,.22);
  --pg-dd-shadow: 0 18px 44px rgba(0,0,0,.55);
  --pg-dd-hover: rgba(148,163,184,.12);
  --pg-dd-text: #e5e7eb;
}

/* the <details> wrapper */
details.nb-dropdown{
  position: relative;
}

/* remove default triangle marker */
details.nb-dropdown > summary{
  list-style: none;
}
details.nb-dropdown > summary::-webkit-details-marker{
  display:none;
}

/* the clickable "button" */
details.nb-dropdown > summary.nb-dropdown-toggle{
  display: inline-flex;
  align-items: center;
  gap: 10px;

  padding: 10px 12px;
  border-radius: 12px;
  border: 1px solid var(--pg-dd-border);
  background: var(--pg-dd-bg);
  color: var(--pg-dd-text);
  cursor: pointer;
  user-select: none;

  box-shadow: 0 6px 18px rgba(2,6,23,.08);
}

/* make the caret / icon sit right (if you have one inside summary) */
details.nb-dropdown > summary.nb-dropdown-toggle .material-symbols-outlined{
  font-size: 18px;
  opacity: .9;
}

/* the dropdown panel (first element after summary) */
details.nb-dropdown > summary + *{
  position: absolute;
  top: calc(100% + 10px);
  left: 0;

  min-width: 260px;
  max-width: 340px;

  background: var(--pg-dd-bg);
  color: var(--pg-dd-text);
  border: 1px solid var(--pg-dd-border);
  border-radius: 14px;
  box-shadow: var(--pg-dd-shadow);
  padding: 10px;

  z-index: 9999;
}

/* OPTIONAL: if you want the 2nd dropdown to open right-aligned under its button,
   add class "nb-dropdown--right" to that <details> */
details.nb-dropdown.nb-dropdown--right > summary + *{
  left: auto;
  right: 0;
}

/* menu items inside panel */
details.nb-dropdown > summary + * button{
  width: 100%;
  border: 0;
  background: transparent;
  color: inherit;

  display: flex;
  align-items: center;
  gap: 10px;

  padding: 10px 10px;
  border-radius: 12px;
  cursor: pointer;
  text-align: left;
}

details.nb-dropdown > summary + * button:hover{
  background: var(--pg-dd-hover);
}

/* if the menu uses little chips */
details.nb-dropdown > summary + * .chip{
  border: 1px solid var(--pg-dd-border);
  background: transparent;
  color: inherit;
  border-radius: 999px;
  padding: 8px 10px;
}

/* if you have icon+label blocks, keep icons aligned */
details.nb-dropdown > summary + * .material-symbols-outlined{
  font-size: 18px;
  opacity: .9;
}
/* =========================================================
   PRO DROPDOWNS (global look)
   Targets: header menu, snap actions, text actions, notebook dropdowns
========================================================= */
/* Subtle pro shadow for dropdown-trigger buttons */
#pg-sticky-loop-shell summary.pill-button, #pg-sticky-loop-shell #pg-loop-tools-toggle,
#snapActionsToggle,
#textActionsToggle,
details.nb-dropdown > summary {
  box-shadow:
    0 1px 2px rgba(15, 23, 42, 0.08),
    0 6px 18px rgba(15, 23, 42, 0.06);
  transition: box-shadow 160ms ease, transform 160ms ease, border-color 160ms ease;
}

/* Slightly stronger on hover/focus */
#snapActionsToggle:hover,
#textActionsToggle:hover,
details.nb-dropdown > summary:hover,
#snapActionsToggle:focus-visible,
#textActionsToggle:focus-visible,
details.nb-dropdown > summary:focus-visible {
  box-shadow:
    0 2px 4px rgba(15, 23, 42, 0.10),
    0 10px 26px rgba(15, 23, 42, 0.10);
}

/* Optional: tiny press feedback */
#snapActionsToggle:active,
#textActionsToggle:active,
details.nb-dropdown > summary:active {
  transform: translateY(1px);
}

/* Base panel styling */
.header-menu-inner,
.snap-actions-menu,
#textActionsMenu,
.nb-dropdown-menu,
.notebook-subject-dropdown {
  background: var(--card-bg, #fff) !important;
  border: 1px solid rgba(148, 163, 184, 0.35) !important;
  border-radius: 14px !important;
  padding: 8px !important;
  box-shadow:
    0 18px 45px rgba(2, 6, 23, 0.14),
    0 4px 14px rgba(2, 6, 23, 0.10) !important;
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
}

/* Keep menus from going edge-to-edge on mobile */
.header-menu-inner,
.snap-actions-menu,
#textActionsMenu,
.nb-dropdown-menu,
.notebook-subject-dropdown {
  max-width: min(360px, calc(100vw - 24px)) !important;
}

/* Button items inside dropdown panels */
.header-menu-inner button,
.snap-actions-menu button,
#textActionsMenu button,
.nb-dropdown-menu button,
.notebook-subject-dropdown button {
  width: 100% !important;
  align-items: center !important;
  justify-content: flex-start !important;
  gap: 10px !important;

  padding: 10px 12px !important;
  border-radius: 12px !important;

  background: transparent !important;

  font-size: 13px !important;
  font-weight: 600 !important;
  line-height: 1.15 !important;

  cursor: pointer !important;
  user-select: none;
}

/* Hover / active feel */
.header-menu-inner button:hover,
.snap-actions-menu button:hover,
#textActionsMenu button:hover,
.nb-dropdown-menu button:hover,
.notebook-subject-dropdown button:hover {
  background: rgba(148, 163, 184, 0.14) !important;
  border-color: rgba(148, 163, 184, 0.22) !important;
}

.header-menu-inner button:active,
.snap-actions-menu button:active,
#textActionsMenu button:active,
.nb-dropdown-menu button:active,
.notebook-subject-dropdown button:active {
  transform: translateY(1px);
}

/* Focus ring (keyboard) */
.header-menu-inner button:focus-visible,
.snap-actions-menu button:focus-visible,
#textActionsMenu button:focus-visible,
.nb-dropdown-menu button:focus-visible,
.notebook-subject-dropdown button:focus-visible {
  outline: none !important;
  box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.35) !important;
}

/* Icons inside menu items */
.header-menu-inner .material-symbols-outlined,
.snap-actions-menu .material-symbols-outlined,
#textActionsMenu .material-symbols-outlined,
.nb-dropdown-menu .material-symbols-outlined,
.notebook-subject-dropdown .material-symbols-outlined {
  font-size: 20px !important;
  opacity: 0.85 !important;
}

/* =========================================================
   NOTEBOOK <details> dropdown trigger styling
========================================================= */

.nb-dropdown > summary {
  list-style: none;
}
.nb-dropdown > summary::-webkit-details-marker {
  display: none;
}

.nb-dropdown-toggle {
  display: flex !important;
  align-items: center !important;
  justify-content: space-between !important;
  gap: 10px !important;

  min-height: 40px !important;
  padding: 10px 12px !important;

  border-radius: 6px !important;
  border: 1px solid rgba(148,163,184,0.35) !important;
  background: var(--card-bg, #fff) !important;

  font-size: 13px !important;
  font-weight: 600 !important;

  cursor: pointer !important;
}

.nb-dropdown[open] > .nb-dropdown-toggle {
  box-shadow: 0 0 0 3px rgba(59,130,246,0.20) !important;
}

/* Position menu nicely under the summary (if you're using details) */
.nb-dropdown {
  position: relative;
}
.nb-dropdown-menu {
  position: absolute;
  top: calc(100% + 8px);
  left: 0;
  z-index: 50;
}

/* =========================================================
   OPTIONAL: Grid layout for “tool picker” style menus
   Add class="pg-dropdown-grid" to the menu you want in a grid
========================================================= */

.pg-dropdown-grid {
  display: grid !important;
  grid-template-columns: repeat(2, minmax(140px, 1fr)) !important;
  gap: 8px !important;
}

@media (max-width: 520px) {
  .pg-dropdown-grid {
    grid-template-columns: 1fr !important;
  }
}
/* Hide the sticky-loop mobile toggles on desktop */

  #drawerToggle{
    display: none !important;
  }
@media (max-width: 640px){
  .btn-row{
    align-items: self-end;
  }
}
.u13-disclaimer{
  color: var(--muted, rgba(148,163,184,.95));
     margin-left: 5px;
    font-size: .65em;
    margin-top: 5px;
    border-top: 1px solid var(--outline);
    padding: 7px 5px 0 7px;
	margin-left: 5px; font-size: .65em;
}


</style>

</head>

<body>
<div class="app">
 <header>
  <div class="title-block">
    <div class="title-row">
      <div class="brand-logo-wrap">
        <img
          src="studylens-dark-highvis.png"
          class="brand-logo brand-logo-light"
          alt="StudyLens"
        />
        <img
          src="studylens-dark-highvis.png"
          class="brand-logo brand-logo-dark"
          alt="StudyLens"
        />
      </div>
      <h1 class="visually-hidden">StudyLens</h1>
    </div>
    <div class="subtitle">
      Snap, solve, study & write.<span class="mobile-break"><br></span> Built
      for students.
    </div>

    <!-- NEW: metrics row lives in the header now -->
    <div
      class="header-metrics pg-loop-row pg-loop-row--metrics"
      data-sticky-loop
      data-loop-interval="6000"
    >
      <div class="pg-loop-pill">
        <span class="pg-loop-pill-label">Today</span>
        <span class="pg-loop-pill-value" data-pg-streak-value>—</span>
      </div>

      <div class="pg-loop-pill">
        <div class="pg-loop-items" id="pg-loop-metrics-rotator">
          <div class="pg-loop-item pg-loop-item--active">
            <span class="pg-loop-pill-label">Weekly recap</span>
            <span
              class="pg-loop-pill-value"
              data-pg-weekly-summary
            >
              —
            </span>
          </div>
          <div class="pg-loop-item">
            <span class="pg-loop-pill-label">Questions solved</span>
            <span
              class="pg-loop-pill-value"
              data-pg-session-count
            >
              —
            </span>
          </div>
        </div>
      </div>
    </div>
    <!-- end header-metrics -->
  </div>

  <div class="header-right">
    <!-- your existing auth-row etc stays the same -->
    <div class="auth-row">
      <span id="proBadge" style="display:none; font-weight:bold;">
        Pro account ✅
      </span>
      <span id="userPlanLabel">Guest · 10 free uses</span>
    </div>
  </div>
</header>

  
  <!-- Sticky progress / loop bar (right under header) -->
<!-- Sticky bar: JUST the two buttons -->
<section id="pg-sticky-loop-shell">
  <div class="pg-loop-row pg-loop-row--actions">
    <!-- existing Menu dropdown -->
    <div class="header-top-row">
		  <div
            class="chip learn-mode"
            id="modeChip"
            style="justify-content:space-between;"
          >
            <span class="chip-dot"></span>
            <span class="mode-label">Learn mode ON</span>
          </div>
      <details
        class="header-menu"
        style="position:relative; display:inline-block;"
      >

        <summary
          class="pill-button"
          style="display:inline-flex;align-items:center;gap:4px;cursor:pointer;"
        >
          <span class="material-symbols-outlined" style="font-size:18px;"
            >expand_more</span
          >
          <span>Menu</span>
        </summary>

        <div
          class="header-menu-inner">
          <!-- everything inside the dropdown stays exactly the same -->
		  
          <button
            class="drawer-toggle" style="display:none;"
            id="drawerToggle"
            type="button"
            style="width:100%; justify-content:center;"
          >
            <span class="material-symbols-outlined">view_sidebar</span>
            <span>Tools</span>
          </button>

          <button
            class="theme-toggle"
            id="themeToggle"
            type="button"
            style="width:100%; justify-content:center;"
          >
            <svg id="iconSun" viewBox="0 0 24 24">
              <path
                fill="currentColor"
                d="M12 4a1 1 0 0 1 1 1V6a1 1 0 1 1-2 0V5a1 1 0 0 1 1-1Zm0 12a4 4 0 1 0 0-8 4 4 0 0 0 0 8Zm8-4a1 1 0 0 1-1 1h-1a1 1 0 1 1 0-2h1a1 1 0 0 1 1 1ZM6 13a1 1 0 1 1 0-2H5a1 1 0 1 1 0 2h1Zm11.07-5.07a1 1 0 0 1-1.41 0L14.9 7.17a1 1 0 0 1 1.42-1.41l.76.76a1 1 0 0 1 0 1.41Zm-9.54 9.54a1 1 0 0 1-1.41 0l-.76-.76A1 1 0 0 1 6.24 15.3l.76.76a1 1 0 0 1 0 1.41ZM18 17.24a1 1 0 0 1 0-1.41l.76-.76a1 1 0 1 1 1.41 1.41l-.76.76a1 1 0 0 1-1.41 0ZM6.24 8.7a1 1 0 0 1-1.41-1.41l.76-.76A1 1 0 0 1 7 7.24l-.76.76Z"
              />
            </svg>
            <svg id="iconMoon" viewBox="0 0 24 24" style="display: none">
              <path
                fill="currentColor"
                d="M20.3 14.8A7.5 7.5 0 0 1 11.2 3.7 1 1 0 0 0 10 2.49 9.5 9.5 0 1 0 21.51 14a1 1 0 0 0-1.21-1.22Z"
              />
            </svg>
            <span id="themeLabel">Dark</span>
          </button>
 <button
            id="authButton"
            class="pill-button"
            type="button"
            style="width:100%; justify-content:center;"
          >
            Sign in
          </button>
          <button
            id="upgradeButton"
            class="pill-button"
            type="button"
            style="width:100%; justify-content:center;"
          >
            Upgrade to Pro
          </button>
		  <p class="u13-disclaimer">
  Under 13? Please don’t create an account.
</p>

        </div>
      </details>
    </div>

    <!-- Tools pill in the loop -->
    <button
      type="button"
      class="pill-button"
      id="pg-loop-tools-toggle"
    >
      <span class="material-symbols-outlined" aria-hidden="true">view_sidebar</span>
      <span>Tools</span>
    </button>
  </div>
</section>



  <div class="top-bar">
    <select id="subjectSelect" class="text-input">
      <option value="general">Subject: Auto</option>
      <option value="math">Math</option>
      <option value="science">Science</option>
      <option value="english">English</option>
      <option value="history">History</option>
    </select>

    <!-- Single model option, still uses value="smart" so backend stays the same -->
    <select id="modelSelect" class="text-input">
      <option value="smart">Model: (smart auto)</option>
    </select>
  </div>

  <p class="desc" style="margin: 0; font-size: 0.72rem;">
    Subject just gives the AI a hint (Math, Science, etc.). You can leave it on
    <strong>Auto</strong>.
  </p>

  <div class="main-layout">
    <div class="content">
      <!-- SNAP & SOLVE (always visible main input) -->
      <section id="snap" class="tab-content active">
        <div class="card">
          <h2>Snap</h2>
          <p class="desc">
            Take a photo or screenshot of homework → text → AI explanation.
          </p>


          <!-- Hidden file inputs: gallery + camera -->
          <input
            type="file"
            id="snapInputGallery"
            accept="image/*"
            style="display:none;"
          />
          <input
            type="file"
            id="snapInputCamera"
            accept="image/*"
            capture="environment"
            style="display:none;"
          />

          <!-- DROPDOWN WRAPPER FOR SNAP ACTIONS -->
		  
          <div class="btn-row snap-actions-wrapper">
            <div class="snap-actions-dropdown">
              <button
                class="pill-button snap-actions-toggle"
                id="snapActionsToggle"
                type="button"
              >
                <span
                  class="material-symbols-outlined"
                  style="font-size: 18px;"
                >
                  expand_more
                </span>
                <span>Image actions</span>
              </button>

              <div class="snap-actions-menu" id="snapActionsMenu">
                <!-- Open camera / gallery -->
                <button id="snapCameraBtn" type="button">
                  <span class="material-symbols-outlined">photo_camera</span>
                  <span>Take Photo</span>
                </button>

                <button
                  id="snapUploadBtn"
                  class="secondary"
                  type="button"
                >
                  <span class="material-symbols-outlined">image</span>
                  <span>Upload Image</span>
                </button>

                <button id="snapOCRBtn" type="button">
                  <span class="material-symbols-outlined">scan</span>
                  <span>Run OCR</span>
                </button>

                <button
                  class="secondary"
                  id="snapClearBtn"
                  type="button"
                >
                  <span class="material-symbols-outlined">delete</span>
                  <span>Clear</span>
                </button>
              </div>
            </div>
          </div>

          <!-- Preview -->
          <img
            id="snapPreview"
            alt="Homework preview"
            style="
              margin-top: 8px;
              max-width: 100%;
              border-radius: 6px;
              display: none;
            "
          />

          <div class="snap-text-header">
            <label for="snapText">
             You can also type or pastehere)
            </label>

            <button
              id="copySnapTextBtn"
              type="button"
              aria-label="Copy text"
            >
              <span class="material-symbols-outlined">content_copy</span>
              <span class="copy-label">Copy</span>
            </button>
          </div>

          <textarea
            id="snapText"
            class="text-input"
            placeholder="OCR text will appear here..."
          ></textarea>

          <!--<button id="refreshOcrButton" type="button" disabled>↻ Refresh OCR</button>-->
<div class="hint-row" style="margin-top: 10px; flex-direction: column; align-items: stretch;">
  <label for="extraInstructions" class="desc" style="margin: 0 0 4px; font-size: 0.75rem;">
    Optional: tell the AI what you want (tone, length, format, etc.)
  </label>
  <textarea
    id="extraInstructions"
    class="text-input"
    placeholder="Example: Explain like I'm in 8th grade and keep the answer under 5 steps."
    style="min-height: 60px;"
  ></textarea>
</div>
          <!-- NEW: custom subject / folder name for saving work -->
          <div
            class="hint-row"
            style="margin-top: 14px; justify-content: flex-start;"
          >
            <span class="desc" style="margin: 0; font-size: 0.75rem;">
              Save this work under:
            </span>
            <input
              id="saveSubjectInput"
              class="text-input"
              type="text"
              value="ex: algebra 2 fri"
              placeholder="e.g. Algebra test 2"
              style="
                
                font-size: 0.9rem;
                padding: 8px 10px;
                border-radius: 6px;
                flex: 0 0 auto;
                min-width: 110px;
              "
            />
          </div>


          <div class="hint-row" style="margin-top: 16px;">
            <span class="desc" style="margin: 0; font-size: 0.75rem;">
              What do you want to do with this text?
            </span>
          </div>

<div class="hint-row" style="margin-top: 4px; justify-content:flex-start;">
  <div class="snap-actions-dropdown" id="textActionsDropdown">
    <!-- dropdown toggle -->
    <button
      class="pill-button snap-actions-toggle"
      id="textActionsToggle"
      type="button"
    >
      <span class="material-symbols-outlined" style="font-size:18px;">
        expand_more
      </span>
      <span>Text actions</span>
    </button>

    <!-- dropdown menu with your existing buttons -->
    <div class="snap-actions-menu" id="textActionsMenu">
      <button id="snapActionSolveBtn" class="pill-button" type="button">
        <span class="material-symbols-outlined" style="font-size: 16px;">
          photo_camera
        </span>
        <span>Solve / Explain</span>
      </button>
<!-- A) Add this button INSIDE the Text actions menu (#textActionsMenu) -->
<button id="notesBtn" class="pill-button" type="button">
  <span class="material-symbols-outlined" style="font-size:16px;">
    checklist
  </span>
  <span>Extract Notes</span>
</button>
      <button id="mathSolveBtn" class="pill-button" type="button">
        <span class="material-symbols-outlined">calculate</span>
        <span>Math Solver</span>
      </button>

      <button id="studyGuideBtn" class="pill-button" type="button">
        <span class="material-symbols-outlined">menu_book</span>
        <span>Study Guide</span>
      </button>

      <button id="essayBtn" class="pill-button" type="button">
        <span class="material-symbols-outlined">draw</span>
        <span>Essay Helper</span>
      </button>

      <button id="cardsBtn" class="pill-button" type="button">
        <span class="material-symbols-outlined">style</span>
        <span>Flashcards</span>
      </button>
    </div>
  </div>
</div>

        </div>
      </section>

      <!-- SOLVE RESULT (new tool section) -->
      <section id="solve" class="tab-content">
        <div class="card">
          <h2>Solve</h2>
          <p class="desc">
            Results from solving the text in the Snap area.
          </p>
          <div class="hint-row">
            <button
              class="pill-button"
              type="button"
              data-action="simplify"
              data-target="snapResult"
            >
              <span
                class="material-symbols-outlined"
                style="font-size: 16px;"
                >lightbulb</span
              >
              Explain simpler
            </button>
            <button
              class="pill-button"
              type="button"
              data-action="hint"
              data-target="snapResult"
            >
              <span
                class="material-symbols-outlined"
                style="font-size: 16px;"
                >tips_and_updates</span
              >
              Give me a hint
            </button>
          </div>




          <pre id="snapResult" class="text-output"></pre>
		  <!-- Export bar for Solve output -->
<div class="output-export-bar" style="margin:8px 0; display:flex; align-items:center; gap:6px;">
  <button type="button" class="pill-button output-pdf-download" data-target="snapResult">Download PDF</button>
  <button type="button" class="pill-button output-backup-download" data-target="snapResult">Backup</button>
  <button type="button" class="pill-button output-backup-restore" data-target="snapResult">Restore</button>
  <input type="file" class="output-backup-file" data-target="snapResult" accept="application/json" style="display:none;">
</div>
        </div>
      </section>

      <!-- MATH SOLVER -->
      <section id="math" class="tab-content">
        <div class="card">
          <h2>Math Solver</h2>
          <p class="desc">
            Type or paste a math question → step-by-step solution.
          </p>

          
          <label for="snapText"
            ></label
          >
          <textarea
            id="mathInput"
            class="text-input"
            placeholder="Example: Solve 3x + 7 = 22"
            style="display:none;"
          ></textarea>

          <!-- Action button removed here; only Clear remains -->
          <div class="btn-row">
            <button
              class="secondary"
              id="mathClearBtn"
              type="button"
            >
              <span class="material-symbols-outlined">delete</span>
              <span>Clear</span>
            </button>
          </div>

          <div class="hint-row">
            <button
              class="pill-button"
              data-action="simplify"
              data-target="mathResult"
            >
              <span
                class="material-symbols-outlined"
                style="font-size: 16px;"
                >lightbulb</span
              >
              Explain simpler
            </button>
          </div>

          <pre id="mathResult" class="text-output"></pre>
		  
        </div>
      </section>

      <!-- STUDY GUIDE -->
      <section id="study" class="tab-content">
        <div class="card">
          <h2>Study Guide</h2>
          <p class="desc">
            Turn messy notes or textbook text into a clean study guide.
          </p>

 
          <label for="snapText"
            ></label
          >
          <textarea
            id="studyInput"
            class="text-input"
            placeholder="Paste your notes or textbook text here..."
            style="display:none;"
          ></textarea>

          <!-- Action button removed here; only Clear remains -->
          <div class="btn-row">
            <button
              class="secondary"
              id="studyClearBtn"
              type="button"
            >
              <span class="material-symbols-outlined">delete</span>
              <span>Clear</span>
            </button>
          </div>

          <div class="hint-row">
            <button
              class="pill-button"
              data-action="simplify"
              data-target="studyResult"
            >
              <span
                class="material-symbols-outlined"
                style="font-size: 16px;"
                >lightbulb</span
              >
              Explain simpler
            </button>
          </div>

          <pre id="studyResult" class="text-output"></pre>
		  <!-- Export bar for Solve output -->
<div class="output-export-bar" style="margin:8px 0; display:flex; align-items:center; gap:6px;">
  <button type="button" class="pill-button output-pdf-download" data-target="snapResult">Download PDF</button>
  <button type="button" class="pill-button output-backup-download" data-target="snapResult">Backup</button>
  <button type="button" class="pill-button output-backup-restore" data-target="snapResult">Restore</button>
  <input type="file" class="output-backup-file" data-target="snapResult" accept="application/json" style="display:none;">
</div>
        </div>
      </section>

      <!-- ESSAY HELPER -->
      <section id="essay" class="tab-content">
        <div class="card">
          <h2>Essay Helper</h2>
          <p class="desc">
            Fix grammar, improve structure, or generate a draft from a prompt.
          </p>

        
          <label for="snapText"
            ></label
          >
          <textarea
            id="essayInput"
            class="text-input"
            placeholder="Paste your essay or describe what you need to write..."
            style="display:none;"
          ></textarea>

          <!-- Action button removed here; only Clear remains -->
          <div class="btn-row">
            <button
              class="secondary"
              id="essayClearBtn"
              type="button"
            >
              <span class="material-symbols-outlined">delete</span>
              <span>Clear</span>
            </button>
          </div>

          <div class="hint-row">
            <button
              class="pill-button"
              data-action="simplify"
              data-target="essayResult"
            >
              <span
                class="material-symbols-outlined"
                style="font-size: 16px;"
                >lightbulb</span
              >
              Simpler version
            </button>
          </div>
<div class="output-format-bar">
  <label for="formatSelect-essayResult" style="margin-right:6px;">
    Format:
  </label>
  <select
    id="formatSelect-essayResult"
    class="text-input output-format-select"
    data-target="essayResult"
    style="width:auto; min-width:160px;"
  >
    <option value="plain">Plain (no formatting)</option>
    <option value="mla">MLA</option>
    <option value="apa">APA 7</option>
    <option value="chicago">Chicago / Turabian</option>
    <option value="ieee">IEEE</option>
  </select>

  <button
    type="button"
    class="pill-button output-format-apply"
    data-target="essayResult"
    style="margin-left:6px;"
  >
    Apply format
  </button>
</div>
          <pre id="essayResult" class="text-output"></pre>
		  <!-- Export bar for Solve output -->
<div class="output-export-bar" style="margin:8px 0; display:flex; align-items:center; gap:6px;">
  <button type="button" class="pill-button output-pdf-download" data-target="snapResult">Download PDF</button>
  <button type="button" class="pill-button output-backup-download" data-target="snapResult">Backup</button>
  <button type="button" class="pill-button output-backup-restore" data-target="snapResult">Restore</button>
  <input type="file" class="output-backup-file" data-target="snapResult" accept="application/json" style="display:none;">
</div>
        </div>
      </section>



<section id="notes" class="tab-content">
  <div class="card">
    <h2>Extract Notes</h2>
    <p class="desc">
      Turn the Snap text into short, high-yield bullet points.
    </p>

    <p class="notes-hint">
      This uses the main Snap textbox (OCR or pasted text). No extra typing needed.
    </p>

    <!-- hidden input, like the other tools; we still copy Snap text into here -->
    <label for="snapText">
      Source text
    </label>
    <textarea
      id="notesInput"
      class="text-input"
      placeholder="(Uses the Snap text above)"
      style="display:none;"
    ></textarea>

    <div class="btn-row">
      <button
        class="secondary"
        id="notesClearBtn"
        type="button"
      >
        <span class="material-symbols-outlined">delete</span>
        <span>Clear</span>
      </button>
    </div>

    <div class="hint-row">
      <button
        class="pill-button"
        data-action="simplify"
        data-target="notesResult"
        type="button"
      >
        <span class="material-symbols-outlined" style="font-size:16px;">
          lightbulb
        </span>
        <span>Explain simpler</span>
      </button>
    </div>

    <pre id="notesResult" class="text-output"></pre>
	<!-- Export bar for Solve output -->
<div class="output-export-bar" style="margin:8px 0; display:flex; align-items:center; gap:6px;">
  <button type="button" class="pill-button output-pdf-download" data-target="snapResult">Download PDF</button>
  <button type="button" class="pill-button output-backup-download" data-target="snapResult">Backup</button>
  <button type="button" class="pill-button output-backup-restore" data-target="snapResult">Restore</button>
  <input type="file" class="output-backup-file" data-target="snapResult" accept="application/json" style="display:none;">
</div>
  </div>
</section>





      <section id="flashcards" class="tab-content">
        <div class="card">
          <h2>Flashcards</h2>
          <p class="desc">
            Paste content → get term/question → answer flashcards.
          </p>

   
         
          <textarea
            id="cardsInput"
            class="text-input"
            placeholder="Paste notes, vocabulary lists, or textbook text..."
            style="display:none;"
          ></textarea>

          <!-- Action button removed here; only Clear remains -->
          <div class="btn-row">
            <button
              class="secondary"
              id="cardsClearBtn"
              type="button"
            >
              <span class="material-symbols-outlined">delete</span>
              <span>Clear</span>
            </button>
          </div>

          <!-- Raw AI output (for debug / copy) -->
          <pre id="cardsResult" class="text-output"></pre>

          <!-- New interactive flashcard viewer -->
          <div
            id="cardsViewer"
            style="display: none; margin-top: 10px;"
          >
            

            <div id="cardsCard" class="flashcard">
              <div id="cardsFront" class="flashcard-side">
                Front
              </div>
              <div
                id="cardsBack"
                class="flashcard-side"
                style="display: none;"
              >
                Back
              </div>
            </div>
<div id="cardsStats" class="desc">
              <!-- e.g. Card 1 of 10 • You Got It 3 • Study More 2 -->
            </div>
            <div class="btn-row" style="margin-top: 8px;">
              

              <button
                class="secondary"
                id="cardsGotItBtn"
                type="button"
              >
                <span class="material-symbols-outlined"></span>
                <span>Got It</span>
              </button>
			  
			  <button
                class="secondary"
                id="cardsNeedWorkBtn"
                type="button"
              >
                <span class="material-symbols-outlined"></span>
                <span>Study More</span>
              </button>

              <button id="cardsFlipBtn" type="button">
                <span class="material-symbols-outlined">sync</span>
                <span>Flip</span>
              </button>
            </div>
          </div>
        </div>
      </section>
	  
	  
	  
	  
<section id="notebook" class="tab-content">
<div class="card">
<h2>Notebook</h2>
<p class="desc">
  Recent saved results from Snap, Math, Study, Essay, etc.
</p>

<!-- NEW: notebook top row with two dropdowns -->
<div class="notebook-top-row">
  <!-- Saved Subjects dropdown (uses #notebookSubjects) -->
  <details class="nb-dropdown" id="nbSavedSubjectsDropdown">
    <summary class="pill-button nb-dropdown-toggle ">
      <span class="material-symbols-outlined" style="font-size:16px;">label</span>
      <span>Saved Subjects</span>
      <span class="material-symbols-outlined nb-dropdown-caret">expand_more</span>
    </summary>

    <div class="nb-dropdown-menu" id="nbSavedSubjectsMenu pg-dropdown-grid">
      <!-- your subject chips still render into this same element -->
      <div id="notebookSubjects" class="hint-row" style="margin-bottom:0;"></div>
    </div>
  </details>

  <!-- Subjects by tools dropdown (uses existing .notebook-filter buttons) -->
  <details class="nb-dropdown" id="nbToolFilterDropdown">
    <summary class="pill-button nb-dropdown-toggle">
      <span class="material-symbols-outlined" style="font-size:16px;">filter_alt</span>
      <span>Subjects by tools</span>
      <span class="material-symbols-outlined nb-dropdown-caret">expand_more</span>
    </summary>

    <div class="nb-dropdown-menu" id="nbToolFilterMenu">
      <div class="hint-row" id="notebookFilterRow">
        <button
          class="pill-button notebook-filter active"
          data-filter="all"
        >
          <span class="material-symbols-outlined" style="font-size:16px;">
            filter_alt
          </span>
          <span>All</span>
        </button>

        <button
          class="pill-button notebook-filter"
          data-filter="Snap"
        >
          <span class="material-symbols-outlined" style="font-size:16px;">
            photo_camera
          </span>
          <span>Solve</span>
        </button>

        <button
          class="pill-button notebook-filter"
          data-filter="Math"
        >
          <span class="material-symbols-outlined" style="font-size:16px;">
            calculate
          </span>
          <span>Math</span>
        </button>

        <button
          class="pill-button notebook-filter"
          data-filter="Study"
        >
          <span class="material-symbols-outlined" style="font-size:16px;">
            menu_book
          </span>
          <span>Study</span>
        </button>

        <button
          class="pill-button notebook-filter"
          data-filter="Essay"
        >
          <span class="material-symbols-outlined" style="font-size:16px;">
            draw
          </span>
          <span>Essay</span>
        </button>

        <button
          class="pill-button notebook-filter"
          data-filter="Cards"
        >
          <span class="material-symbols-outlined" style="font-size:16px;">
            style
          </span>
          <span>Flashcards</span>
        </button>
      </div>
    </div>
  </details>
</div>



<!-- keep your existing Clear / Undo row exactly as it was -->
<div class="btn-row" style="margin-bottom: 8px;">
  <button class="secondary" id="clearNotebookBtn" type="button">
    <span class="material-symbols-outlined">delete_forever</span>
    <span>Clear notebook</span>
  </button>
  <button class="secondary" id="undoNotebookBtn" type="button">
    <span class="material-symbols-outlined">undo</span>
    <span>Undo</span>
  </button>
</div>

<!-- notebookSubjects div is now inside the Saved Subjects dropdown above -->
<div id="notebookList"></div>
</div>
</section>


      <div class="hint-footer" id="hintFooter">
        AI is for learning, not cheating. Always check your work.
      </div>
    </div>

    <!-- RIGHT SIDE DRAWER / SIDEBAR -->
    <aside class="side-drawer" id="sideDrawer">
  <div class="side-drawer-inner">

    <div class="side-drawer-header">TOOLS</div>

    <nav class="side-nav">
      <!-- NEW: OCR tool -->
      <button class="nav-btn active" data-target="snap" type="button">
        <span class="material-symbols-outlined">scan</span>
        <span class="label">Snap</span>
      </button>

      <button class="nav-btn" data-target="notes" type="button">
        <span class="material-symbols-outlined">checklist</span>
        <span class="label">Extract Notes</span>
      </button>

      <!-- Existing tools, unchanged except Solve is no longer the default active -->
      <button class="nav-btn" data-target="solve" type="button">
        <span class="material-symbols-outlined">photo_camera</span>
        <span class="label">Solve</span>
      </button>

      <button class="nav-btn" data-target="math" type="button">
        <span class="material-symbols-outlined">calculate</span>
        <span class="label">Math Solver</span>
      </button>

      <button class="nav-btn" data-target="study" type="button">
        <span class="material-symbols-outlined">menu_book</span>
        <span class="label">Study Guide</span>
      </button>

      <button class="nav-btn" data-target="essay" type="button">
        <span class="material-symbols-outlined">draw</span>
        <span class="label">Essay Helper</span>
      </button>

      <button class="nav-btn" data-target="flashcards" type="button">
        <span class="material-symbols-outlined">style</span>
        <span class="label">Flashcards</span>
      </button>

      <button class="nav-btn" data-target="notebook" type="button">
        <span class="material-symbols-outlined">book_2</span>
        <span class="label">Notebook</span>
      </button>
    </nav>

  </div>
</aside>

  </div>
</div>





<!-- Fixed back / forward tool buttons -->
<div id="tabNavButtons">
  <button id="backTabButton" class="tab-nav-btn" type="button">
    ← Back
  </button>
  <button id="forwardTabButton" class="tab-nav-btn" type="button">
    Forward →
  </button>
</div>










<!-- BLOCK 1: Theme toggle, drawer/sidebar, subject/model helpers -------------------------
--------------------------------------------------------------------------------------=----
===========================================================================================
===========================================================================================
------------------------------------------------------------------------------------------->

<script>

/* =========================================================
   SECTION 0: Grab the elements we will control (START)
   - These IDs must match your HTML exactly (we did not change them)
========================================================= */
const themeToggle     = document.getElementById("themeToggle");
const themeLabel      = document.getElementById("themeLabel");
const iconSun         = document.getElementById("iconSun");
const iconMoon        = document.getElementById("iconMoon");

const drawerToggle    = document.getElementById("drawerToggle");
const sideDrawer      = document.getElementById("sideDrawer");
const drawerBackdrop  = document.getElementById("drawerBackdrop");
/* ===================== SECTION 0 (END) ===================== */



/* =========================================================
   SECTION 1: Theme toggle (START)
   Goal:
   - Switch between "dark" and "light"
   - Update <html data-theme="...">
   - Save it in localStorage so it can persist
   - Update label + icons
   - Update the browser/status bar color (meta theme-color)
========================================================= */

/* --- PART 1A: Keep browser/status bar color in sync (START) --- */
function applyThemeColor(theme) {
  // Find <meta name="theme-color" ...> in your <head>
  const meta = document.querySelector('meta[name="theme-color"]');

  // Safety: if the meta tag doesn't exist, stop here
  if (!meta) return;

  const isDark = theme === "dark";

  // Dark uses your dark surface, light uses your light header/bg
  meta.setAttribute("content", isDark ? "#020617" : "#f9fafb");
}
/* --- PART 1A (END) --- */


/* --- PART 1B: Apply a theme everywhere (START) --- */
function setTheme(theme) {
  // 1) Put the theme on the <html> element as an attribute
  document.documentElement.setAttribute("data-theme", theme);

  // 2) Save theme so it persists in the browser
  localStorage.setItem("studyai-theme", theme);

  // 3) Update label + icons (only if those elements exist)
  const dark = theme === "dark";

  if (themeLabel) themeLabel.textContent = dark ? "Dark" : "Light";

  if (iconSun)  iconSun.style.display  = dark ? "block" : "none";
  if (iconMoon) iconMoon.style.display = dark ? "none"  : "block";

  // 4) Sync the browser/status bar color
  applyThemeColor(theme);
}
/* --- PART 1B (END) --- */


/* --- PART 1C: Initialize the theme on page load (START) --- */
const initialTheme =
  document.documentElement.getAttribute("data-theme") || "dark";

setTheme(initialTheme);
/* --- PART 1C (END) --- */


/* --- PART 1D: Click handler for theme toggle button (START) --- */
if (themeToggle) {
  themeToggle.addEventListener("click", () => {
    const current =
      document.documentElement.getAttribute("data-theme") || "dark";

    // Flip the theme
    setTheme(current === "dark" ? "light" : "dark");
  });
}
/* --- PART 1D (END) --- */

/* ===================== SECTION 1 (END) ===================== */



/* =========================================================
   SECTION 2: Drawer / sidebar (START)
   Goal:
   - On desktop (>= 800px) the drawer stays open
   - On mobile (< 800px) it opens/closes with a toggle
   - Backdrop click closes it
   - Resize adjusts the state
========================================================= */

/* --- PART 2A: Desktop check helper (START) --- */
function isDesktop() {
  return window.innerWidth >= 800;
}
/* --- PART 2A (END) --- */


/* --- PART 2B: Open drawer (START) --- */
function openDrawer() {
  // On desktop it is always visible; do nothing
  if (isDesktop()) return;

  // ✅ Safety: drawer is required, backdrop is optional
  if (!sideDrawer) return;

  // Open the drawer
  sideDrawer.classList.add("open");

  // Show backdrop ONLY if it exists (do NOT block opening if missing)
  if (drawerBackdrop) {
    drawerBackdrop.classList.add("show");
  }
}
/* --- PART 2B (END) --- */


/* --- PART 2C: Close drawer (START) --- */
function closeDrawer() {
  if (isDesktop()) return;

  // ✅ Safety: drawer is required, backdrop is optional
  if (!sideDrawer) return;

  // Close the drawer
  sideDrawer.classList.remove("open");

  // Hide backdrop ONLY if it exists
  if (drawerBackdrop) {
    drawerBackdrop.classList.remove("show");
  }
}
/* --- PART 2C (END) --- */


/* --- PART 2D: Toggle button click (START) --- */
if (drawerToggle) {
  drawerToggle.addEventListener("click", () => {
    // Safety: if drawer element is missing, do nothing
    if (!sideDrawer) return;

    if (sideDrawer.classList.contains("open")) {
      closeDrawer();
    } else {
      openDrawer();
    }
  });
}
/* --- PART 2D (END) --- */


/* --- PART 2E: Backdrop click closes drawer (START) --- */
if (drawerBackdrop) {
  drawerBackdrop.addEventListener("click", closeDrawer);
}
/* --- PART 2E (END) --- */


/* --- PART 2F: Window resize behavior (START) --- */
window.addEventListener("resize", () => {
  if (!sideDrawer) return;

  if (isDesktop()) {
    // Desktop: drawer open, backdrop hidden
    sideDrawer.classList.add("open");
    if (drawerBackdrop) drawerBackdrop.classList.remove("show");
  } else {
    // Mobile: drawer closed by default
    sideDrawer.classList.remove("open");
  }
});
/* --- PART 2F (END) --- */


/* --- PART 2G: Initial state on page load (START) --- */
if (isDesktop() && sideDrawer) {
  sideDrawer.classList.add("open");
}
/* --- PART 2G (END) --- */

/* ===================== SECTION 2 (END) ===================== */



/* =========================================================
   SECTION 3: Subject / Model helpers (START)
   Goal:
   - Give you a safe "default" if the dropdown is missing or empty
========================================================= */

function getSubject() {
  const subjectSelect = document.getElementById("subjectSelect");
  return (subjectSelect && subjectSelect.value) ? subjectSelect.value : "general";
}

function getModelChoice() {
  const modelSelect = document.getElementById("modelSelect");
  return (modelSelect && modelSelect.value) ? modelSelect.value : "smart";
}

/* ===================== SECTION 3 (END) ===================== */

/* =========================================================
   PG NON-BLOCKING CONFIRM (START)
   - Replaces confirm() with Promise-based modal
   - Use: const ok = await pgConfirm("Delete this?");
========================================================= */

(function () {
  // One global init guard
  if (window.__pgConfirmReady) return;
  window.__pgConfirmReady = true;

  function ensureStyles() {
    if (document.getElementById("pgConfirmStyles")) return;
    const style = document.createElement("style");
    style.id = "pgConfirmStyles";
    style.textContent = `
      .pgc-backdrop{
        position:fixed; inset:0;
        background:rgba(0,0,0,.45);
        display:flex; align-items:center; justify-content:center;
        z-index:99999;
        padding:16px;
      }
      .pgc-modal{
        width:min(440px, 100%);
        background: var(--card-bg, #fff);
        color: var(--text, #0f172a);
        border: 1px solid rgba(148,163,184,.35);
        border-radius: 14px;
        box-shadow: 0 18px 60px rgba(0,0,0,.25);
        padding: 14px;
      }
      .pgc-title{
        font-weight:700;
        font-size:14px;
        margin:0 0 8px 0;
      }
      .pgc-msg{
        font-size:13px;
        line-height:1.35;
        opacity:.92;
        margin:0 0 12px 0;
        white-space:pre-wrap;
      }
      .pgc-actions{
        display:flex;
        justify-content:flex-end;
        gap:10px;
      }
      .pgc-btn{
        border-radius: 999px;
        padding: 8px 12px;
        font-size: 12px;
        border: 1px solid rgba(148,163,184,.55);
        background: transparent;
        cursor:pointer;
        box-shadow: 0 1px 0 rgba(255,255,255,.35) inset;
      }
      .pgc-btn--danger{
        border-color: rgba(239,68,68,.55);
      }
    `;
    document.head.appendChild(style);
  }

  window.pgConfirm = function pgConfirm(message, opts) {
    ensureStyles();

    opts = opts || {};
    const title = opts.title || "Confirm";
    const okText = opts.okText || "OK";
    const cancelText = opts.cancelText || "Cancel";
    const danger = !!opts.danger;

    return new Promise((resolve) => {
      const backdrop = document.createElement("div");
      backdrop.className = "pgc-backdrop";

      const modal = document.createElement("div");
      modal.className = "pgc-modal";
      modal.setAttribute("role", "dialog");
      modal.setAttribute("aria-modal", "true");

      const h = document.createElement("div");
      h.className = "pgc-title";
      h.textContent = title;

      const p = document.createElement("div");
      p.className = "pgc-msg";
      p.textContent = String(message || "");

      const actions = document.createElement("div");
      actions.className = "pgc-actions";

      const cancelBtn = document.createElement("button");
      cancelBtn.type = "button";
      cancelBtn.className = "pgc-btn";
      cancelBtn.textContent = cancelText;

      const okBtn = document.createElement("button");
      okBtn.type = "button";
      okBtn.className = "pgc-btn" + (danger ? " pgc-btn--danger" : "");
      okBtn.textContent = okText;

      actions.appendChild(cancelBtn);
      actions.appendChild(okBtn);

      modal.appendChild(h);
      modal.appendChild(p);
      modal.appendChild(actions);
      backdrop.appendChild(modal);
      document.body.appendChild(backdrop);

      function cleanup(result) {
        try { document.removeEventListener("keydown", onKey); } catch {}
        if (backdrop && backdrop.parentNode) backdrop.parentNode.removeChild(backdrop);
        resolve(result);
      }

      function onKey(e) {
        if (e.key === "Escape") cleanup(false);
        if (e.key === "Enter") cleanup(true);
      }

      // click outside closes (cancel)
      backdrop.addEventListener("pointerdown", (e) => {
        if (e.target === backdrop) cleanup(false);
      });

      cancelBtn.addEventListener("click", () => cleanup(false));
      okBtn.addEventListener("click", () => cleanup(true));
      document.addEventListener("keydown", onKey);

      // focus OK by default
      setTimeout(() => { try { okBtn.focus(); } catch {} }, 0);
    });
  };
})();

</script>




<!--=========================================================
   PG SAFE WIRING (START)
   - Prevents duplicate listeners when scripts are pasted multiple times
   - Use: PG.on(el, "click", "unique-key", handler)
   - Use: PG.delegate(root, "click", "unique-key", ".selector", handler)
========================================================= -->
<script>
/* =========================================================
   PG SAFE WIRING (START)
   - Prevents duplicate listeners when scripts are pasted multiple times
   - Use: PG.on(el, "click", "unique-key", handler)
   - Use: PG.delegate(root, "click", "unique-key", ".selector", handler)
========================================================= */

(function () {
  // One global namespace (don’t overwrite if already present)
  window.PG = window.PG || {};

  // Global init guard (prevents re-defining helpers)
  if (window.PG.__safeWiringReady) return;
  window.PG.__safeWiringReady = true;

  // Tracks "element + event + key" => wired
  const wired = new WeakMap();

  function markWired(el, eventName, key) {
    let map = wired.get(el);
    if (!map) {
      map = new Map();
      wired.set(el, map);
    }
    const k = eventName + "::" + key;
    if (map.get(k)) return false;
    map.set(k, true);
    return true;
  }

  // Safe addEventListener (won't double-wire)
  window.PG.on = function (el, eventName, key, handler, options) {
    if (!el || !eventName || !key || typeof handler !== "function") return;
    if (!markWired(el, eventName, key)) return; // already wired
    el.addEventListener(eventName, handler, options);
  };

  // Safe delegated listener (one listener on root, filters by selector)
  window.PG.delegate = function (root, eventName, key, selector, handler, options) {
    if (!root || !eventName || !key || !selector || typeof handler !== "function") return;

    // Only wire ONE root listener per event+key
    if (!markWired(root, eventName, key)) return;

    root.addEventListener(eventName, function (e) {
      const target = e.target && e.target.closest ? e.target.closest(selector) : null;
      if (!target || !root.contains(target)) return;
      handler.call(target, e, target);
    }, options);
  };
})();
</script>


<!-- BLOCK: Global “click off” closer for dropdowns/menus (safe, doesn’t break toggles) ----
--------------------------------------------------------------------------------------=----
===========================================================================================
===========================================================================================
------------------------------------------------------------------------------------------->

<script>
  (function () {
    function onReady(fn) {
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", fn);
      } else {
        fn();
      }
    }

    function hide(el) {
      if (!el) return;
      el.style.display = "none";
    }

    onReady(function () {
      const snapToggle = document.getElementById("snapActionsToggle");
      const snapMenu   = document.getElementById("snapActionsMenu");

      const textToggle = document.getElementById("textActionsToggle");
      const textMenu   = document.getElementById("textActionsMenu");

      function closeNotebookSubjectMenusIfClickOutside(target) {
        const openMenus = document.querySelectorAll(".notebook-subject-dropdown");
        openMenus.forEach(function (menu) {
          if (menu.style.display === "none") return;

          const row = menu.closest(".notebook-subject-row");
          if (row && row.contains(target)) return; // clicked inside -> keep open

          hide(menu);
        });
      }

      document.addEventListener("click", function (e) {
        const t = e.target;

        // Snap actions dropdown
        if (snapMenu) {
          const clickedSnap = (snapMenu.contains(t) || (snapToggle && snapToggle.contains(t)));
          if (!clickedSnap) hide(snapMenu);
        }

        // Text actions dropdown
        if (textMenu) {
          const clickedText = (textMenu.contains(t) || (textToggle && textToggle.contains(t)));
          if (!clickedText) hide(textMenu);
        }

        // Notebook subject “…” dropdowns
        closeNotebookSubjectMenusIfClickOutside(t);

        // Any <details open> menus (header menu, etc.)
        document.querySelectorAll("details[open]").forEach(function (d) {
          if (!d.contains(t)) d.removeAttribute("open");
        });
      });

      // ESC closes everything
      document.addEventListener("keydown", function (e) {
        if (e.key !== "Escape") return;

        hide(snapMenu);
        hide(textMenu);

        document.querySelectorAll(".notebook-subject-dropdown").forEach(function (m) {
          hide(m);
        });

        document.querySelectorAll("details[open]").forEach(function (d) {
          d.removeAttribute("open");
        });
      });
    });
  })();
</script>


<!-- BLOCK: Close drawer when clicking outside (mobile only) --------------------------------
--------------------------------------------------------------------------------------=----
===========================================================================================
===========================================================================================
------------------------------------------------------------------------------------------->

<script>
/* =========================================================
   SECTION 1: Close drawer on outside click (START)
   Rules:
   - Mobile only (width < 800)
   - Only if #sideDrawer currently has class "open"
   - Clicking OUTSIDE closes it
   - Clicking the toggle button does NOT close it (so toggle still works)
========================================================= */

document.addEventListener(
  "pointerdown",
  function (e) {
    /* --- PART 1A: Re-grab elements safely each time (START) --- */
    const sideDrawer = document.getElementById("sideDrawer");
    const drawerToggle = document.getElementById("drawerToggle");
    const drawerBackdrop = document.getElementById("drawerBackdrop");
    /* --- PART 1A (END) --- */

    /* --- PART 1B: Only run on mobile + only if drawer is open (START) --- */
    const isDesktopNow = window.innerWidth >= 800;
    if (isDesktopNow) return;
    if (!sideDrawer) return;
    if (!sideDrawer.classList.contains("open")) return;
    /* --- PART 1B (END) --- */

    /* --- PART 1C: Ignore clicks inside drawer OR on the toggle (START) --- */
    const clickedInsideDrawer = sideDrawer.contains(e.target);
    if (clickedInsideDrawer) return;

    const clickedToggle =
      drawerToggle && drawerToggle.contains(e.target);
    if (clickedToggle) return;
    /* --- PART 1C (END) --- */

    /* --- PART 1D: Outside click -> close drawer (START) --- */
    sideDrawer.classList.remove("open");
    if (drawerBackdrop) {
      drawerBackdrop.classList.remove("show");
    }
    /* --- PART 1D (END) --- */
  },
  true // capture phase = more reliable for "click outside" behavior
);

/* ===================== SECTION 1 (END) ===================== */
</script>




<!-- BLOCK 2: Cheat mode toggle (remembers last mode across refresh) -----------------------
--------------------------------------------------------------------------------------=----
===========================================================================================
===========================================================================================
------------------------------------------------------------------------------------------->

<script>
/* ===========================================================================================
   SECTION 0: Get the main element + define storage key (START)
   - We are NOT changing any IDs or classes
=========================================================================================== */
const modeChip = document.getElementById("modeChip");
const CHEAT_MODE_STORAGE_KEY = "pg_cheat_mode";
/* ================================== SECTION 0 (END) ===================================== */



/* ===========================================================================================
   SECTION 1: Load saved mode from localStorage (START)
   Goal:
   - On refresh, remember the last state
   - Store it on window.__cheatMode
     - false = Learn mode ON
     - true  = (hidden) cheat mode ON  -> Learn mode OFF
=========================================================================================== */

/* --- PART 1A: Immediately-run setup function (IIFE) (START) ---
   This runs once as soon as the script loads.
*/
(function initCheatModeFlag() {
  // Default if nothing is saved (Learn mode ON)
  let savedCheat = false;

  try {
    // Try to read the saved value from localStorage
    const stored = localStorage.getItem(CHEAT_MODE_STORAGE_KEY);

    // localStorage stores strings, so we compare against "true"/"false"
    if (stored === "true") {
      savedCheat = true;
    } else if (stored === "false") {
      savedCheat = false;
    }
  } catch (e) {
    // If storage is blocked/unavailable, we just keep the default (false)
  }

  // Put the result somewhere global so other scripts can read it if needed
  window.__cheatMode = savedCheat;
})();
/* --- PART 1A (END) --- */

/* ================================== SECTION 1 (END) ===================================== */



/* ===========================================================================================
   SECTION 2: Safety check (START)
   If #modeChip doesn't exist, do nothing (prevents errors).
=========================================================================================== */
if (!modeChip) {
  console.warn("modeChip element not found; cheat/learn toggle not initialized.");
} else {
/* ================================== SECTION 2 (END) ===================================== */



  /* =========================================================================================
     SECTION 3: Find elements INSIDE the chip (START)
     - These are looked up relative to #modeChip
     - Classes stay the same: .mode-label and .chip-dot
  ========================================================================================= */
  const modeLabel = modeChip.querySelector(".mode-label");
  const chipDot = modeChip.querySelector(".chip-dot");
  /* ================================= SECTION 3 (END) ==================================== */



  /* =========================================================================================
     SECTION 4: Update the UI to match the current mode (START)
     This function:
     - Updates the text "Learn mode ON/OFF"
     - Updates dot color (green/red)
     - Updates chip border and background
     - Sets a data-state attribute for styling/debugging
  ========================================================================================= */
  function updateModeChip() {
    // Learn mode is ON when cheatMode is FALSE
    const isLearnOn = !window.__cheatMode;

    /* ---- PART 4A: Update the text label (START) ---- */
    // Note: UI never mentions "cheat mode" (your original rule)
    if (modeLabel) {
      modeLabel.textContent = isLearnOn ? "Learn mode ON" : "Learn mode OFF";
    }
    /* ---- PART 4A (END) ---- */


    /* ---- PART 4B: Update the dot color (START) ---- */
    if (chipDot) {
      chipDot.style.backgroundColor = isLearnOn ? "#22c55e" : "#ef4444"; // green / red
    }
    /* ---- PART 4B (END) ---- */


    /* ---- PART 4C: Update the chip border color (START) ---- */
    modeChip.style.borderColor = isLearnOn
      ? "rgba(34,197,94,0.6)"   // green border
      : "rgba(239,68,68,0.6)";  // red border
    /* ---- PART 4C (END) ---- */


    /* ---- PART 4D: Update the chip background color (START) ---- */
    modeChip.style.backgroundColor = isLearnOn
      ? "rgba(80 219 131 / 12%)"  // light green background
      : "rgb(254 157 157 / 12%)"; // light red background
    /* ---- PART 4D (END) ---- */


    /* ---- PART 4E: Set a data attribute for state (START) ---- */
    // This can help with CSS hooks or debugging.
    modeChip.setAttribute("data-state", isLearnOn ? "on" : "off");
    /* ---- PART 4E (END) ---- */
  }
  /* ================================= SECTION 4 (END) ==================================== */



  /* =========================================================================================
     SECTION 5: Click handler (START)
     When the user clicks the chip:
     - Flip window.__cheatMode
     - Save it to localStorage
     - Update the UI
  ========================================================================================= */
  modeChip.addEventListener("click", () => {
    /* ---- PART 5A: Flip the mode (START) ---- */
    window.__cheatMode = !window.__cheatMode;
    /* ---- PART 5A (END) ---- */


    /* ---- PART 5B: Save the new mode to storage (START) ---- */
    try {
      localStorage.setItem(CHEAT_MODE_STORAGE_KEY, String(window.__cheatMode));
    } catch (e) {
      // If saving fails, ignore it (the UI still works for this session)
    }
    /* ---- PART 5B (END) ---- */


    /* ---- PART 5C: Refresh the UI (START) ---- */
    updateModeChip();
    /* ---- PART 5C (END) ---- */
  });
  /* ================================= SECTION 5 (END) ==================================== */



  /* =========================================================================================
     SECTION 6: Initial UI sync on page load (START)
     - Use the saved/default value and paint the chip correctly
  ========================================================================================= */
  updateModeChip();
  /* ================================= SECTION 6 (END) ==================================== */

} // end of "modeChip exists" else block
</script>



<!-- BLOCK 2: Notebook load/save/render, filters, add item ----------------------------------
--------------------------------------------------------------------------------------=----
===========================================================================================
===========================================================================================
------------------------------------------------------------------------------------------->

<script>
/* ===========================================================================================
   SECTION 0: Notebook globals + DOM elements (START)
   - IDs/classes are unchanged
=========================================================================================== */
const notebookKey = "studyai-notebook";

const notebookListEl = document.getElementById("notebookList");
const notebookFilterButtons = document.querySelectorAll(".notebook-filter");
const notebookSubjectsEl = document.getElementById("notebookSubjects");

let notebookFilter = "all";
let notebookSubjectFilter = "all";
let notebookLastSnapshot = null; // used for one-level undo
/* ================================== SECTION 0 (END) ===================================== */



/* ===========================================================================================
   SECTION 1: Clipboard helper (START)
   Goal:
   - Copy any text to the clipboard
   - Uses modern navigator.clipboard if available
   - Falls back to hidden textarea + execCommand("copy")
=========================================================================================== */
function copyTextToClipboard(text) {
  const value = String(text || "");
  if (!value) return;

  /* ---- PART 1A: Modern clipboard API (START) ---- */
  if (navigator.clipboard && navigator.clipboard.writeText) {
    navigator.clipboard.writeText(value).catch((err) => {
      console.error("Clipboard error:", err);
    });
    return;
  }
  /* ---- PART 1A (END) ---- */


  /* ---- PART 1B: Fallback copy method (START) ---- */
  const ta = document.createElement("textarea");
  ta.value = value;

  // Make it invisible + not jump the page
  ta.style.position = "fixed";
  ta.style.opacity = "0";

  document.body.appendChild(ta);
  ta.select();

  try {
    document.execCommand("copy");
  } catch (e) {
    console.error("execCommand copy failed:", e);
  }

  document.body.removeChild(ta);
  /* ---- PART 1B (END) ---- */
}
/* ================================== SECTION 1 (END) ===================================== */



/* ===========================================================================================
   SECTION 2: Load/save notebook to localStorage (START)
   - loadNotebook() returns an array
   - saveNotebook(items) stores last 200 items
=========================================================================================== */
function loadNotebook() {
  try {
    return JSON.parse(localStorage.getItem(notebookKey) || "[]");
  } catch (e) {
    return [];
  }
}

function saveNotebook(items) {
  // Keep only the last 200 items so storage doesn't grow forever
  localStorage.setItem(notebookKey, JSON.stringify(items.slice(-200)));
}
/* ================================== SECTION 2 (END) ===================================== */



/* ===========================================================================================
   SECTION 3: Subject name used when SAVING new notebook items (START)
   Reads #saveSubjectInput, defaults to "general"
=========================================================================================== */
function getSaveSubject() {
  const input = document.getElementById("saveSubjectInput");
  if (!input) return "general";

  const value = (input.value || "").trim();
  return value || "general";
}
/* ================================== SECTION 3 (END) ===================================== */



/* ===========================================================================================
   SECTION 4: Render the SUBJECT chips + dropdown menus (START)
   - Builds subject list from ALL items (not filtered)
   - Adds:
     - .notebook-subject-btn (filter toggle)
     - .notebook-subject-menu (opens dropdown)
     - .notebook-subject-edit (rename)
     - .notebook-subject-delete (delete subject + notes)
   NOTE: We do NOT change existing IDs/classes, we only create elements using your same class names.
=========================================================================================== */
function renderNotebookSubjects(allItems) {
  if (!notebookSubjectsEl) return;

  /* ---- PART 4A: Build unique subject list (START) ---- */
  const subjects = Array.from(
    new Set(
      allItems.map((i) => {
        const s = (i.subject || "general").trim();
        return s || "general";
      })
    )
  ).sort((a, b) => a.localeCompare(b));
  /* ---- PART 4A (END) ---- */

  // Clear current subject chips
  notebookSubjectsEl.innerHTML = "";

  // If no subjects exist, stop here
  if (!subjects.length) return;

  /* ---- PART 4B: Create UI rows for each subject (START) ---- */
  subjects.forEach((subj) => {
    // Wrapper row
    const row = document.createElement("div");
    row.className = "notebook-subject-row";

    // Inline styles (kept the same behavior)
    row.style.position = "relative";
    row.style.display = "inline-flex";
    row.style.alignItems = "center";
    row.style.gap = "4px";

    // Main subject button
    const subjBtn = document.createElement("button");
    subjBtn.type = "button";
    subjBtn.className = "pill-button notebook-subject-btn";

    // Highlight active subject filter
    if (notebookSubjectFilter === subj) {
      subjBtn.classList.add("active");
    }

    subjBtn.dataset.subject = subj;
    subjBtn.textContent = subj;

    // Menu button (3 dots)
    const menuBtn = document.createElement("button");
    menuBtn.type = "button";
    menuBtn.className = "pill-button notebook-subject-menu";
    menuBtn.dataset.subject = subj;
    menuBtn.textContent = "⋯";

    // Dropdown container (hidden by default)
    const dropdown = document.createElement("div");
    dropdown.className = "notebook-subject-dropdown";

    dropdown.style.display = "none";
    dropdown.style.position = "absolute";
    dropdown.style.right = "0";
    dropdown.style.top = "110%";
    dropdown.style.background = "#fff";
    dropdown.style.border = "1px solid var(--outline)";
    dropdown.style.borderRadius = "0px";
    dropdown.style.padding = "1em";
    dropdown.style.zIndex = "20";
    dropdown.style.whiteSpace = "nowrap";

    // Rename button
    const editBtn = document.createElement("button");
    editBtn.type = "button";
    editBtn.className = "pill-button notebook-subject-edit";
    editBtn.dataset.subject = subj;
    editBtn.textContent = "Rename subject";

    // Delete button
    const delBtn = document.createElement("button");
    delBtn.type = "button";
    delBtn.className = "pill-button notebook-subject-delete";
    delBtn.dataset.subject = subj;
    delBtn.textContent = "Delete subject & notes";

    dropdown.appendChild(editBtn);
    dropdown.appendChild(delBtn);

    /* ---- PART 4C: Menu button click (START)
       - toggles dropdown only for THIS subject row
       - stopPropagation prevents parent click handlers from interfering
    ---- */
    menuBtn.addEventListener("click", (ev) => {
      ev.stopPropagation();
      const isShowing = dropdown.style.display === "flex";
      dropdown.style.display = isShowing ? "none" : "flex";
    });
    /* ---- PART 4C (END) ---- */

    // Assemble the row
    row.appendChild(subjBtn);
    row.appendChild(menuBtn);
    row.appendChild(dropdown);

    // Add row into the subjects container
    notebookSubjectsEl.appendChild(row);
  });
  /* ---- PART 4B (END) ---- */
}
/* ================================== SECTION 4 (END) ===================================== */



/* ===========================================================================================
   SECTION 5: Render notebook items list (START)
   - Loads items from storage
   - Renders subject chips from ALL items
   - Applies type filter + subject filter
   - Builds each item card with:
     - Open button (.notebook-open-btn)
     - Copy icon (.notebook-item-copy)
     - Delete button (.notebook-item-delete)
=========================================================================================== */
function renderNotebook() {
  if (!notebookListEl) return;

  /* ---- PART 5A: Load + clear UI (START) ---- */
  const allItems = loadNotebook();
  notebookListEl.innerHTML = "";
  /* ---- PART 5A (END) ---- */

  // Always render subject chips from the full set
  renderNotebookSubjects(allItems);

  /* ---- PART 5B: Empty state (START) ---- */
  if (!allItems.length) {
    notebookListEl.innerHTML =
      '<p class="desc">Nothing saved yet. Solve something and it will appear here.</p>';
    return;
  }
  /* ---- PART 5B (END) ---- */

  /* ---- PART 5C: Apply filters (START) ---- */
  const byType =
    notebookFilter === "all"
      ? allItems
      : allItems.filter((i) => i.type === notebookFilter);

  const items =
    notebookSubjectFilter === "all"
      ? byType
      : byType.filter((i) => (i.subject || "general").trim() === notebookSubjectFilter);
  /* ---- PART 5C (END) ---- */

  /* ---- PART 5D: No results state (START) ---- */
  if (!items.length) {
    notebookListEl.innerHTML =
      '<p class="desc">No items for this filter yet.</p>';
    return;
  }
  /* ---- PART 5D (END) ---- */

  /* ---- PART 5E: Label mapping for the "Open in ..." button (START) ---- */
  const labelMap = {
    Snap: "Solve",
    Math: "Math Solver",
    Study: "Study Guide",
    Essay: "Essay Helper",
    Cards: "Flashcards",
    Flashcards: "Flashcards",
    Simplified: "Simplified answer",
    Hint: "Hint",
  };
  /* ---- PART 5E (END) ---- */

  /* ---- PART 5F: Render newest-first (START) ---- */
  items
    .slice()
    .reverse()
    .forEach((item) => {
      // Card wrapper
      const wrapper = document.createElement("div");
      wrapper.className = "notebook-item";

      // Header
      const header = document.createElement("div");
      header.className = "notebook-item-header";

      // Meta line
      const meta = document.createElement("div");
      meta.className = "notebook-meta";

      const timeStr = new Date(item.time).toLocaleString();

      // UPDATED: subject first + removed model ("smart")
      meta.textContent = `${item.subject || "general"} • ${item.type} • ${timeStr} • ${item.mode || "learn"}`;

      header.appendChild(meta);
      wrapper.appendChild(header);

      // Body (HIDDEN — keep text in storage, just don’t show it in the notebook list)
      const body = document.createElement("div");
      body.textContent = item.text || "";
      body.style.display = "none";
      wrapper.appendChild(body);

      // Footer
      const footer = document.createElement("div");
      footer.className = "notebook-item-footer";

      // Open button
      const openBtn = document.createElement("button");
      openBtn.className = "pill-button notebook-open-btn";
      openBtn.type = "button";
      openBtn.dataset.id = item.id;

      const displayType = labelMap[item.type] || item.type || "tool";
      openBtn.textContent = "Open in " + displayType;

      // Copy icon button
      const copyBtn = document.createElement("button");
      copyBtn.className = "pill-button notebook-item-copy";
      copyBtn.type = "button";
      copyBtn.dataset.id = item.id;
      copyBtn.innerHTML =
        '<span class="material-symbols-outlined">content_copy</span>';

      // Delete button
      const deleteBtn = document.createElement("button");
      deleteBtn.className = "pill-button notebook-item-delete";
      deleteBtn.type = "button";
      deleteBtn.dataset.id = item.id;
      deleteBtn.textContent = "Delete";

      footer.appendChild(openBtn);
      footer.appendChild(copyBtn);
      footer.appendChild(deleteBtn);

      wrapper.appendChild(footer);
      notebookListEl.appendChild(wrapper);
    });
  /* ---- PART 5F (END) ---- */
}
/* ================================== SECTION 5 (END) ===================================== */



/* ===========================================================================================
   SECTION 6: Open a saved notebook item back in its tool (START)
   - Looks up item by id
   - Activates the correct tab (if activateTab exists)
   - Renders text into the correct result element
   - Rebuilds flashcards if helpers exist
=========================================================================================== */
function openNotebookItemById(itemId) {
  const items = loadNotebook();
  const item = items.find((i) => i.id === itemId);
  if (!item) return;

  const text = item.text || "";

  /* ---- PART 6A: Safe render helper (START)
     - If renderAnswer exists, it uses it
     - Otherwise it falls back to plain textContent
  ---- */
  function safeRender(elementId) {
    const el = document.getElementById(elementId);
    if (!el) return;

    if (typeof renderAnswer === "function") {
      renderAnswer(el, text);
    } else {
      el.textContent = text;
    }
  }
  /* ---- PART 6A (END) ---- */

  /* ---- PART 6B: Route based on item.type (START) ---- */
  switch (item.type) {
    case "Snap":
      if (typeof activateTab === "function") {
        if (document.getElementById("solve")) {
          activateTab("solve");
        } else {
          activateTab("snap");
        }
      }
      safeRender("snapResult");
      break;

    case "Math":
      if (typeof activateTab === "function") activateTab("math");
      safeRender("mathResult");
      break;

    case "Study":
      if (typeof activateTab === "function") activateTab("study");
      safeRender("studyResult");
      break;
	  
	  case "Notes":
  if (typeof activateTab === "function") activateTab("notes");
  safeRender("notesResult");
  break;


    case "Essay":
      if (typeof activateTab === "function") activateTab("essay");
      safeRender("essayResult");
      break;

    case "Cards":
    case "Flashcards": {
      if (typeof activateTab === "function") activateTab("flashcards");

      // Put raw text back into cardsResult
      const cardsResultEl = document.getElementById("cardsResult");
      if (cardsResultEl) {
        cardsResultEl.textContent = text;
      }

      // Rebuild interactive flashcards if helpers exist
      if (typeof parseFlashcardsFromText === "function") {
        try {
          const parsed = parseFlashcardsFromText(text);
          if (parsed && parsed.length) {
            if (typeof saveFlashcards === "function") {
              saveFlashcards(parsed);
            }
            if (typeof window !== "undefined") {
              window.flashcards = parsed;
              window.currentCardIndex = 0;
            }
            if (typeof renderCurrentCard === "function") {
              renderCurrentCard();
            }
          }
        } catch (e) {
          console.error("Error rebuilding flashcards from notebook:", e);
        }
      }
      break;
    }

    case "Simplified":
    case "Hint":
    default:
      // Fallback: show in Solve/Snap
      if (typeof activateTab === "function") {
        if (document.getElementById("solve")) {
          activateTab("solve");
        } else {
          activateTab("snap");
        }
      }
      safeRender("snapResult");
      break;
  }
  /* ---- PART 6B (END) ---- */
}
/* ================================== SECTION 6 (END) ===================================== */



/* ===========================================================================================
   SECTION 7: Notebook item buttons (Open / Copy / Delete) via event delegation (START)
   - One click handler on #notebookList
   - Uses closest() to detect which button was clicked
=========================================================================================== */
if (notebookListEl) {
  notebookListEl.addEventListener("click", (e) => {
    /* ---- PART 7A: Open button (START) ---- */
    const openBtn = e.target.closest(".notebook-open-btn");
    if (openBtn) {
      const id = openBtn.dataset.id;
      if (!id) return;
      openNotebookItemById(id);
      return;
    }
    /* ---- PART 7A (END) ---- */

    /* ---- PART 7B: Copy button (START) ---- */
    const copyBtn = e.target.closest(".notebook-item-copy");
    if (copyBtn) {
      const id = copyBtn.dataset.id;
      if (!id) return;

      const items = loadNotebook();
      const item = items.find((i) => i.id === id);
      if (!item) return;

      copyTextToClipboard(item.text || "");
      return;
    }
    /* ---- PART 7B (END) ---- */

    /* ---- PART 7C: Delete button (START) ---- */
    const deleteBtn = e.target.closest(".notebook-item-delete");
    if (deleteBtn) {
      const id = deleteBtn.dataset.id;
      if (!id) return;

      const items = loadNotebook();
      const idx = items.findIndex((i) => i.id === id);
      if (idx === -1) return;

      const ok = confirm("Delete this saved item? You can undo once.");
      if (!ok) return;

      notebookLastSnapshot = items.slice();
      items.splice(idx, 1);

      saveNotebook(items);
      renderNotebook();
    }
    /* ---- PART 7C (END) ---- */
  });
}
/* ================================== SECTION 7 (END) ===================================== */



/* ===========================================================================================
   SECTION 8: Subject chip actions via delegation (START)
   Handles:
   - .notebook-subject-btn (filter)
   - .notebook-subject-edit (rename)
   - .notebook-subject-delete (delete subject + notes)
   NOTE: the menu open/close is handled directly in renderNotebookSubjects()
=========================================================================================== */
if (notebookSubjectsEl) {
  notebookSubjectsEl.addEventListener("click", (e) => {
    /* ---- PART 8A: Subject filter toggle (START) ---- */
    const subjectBtn = e.target.closest(".notebook-subject-btn");
    if (subjectBtn) {
      const subj = subjectBtn.dataset.subject;
      if (!subj) return;

      notebookSubjectFilter = notebookSubjectFilter === subj ? "all" : subj;
      renderNotebook();
      return;
    }
    /* ---- PART 8A (END) ---- */

    /* ---- PART 8B: Rename subject (START) ---- */
    const editBtn = e.target.closest(".notebook-subject-edit");
    if (editBtn) {
      const oldSubj = editBtn.dataset.subject;
      if (!oldSubj) return;

      const newNameRaw = prompt("Rename subject:", oldSubj);
      if (newNameRaw === null) return;

      const newName = newNameRaw.trim();
      if (!newName || newName === oldSubj) return;

      const ok = confirm(`Rename subject "${oldSubj}" to "${newName}"?`);
      if (!ok) return;

      const items = loadNotebook();
      notebookLastSnapshot = items.slice();

      const updated = items.map((it) => {
        const s = (it.subject || "general").trim();
        if (s === oldSubj) {
          return { ...it, subject: newName };
        }
        return it;
      });

      if (notebookSubjectFilter === oldSubj) {
        notebookSubjectFilter = newName;
      }

      saveNotebook(updated);
      renderNotebook();
      return;
    }
    /* ---- PART 8B (END) ---- */

    /* ---- PART 8C: Delete subject + its notes (START) ---- */
    const delBtn = e.target.closest(".notebook-subject-delete");
    if (delBtn) {
      const subj = delBtn.dataset.subject;
      if (!subj) return;

      const ok = confirm(
        `Delete subject "${subj}" and all its saved work? You can undo once.`
      );
      if (!ok) return;

      const items = loadNotebook();
      notebookLastSnapshot = items.slice();

      const remaining = items.filter(
        (it) => (it.subject || "general").trim() !== subj
      );

      if (notebookSubjectFilter === subj) {
        notebookSubjectFilter = "all";
      }

      saveNotebook(remaining);
      renderNotebook();
    }
    /* ---- PART 8C (END) ---- */
  });
}
/* ================================== SECTION 8 (END) ===================================== */



/* ===========================================================================================
   SECTION 9: Notebook FILTER buttons (All, Snap, Math, etc.) (START)
   - .notebook-filter buttons must have data-filter="..."
   - Adds/removes "active" class (class name unchanged)
=========================================================================================== */
notebookFilterButtons.forEach((btn) => {
  btn.addEventListener("click", () => {
    notebookFilterButtons.forEach((b) => b.classList.remove("active"));
    btn.classList.add("active");

    notebookFilter = btn.dataset.filter || "all";
    renderNotebook();
  });
});
/* ================================== SECTION 9 (END) ===================================== */



/* ===========================================================================================
   SECTION 10: Add an item to the notebook (START)
   - Called by other tools when they generate an answer
   - Keeps a snapshot for undo
=========================================================================================== */
function addNotebookItem(type, text) {
  if (!text || !text.trim()) return;

  const items = loadNotebook();
  notebookLastSnapshot = items.slice(); // allow undo of this insert

  items.push({
    id: Date.now() + Math.random().toString(16).slice(2),
    type, // "Snap", "Math", "Study", etc.
    text: text.trim(),
    time: Date.now(),
    subject: getSaveSubject(),
    model: getModelChoice(),
    mode: window.__cheatMode ? "cheat" : "learn",
    pinned: false,
  });

  saveNotebook(items);
  renderNotebook();
}
/* ================================== SECTION 10 (END) ==================================== */



/* ===========================================================================================
   SECTION 11: Clear + Undo buttons (START)
   - #clearNotebookBtn clears everything (with confirm)
   - #undoNotebookBtn restores the last snapshot (one-level undo)
=========================================================================================== */
const clearNotebookBtn = document.getElementById("clearNotebookBtn");
if (clearNotebookBtn) {
  clearNotebookBtn.addEventListener("click", () => {
    const items = loadNotebook();

    if (!items.length) {
      alert("Notebook is already empty.");
      return;
    }

    const ok = confirm("Clear all saved notebook items? You can undo this once.");
    if (!ok) return;

    notebookLastSnapshot = items.slice();
    saveNotebook([]);
    renderNotebook();
  });
}

const undoNotebookBtn = document.getElementById("undoNotebookBtn");
if (undoNotebookBtn) {
  undoNotebookBtn.addEventListener("click", () => {
    if (!notebookLastSnapshot) {
      alert("Nothing to undo yet.");
      return;
    }

    saveNotebook(notebookLastSnapshot);
    notebookLastSnapshot = null;
    renderNotebook();
  });
}
/* ================================== SECTION 11 (END) ==================================== */



/* ===========================================================================================
   SECTION 12: Initial render (START)
=========================================================================================== */
renderNotebook();
/* ================================== SECTION 12 (END) ==================================== */



/* ===========================================================================================
   SECTION 13: Copy buttons for textareas (START)
   - Wires #copySnapTextBtn to copy #snapText
   - Auto-inserts copy buttons next to other visible <textarea> elements
   IMPORTANT:
   - Keeps your exclusions: snapText and extraInstructions
=========================================================================================== */

/* --- PART 13A: Run when DOM is ready (START)
   This version is safer than only DOMContentLoaded:
   - If the script loads after DOMContentLoaded already fired, it still runs.
*/
function runWhenReady(fn) {
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", fn);
  } else {
    fn();
  }
}
/* --- PART 13A (END) --- */

runWhenReady(() => {
  /* ---- PART 13B: Snap textarea copy button (START) ---- */
  const snapTa = document.getElementById("snapText");
  const copySnapBtn = document.getElementById("copySnapTextBtn");

  if (snapTa && copySnapBtn) {
    copySnapBtn.addEventListener("click", () => {
      copyTextToClipboard(snapTa.value || "");
    });
  }
  /* ---- PART 13B (END) ---- */


  /* ---- PART 13C: Auto-add copy buttons to other textareas (START) ---- */
  const textareas = document.querySelectorAll("textarea");

  textareas.forEach((ta) => {
    // Exclusions (kept exactly)
    if (ta.id === "snapText") return;
    if (ta.id === "extraInstructions") return;

    // Skip hidden textareas
    if (ta.style.display === "none") return;

    // Must have a parent to insert a button
    if (!ta.parentNode) return;

    const btn = document.createElement("button");
    btn.type = "button";
    btn.className = "icon-copy-btn";
    btn.setAttribute("aria-label", "Copy text");
    btn.innerHTML =
      '<span class="material-symbols-outlined">content_copy</span>';

    ta.parentNode.insertBefore(btn, ta.nextSibling);

    btn.addEventListener("click", () => {
      copyTextToClipboard(ta.value || "");
    });
  });
  /* ---- PART 13C (END) ---- */
});
/* ================================== SECTION 13 (END) ==================================== */
</script>



<!-- BLOCK 3: Answer sanitizing, AI backend call, and all task helpers ----------------------
--------------------------------------------------------------------------------------=----
===========================================================================================
===========================================================================================
------------------------------------------------------------------------------------------->

<script>
/* ===========================================================================================
   SECTION 0: Answer sanitizing (START)
   Goal:
   - Take raw AI text and remove markdown/latex-ish junk
   - Normalize the output into clean readable text
=========================================================================================== */
function sanitizeAnswerText(raw) {
  if (!raw) return "";

  let text = String(raw);

  /* ---- PART 0A: Remove common markdown formatting (START) ---- */
  text = text.replace(/^\s*#{1,6}\s+.*$/gm, "");
  text = text.replace(/^\s*[-*_]{3,}\s*$/gm, "");
  text = text.replace(/---/g, "");
  text = text.replace(/```/g, "");
  /* ---- PART 0A (END) ---- */

  /* ---- PART 0B: Convert common LaTeX-ish patterns into plain text (START) ---- */
  text = text.replace(/\\frac\{([^}]+)\}\{([^}]+)\}/g, "$1/$2");
  text = text.replace(/\\sqrt\{([^}]+)\}/g, "√($1)");
  text = text.replace(/√\(([^()]+)\)/g, "√$1");
  text = text.replace(/\\boxed\{([^}]+)\}/g, "$1");
  /* ---- PART 0B (END) ---- */

  /* ---- PART 0C: Remove LaTeX math wrappers like \( \) and \[ \] and $ $ (START) ---- */
  text = text.replace(/\\\(|\\\)/g, "");
  text = text.replace(/\\\[|\\\]/g, "");
  text = text.replace(/\$\$/g, "");
  text = text.replace(/\$(.*?)\$/g, "$1");
  /* ---- PART 0C (END) ---- */

  /* ---- PART 0D: Replace LaTeX operators with symbols (START) ---- */
  text = text.replace(/\\times/g, "×");
  text = text.replace(/\\cdot/g, "·");
  /* ---- PART 0D (END) ---- */

  /* ---- PART 0E: Remove bullet markers when they aren't numeric lists (START) ---- */
  text = text.replace(/^\s*-\s+(?!\d)/gm, "");
  text = text.replace(/^\s*\*\s+(?!\d)/gm, "");
  /* ---- PART 0E (END) ---- */

  /* ---- PART 0F: Remove specific filler lines (START) ---- */
  text = text.replace(/^Lets solve.*$/gmi, "");
  /* ---- PART 0F (END) ---- */

  /* ---- PART 0G: Strip leftover special characters + normalize spacing (START) ---- */
  text = text.replace(/[\\`#*_$>]/g, "");
  text = text.replace(/\r\n/g, "\n");
  text = text.replace(/\n{3,}/g, "\n\n");
  /* ---- PART 0G (END) ---- */

  /* ---- PART 0H: Fix "Final answer:" line if it's empty (START) ---- */
  const finalLineMatch = text.match(/Final answer:\s*$/m);
  if (finalLineMatch) {
    const numbers = text.match(/-?\d+(\.\d+)?/g);
    if (numbers && numbers.length > 0) {
      const lastNum = numbers[numbers.length - 1];
      text = text.replace(/Final answer:\s*$/m, "Final answer: " + lastNum);
    }
  }
  /* ---- PART 0H (END) ---- */

  return text.trim();
}
/* ================================== SECTION 0 (END) ===================================== */



/* ===========================================================================================
   SECTION 1: Inject styles for tool outputs (START)
=========================================================================================== */
(function ensureToolOutputStyles() {
  if (document.getElementById("tool-output-styles")) return;

  const style = document.createElement("style");
  style.id = "tool-output-styles";

  style.textContent = `
    .tool-output {
      position: relative;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      font-size: 0.95rem;
      line-height: 1.6;
      color: #111827;
      background: #f9fafb;
      border-radius: 0.75rem;
      border: 1px solid #e5e7eb;
      padding: 0.85rem 1rem 0.9rem 1rem;
      margin-top: 0.75rem;
      overflow-wrap: anywhere;
    }
    .tool-output-header {
      display: flex;
      justify-content: flex-end;
      align-items: center;
      margin-bottom: 0.25rem;
    }
    .tool-output-body {
      white-space: pre-wrap;
    }
    .tool-output-copy {
      border-radius: 6px;
      font-size: 0.75rem;
      padding: 0.1rem 0.6rem;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
    }
    .tool-output-copy:hover {
      background: var(--btn-bg-active);
      color: var(--btn-fg-active);
    }
    .tool-output-copy-label { font-weight: 500; }
    .section-heading {
      display: block;
      font-weight: 700;
      color: #000;
      margin-top: 0.9rem;
      margin-bottom: 0.1rem;
      font-size: 1rem;
    }
    .step-line {
      display: block;
      font-weight: 600;
      color: #111827;
      margin-top: 0.4rem;
    }
    .answer-label { font-weight: 700; color: #000; }
    .answer-value { font-weight: 500; color: #111827; }
    .hint-label {
      display: inline-block;
      margin-top: 0.75rem;
      font-weight: 700;
      color: #000;
    }
  `;

  document.head.appendChild(style);
})();
/* ================================== SECTION 1 (END) ===================================== */



/* ===========================================================================================
   SECTION 2: Render tool output with formatting + copy button (START)
=========================================================================================== */
function renderAnswer(preEl, text) {
  if (!preEl) return;

  const plain = String(text || "");
  preEl.dataset.plainText = plain;

  preEl.classList.add("tool-output");

  const escaped = plain
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;");

  const lines = escaped.split("\n");

  const htmlLines = lines.map((line) => {
    const trimmed = line.trim();

    const finalMatch = line.match(/^(Final answer:\s*)(.*)$/i);
    if (finalMatch) {
      const label = finalMatch[1];
      const value = finalMatch[2] || "";
      return `<span class="answer-label">${label}</span><span class="answer-value"> ${value}</span>`;
    }

    if (/^Step\s+\d+/i.test(trimmed)) {
      return `<span class="step-line">${line}</span>`;
    }

    if (/^(Summary|Answer Key|Multiple Choice|Short Answer|True\/False)\s*:/i.test(trimmed)) {
      return `<span class="section-heading">${line}</span>`;
    }

    if (/^Hint:\s*$/i.test(trimmed)) {
      return `<span class="hint-label">Hint</span>`;
    }

    return line;
  });

  const contentHtml = htmlLines.join("\n");
  const copyTarget = preEl.id ? ` data-copy-target="${preEl.id}"` : "";

  preEl.innerHTML = `
    <div class="tool-output-header">
      <button type="button" class="tool-output-copy"${copyTarget}>
        <span class="tool-output-copy-label">Copy</span>
      </button>
    </div>
    <div class="tool-output-body" contenteditable="true" spellcheck="true">${contentHtml}</div>
  `;
}
/* ================================== SECTION 2 (END) ===================================== */



/* ===========================================================================================
   SECTION 3: Global click handler for tool-output copy buttons (FIXED)
=========================================================================================== */
document.addEventListener("click", (e) => {
  const btn = e.target.closest(".tool-output-copy");
  if (!btn) return;

  let container = null;

  const targetId = btn.dataset.copyTarget;
  if (targetId) container = document.getElementById(targetId);
  if (!container) container = btn.closest(".tool-output");
  if (!container) return;

  let textToCopy = "";

  if (container.dataset && container.dataset.plainText && container.dataset.plainText.trim()) {
    textToCopy = container.dataset.plainText;
  } else {
    const body = container.querySelector(".tool-output-body");
    textToCopy = body ? body.innerText : "";
  }

  textToCopy = String(textToCopy || "").trim();
  if (!textToCopy) return;

  copyTextToClipboard(textToCopy);

  const label = btn.querySelector(".tool-output-copy-label");
  if (label) {
    const old = label.textContent;
    label.textContent = "Copied!";
    setTimeout(() => { label.textContent = old; }, 1200);
  }
});
/* ================================== SECTION 3 (END) ===================================== */



/* ===========================================================================================
   OUTPUT PDF (only) - MOBILE FIX
   ✅ FIX:
   - Mobile blocks iframe.print() (especially iPhone Safari / in-app browsers)
   - Open a real new tab, show a big "Print / Save PDF" button, user taps it
   - Keeps the exact output HTML (formatting/highlighting) when available
=========================================================================================== */
(function setupPdfOnly() {
  function getToolOutputBody(outputEl) {
    if (!outputEl) return null;
    return outputEl.querySelector(".tool-output-body");
  }

  function escapeHtml(s) {
    return String(s || "")
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;");
  }

  function getAllById(targetId) {
    const safe = String(targetId || "").replace(/"/g, '\\"');
    return Array.from(document.querySelectorAll('[id="' + safe + '"]'));
  }

  function isVisible(el) {
    if (!el) return false;

    const style = window.getComputedStyle(el);
    if (style.display === "none" || style.visibility === "hidden" || style.opacity === "0") return false;

    const rect = el.getBoundingClientRect();
    if (rect.width === 0 && rect.height === 0) return false;

    const tab = el.closest(".tab-content");
    if (tab && !tab.classList.contains("active")) return false;

    return true;
  }

  function pickBestOutputEl(targetId) {
    const candidates = getAllById(targetId);
    const visible = candidates.find(isVisible);
    if (visible) return visible;
    return candidates[0] || null;
  }

  function printOutputToPdf(outputEl, titleText) {
    if (!outputEl) return;

    const bodyEl = getToolOutputBody(outputEl);

    const fallbackText =
      (outputEl.dataset && outputEl.dataset.plainText) ||
      outputEl.textContent ||
      "";

    const hasHtml = bodyEl && bodyEl.innerHTML && bodyEl.innerHTML.trim();
    const hasText = String(fallbackText || "").trim().length > 0;

    if (!hasHtml && !hasText) {
      alert("Nothing to export yet.");
      return;
    }

    const toolStylesEl = document.getElementById("tool-output-styles");
    const toolCss = toolStylesEl ? toolStylesEl.textContent : "";

    const headBits = Array.from(document.querySelectorAll('link[rel="stylesheet"], style'))
      .map((n) => n.outerHTML)
      .join("\n");

    const safeDocTitle = String(titleText || "Export").replace(/</g, "&lt;");

    const contentBlock = hasHtml
      ? `<div class="tool-output"><div class="tool-output-body">${bodyEl.innerHTML}</div></div>`
      : `<div class="tool-output"><pre class="tool-output-body" style="margin:0; white-space:pre-wrap;">${escapeHtml(fallbackText)}</pre></div>`;

    const printableHtml = `
<!doctype html>
<html>
<head>
<meta charset="utf-8">
<base href="${location.href}">
<title>${safeDocTitle}</title>
${headBits}
<style>
  ${toolCss}

  /* PDF ONLY: remove the box/border/background */
  .tool-output {
    border: none !important;
    background: transparent !important;
    padding: 0 !important;
    box-shadow: none !important;
  }

  body { padding: 0; margin: 0; }
  @page { margin: 14mm; }
  .tool-output { margin: 0; }
  .tool-output-body { white-space: pre-wrap; }

  /* Mobile-friendly print button bar */
  .printbar {
    position: sticky;
    top: 0;
    background: #fff;
    padding: 12px;
    border-bottom: 1px solid #e5e7eb;
    display: flex;
    gap: 10px;
    align-items: center;
    justify-content: flex-end;
    z-index: 9999;
  }
  .printbtn {
    font: inherit;
    border: 1px solid #e5e7eb;
    background: #f3f4f6;
    border-radius: 10px;
    padding: 10px 14px;
    cursor: pointer;
  }
</style>
</head>
<body>
  <div class="printbar">
    <button class="printbtn" onclick="window.print()">Print / Save PDF</button>
  </div>
  ${contentBlock}
</body>
</html>`;

    // ✅ Mobile-safe: open a real new tab/window (must be called inside the click)
    const w = window.open("", "_blank");
    if (!w) {
      alert("Popup blocked. Allow popups, then try again.");
      return;
    }

    w.document.open();
    w.document.write(printableHtml);
    w.document.close();
  }

  document.addEventListener("click", (e) => {
    const pdfBtn = e.target.closest(".output-pdf-download");
    if (pdfBtn) {
      const targetId = pdfBtn.dataset.target;
      if (!targetId) return;

      const outputEl = pickBestOutputEl(targetId);
      if (!outputEl) return;

      printOutputToPdf(outputEl, targetId || "Export");
      return;
    }
  }, true);
})();



/* ===========================================================================================
   SECTION 3D: Keep copy text synced with user edits
=========================================================================================== */
document.addEventListener("input", (e) => {
  const body = e.target.closest(".tool-output-body");
  if (!body) return;

  const container = body.closest(".tool-output");
  if (!container) return;

  container.dataset.plainText = body.innerText || "";
});
/* ================================ SECTION 3D (END) ===================================== */



/* ===========================================================================================
   SECTION 4: Flashcard-side cleaning helper (START)
=========================================================================================== */
function cleanSide(text) {
  return String(text || "")
    .trim()
    .replace(/^[QA]\s*:\s*/i, "")
    .replace(/^:\s*/, "")
    .replace(/\s*:\s*$/, "");
}
/* ================================== SECTION 4 (END) ===================================== */



/* ===========================================================================================
   SECTION 5: AI ENGINE (BACKEND HOOK POINT) (START)
=========================================================================================== */
async function callAI({ prompt, task }) {
  const modelChoice = getModelChoice();
  const subject = getSubject();
  const mode = window.__cheatMode ? "cheat" : "learn";

  try {
    const res = await fetch("/api/solve", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        prompt:
          `Mode: ${mode}\n` +
          `Subject: ${subject}\n` +
          `Tool: ${task}\n\n` +
          prompt,
        task,
        model: modelChoice,
      }),
    });

    if (!res.ok) {
      throw new Error("Network error (" + res.status + ")");
    }

    const data = await res.json();
    if (data.error) throw new Error(data.error);

    return data.text || "[Empty response]";
  } catch (err) {
    console.error(err);
    return "⚠️ Error talking to AI:\n" + err.message;
  }
}
/* ================================== SECTION 5 (END) ===================================== */



/* ===========================================================================================
   SECTION 6: TASK HELPERS (START)
=========================================================================================== */

/* ---- PART 6A: Math Solver (START) ---- */
async function runMathSolver(text) {
  const cheat = window.__cheatMode;

  const prompt = cheat
    ? "Solve this math problem and give ONLY the final numeric/algebraic answer. " +
      "If there are multiple parts, label each answer clearly (a), b), c), etc.).\n\nProblem:\n" +
      text.trim()
    : "You are a step-by-step math tutor for a middle/high school student.\n" +
      "Solve the problem clearly. Show each step, and END with a line exactly like:\n" +
      "`Final answer: <number>`\n\n" +
      "Problem:\n" +
      text.trim();

  return callAI({ prompt, task: "math" });
}
/* ---- PART 6A (END) ---- */


/* ---- PART 6B: Study Guide (START) ---- */
async function runStudyGuide(text) {
  const prompt =
    "Turn the following notes or textbook text into a study guide for a student.\n" +
    "Output:\n- Bullet point main ideas\n- Key definitions\n- Short summary at the end.\n\n" +
    text.trim();

  return callAI({ prompt, task: "study_guide" });
}
/* ---- PART 6B (END) ---- */


/* ---- PART 6C: Essay Helper (START) ---- */
async function runEssayHelper(text) {
  const cheat = window.__cheatMode;

  const prompt = cheat
    ? "Write a strong, polished essay based on this text or prompt. Just give the finished essay.\n\nInput:\n" +
      text.trim()
    : "You are an essay helper for a middle/high school student.\n" +
      "If the text looks like a draft, improve clarity, grammar, and structure but keep their voice.\n" +
      "If it is a prompt, generate a well-structured answer.\n\n" +
      "Input:\n" +
      text.trim();

  return callAI({ prompt, task: "essay" });
}
/* ---- PART 6C (END) ---- */


/* ---- PART 6D: Flashcards (START) ---- */
async function runFlashcards(text) {
  const prompt =
    "Create useful flashcards from this content for a student.\n" +
    "Output format strictly like:\n" +
    "Q: ...\nA: ...\n\n" +
    "Use many short cards.\n\n" +
    "Content:\n" +
    text.trim();

  return callAI({ prompt, task: "flashcards" });
}
/* ---- PART 6D (END) ---- */


/* ---- PART 6E: Simplify (START) ---- */
async function runSimplify(text) {
  const prompt =
    "Explain the following answer in much simpler language for a middle or high school student. Keep key ideas, but shorten and simplify:\n\n" +
    text.trim();

  return callAI({ prompt, task: "simplify" });
}
/* ---- PART 6E (END) ---- */


/* ---- PART 6F: Hint (START) ---- */
async function runHint(question, existingAnswer) {
  const prompt =
    "Give a helpful hint (not the full solution) for this problem for a student.\n" +
    "Keep it short and focused.\n\nProblem:\n" +
    question.trim() +
    "\n\nExisting answer (if any):\n" +
    (existingAnswer || "");

  return callAI({ prompt, task: "hint" });
}
/* ---- PART 6F (END) ---- */


/* ---- PART 6G: Snap Solve (START) ---- */
async function runSnapSolve(text) {
  const cheat = window.__cheatMode;

  const prompt = cheat
    ? "A student scanned this homework text. Give the direct final answers as clearly as possible. " +
      "If there are multiple questions, number each answer so it matches. Minimal explanation.\n\n" +
      text.trim()
    : "A student scanned this homework text. Solve or explain it step-by-step in a clear way.\n\n" +
      text.trim();

  return callAI({ prompt, task: "snap" });
}
/* ---- PART 6G (END) ---- */

/* ================================== SECTION 6 (END) ===================================== */
</script>







<!-- BLOCK 4: Image resize helper and OCR call to backend -----------------------------------
--------------------------------------------------------------------------------------=----
===========================================================================================
===========================================================================================
------------------------------------------------------------------------------------------->

<script>
/* ===========================================================================================
   SECTION 0: Remember the last OCR image (START)
   Goal:
   - Store the most recent OCR image as a Data URL string
   - Allows "refresh OCR" without re-uploading the file
=========================================================================================== */
let lastOcrImageDataUrl = null;
/* ================================== SECTION 0 (END) ===================================== */



/* ===========================================================================================
   SECTION 1: Resize image before sending to backend (START)
   Why:
   - Phones often upload HUGE images
   - Resizing makes upload faster + OCR faster
   Input:
   - file: a File object (from <input type="file">)
   - maxWidth: maximum width allowed (default 1200px)
   - quality: JPEG quality 0..1 (default 0.8)
   Output:
   - Promise that resolves to a JPEG data URL: "data:image/jpeg;base64,..."
=========================================================================================== */
function resizeImageToDataUrl(file, maxWidth = 1200, quality = 0.8) {
  return new Promise((resolve, reject) => {
    /* ---- PART 1A: Read the file into memory (FileReader) (START) ---- */
    const reader = new FileReader();

    reader.onload = (e) => {
      /* ---- PART 1B: Load that file data into an Image object (START) ---- */
      const img = new Image();

      img.onload = () => {
        /* ---- PART 1C: Compute resized dimensions (START) ---- */
        // Scale down only if the image is wider than maxWidth
        const scale = Math.min(1, maxWidth / img.width);

        const w = img.width * scale;
        const h = img.height * scale;
        /* ---- PART 1C (END) ---- */


        /* ---- PART 1D: Draw resized image onto a canvas (START) ---- */
        const canvas = document.createElement("canvas");
        canvas.width = w;
        canvas.height = h;

        const ctx = canvas.getContext("2d");
        // Safety: if canvas context fails for some reason
        if (!ctx) {
          reject(new Error("Canvas 2D context not available."));
          return;
        }

        ctx.drawImage(img, 0, 0, w, h);
        /* ---- PART 1D (END) ---- */


        /* ---- PART 1E: Export canvas as JPEG data URL (START) ---- */
        try {
          const dataUrl = canvas.toDataURL("image/jpeg", quality);
          resolve(dataUrl);
        } catch (err) {
          reject(err);
        }
        /* ---- PART 1E (END) ---- */
      };

      // If the image fails to load, reject
      img.onerror = reject;

      // Use the FileReader result as the image source
      img.src = e.target.result;
      /* ---- PART 1B (END) ---- */
    };

    // If file read fails, reject
    reader.onerror = reject;

    // Start reading file as a base64 data URL
    reader.readAsDataURL(file);
    /* ---- PART 1A (END) ---- */
  });
}
/* ================================== SECTION 1 (END) ===================================== */



/* ===========================================================================================
   SECTION 2: OCR call to backend (START)
   Name note:
   - Your function is called runFakeOCR, but it is doing REAL OCR via /api/ocr.
   Behavior:
   - If "file" is provided: resize it, store it in lastOcrImageDataUrl
   - If no file: reuse lastOcrImageDataUrl (refresh)
   - Sends Mode/Subject/Model context (like your other tools)
   - Returns plain extracted text or a user-friendly error string
=========================================================================================== */
async function runFakeOCR(file) {
  /* ---- PART 2A: Decide which image data to use (START) ---- */
  let imageData;

  if (file) {
    // New image uploaded: resize it and remember it
    imageData = await resizeImageToDataUrl(file, 1200, 0.8);
    lastOcrImageDataUrl = imageData;
  } else if (lastOcrImageDataUrl) {
    // No new file: reuse the last stored image
    imageData = lastOcrImageDataUrl;
  } else {
    // Nothing to OCR yet
    return "⚠️ No image available for OCR yet.";
  }
  /* ---- PART 2A (END) ---- */


  /* ---- PART 2B: Gather context used by your app (START) ---- */
  const subject = getSubject();
  const modelChoice = getModelChoice();
  const mode = window.__cheatMode ? "cheat" : "learn";
  /* ---- PART 2B (END) ---- */


  /* ---- PART 2C: Build request body for /api/ocr (START) ---- */
  const body = {
    prompt:
      `Mode: ${mode}\n` +
      `Subject: ${subject}\n` +
      `Tool: ocr\n\n` +
      "Extract the text from this homework image and return plain text only.",
    task: "ocr",
    model: modelChoice,
    imageData: imageData,
  };
  /* ---- PART 2C (END) ---- */


  /* ---- PART 2D: Send request + handle response (START) ---- */
  try {
    const res = await fetch("/api/ocr", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body),
    });

    if (!res.ok) {
      throw new Error("Network error (" + res.status + ")");
    }

    const data = await res.json();
    if (data.error) throw new Error(data.error);

    return data.text || "";
  } catch (err) {
    console.error("OCR error:", err);
    return "⚠️ Error during OCR: " + err.message;
  }
  /* ---- PART 2D (END) ---- */
}
/* ================================== SECTION 2 (END) ===================================== */
</script>



<!-- BLOCK 5: Tabs / sidenav navigation (with Back + Forward) -------------------------------
--------------------------------------------------------------------------------------=----
===========================================================================================
===========================================================================================
------------------------------------------------------------------------------------------->

<script>
/* ===========================================================================================
   SECTION 0: Grab tab/sidenav elements + state (START)
   - .nav-btn buttons must have data-target="tabId"
   - .tab-content sections must have id="tabId"
   - LAST_TAB_KEY remembers the last opened tab across refresh
=========================================================================================== */
const navBtns = document.querySelectorAll(".nav-btn");
const tabs = document.querySelectorAll(".tab-content");
const LAST_TAB_KEY = "studyai-last-tab";

/* ---- PART 0A: History stacks + navigation flags (START) ----
   - tabHistory: back stack (where you've been)
   - forwardHistory: forward stack (where you can go forward)
   - currentTab: the tab currently visible
   - isNavigatingBack / isNavigatingForward:
     used so activateTab() knows whether to add to history or not
*/
let tabHistory = [];        // back stack
let forwardHistory = [];    // forward stack
let currentTab = null;

let isNavigatingBack = false;
let isNavigatingForward = false;
/* ---- PART 0A (END) ---- */

const backTabButton = document.getElementById("backTabButton");
const forwardTabButton = document.getElementById("forwardTabButton");
/* ================================== SECTION 0 (END) ===================================== */



/* ===========================================================================================
   SECTION 1: Update Back/Forward button disabled state (START)
   Goal:
   - If no back history: disable Back button
   - If no forward history: disable Forward button
   - Also toggles the CSS class "tab-nav-btn-disabled"
=========================================================================================== */
function updateBackButtonState() {
  /* ---- PART 1A: Back button (START) ---- */
  if (backTabButton) {
    if (tabHistory.length === 0) {
      backTabButton.disabled = true;
      backTabButton.classList.add("tab-nav-btn-disabled");
    } else {
      backTabButton.disabled = false;
      backTabButton.classList.remove("tab-nav-btn-disabled");
    }
  }
  /* ---- PART 1A (END) ---- */

  /* ---- PART 1B: Forward button (START) ---- */
  if (forwardTabButton) {
    if (forwardHistory.length === 0) {
      forwardTabButton.disabled = true;
      forwardTabButton.classList.add("tab-nav-btn-disabled");
    } else {
      forwardTabButton.disabled = false;
      forwardTabButton.classList.remove("tab-nav-btn-disabled");
    }
  }
  /* ---- PART 1B (END) ---- */
}
/* ================================== SECTION 1 (END) ===================================== */



/* ===========================================================================================
   SECTION 2: Activate a tab (START)
   What it does:
   1) Turns "active" class on the correct nav button
   2) Turns "active" class on the correct tab content panel
   3) Updates history stacks (only for "normal" navigation)
   4) Saves last tab to localStorage
=========================================================================================== */
function activateTab(targetId) {
  let found = false;

  /* ---- PART 2A: Highlight the correct nav button (START) ---- */
  navBtns.forEach((b) => {
    const isTarget = b.dataset.target === targetId;
    if (isTarget) found = true;
    b.classList.toggle("active", isTarget);
  });
  /* ---- PART 2A (END) ---- */

  /* ---- PART 2B: Show the correct tab content (START) ---- */
  tabs.forEach((t) => {
    t.classList.toggle("active", t.id === targetId);
  });
  /* ---- PART 2B (END) ---- */

  /* ---- PART 2C: Fallback if tab not found (START) ----
     If targetId doesn't match any .nav-btn data-target, we fallback to "solve".
     NOTE: this prevents adding fake/unreachable tabs into history.
  */
  if (!found && targetId !== "solve") {
    activateTab("solve");
    return;
  }
  /* ---- PART 2C (END) ---- */

  /* ---- PART 2D: Update history stacks (START) ----
     We only push to history on normal clicks (NOT during back/forward).
  */
  const isNormalNavigation = !isNavigatingBack && !isNavigatingForward;

  if (isNormalNavigation && currentTab && currentTab !== targetId) {
    // Add current tab to BACK history
    tabHistory.push(currentTab);

    // New navigation clears the forward history (like a browser)
    forwardHistory = [];

    // Keep history from growing forever
    if (tabHistory.length > 25) {
      tabHistory.shift(); // remove oldest
    }
  }
  /* ---- PART 2D (END) ---- */

  /* ---- PART 2E: Save + refresh UI state (START) ---- */
  currentTab = targetId;
  localStorage.setItem(LAST_TAB_KEY, targetId);
  updateBackButtonState();
  /* ---- PART 2E (END) ---- */
}
/* ================================== SECTION 2 (END) ===================================== */



/* ===========================================================================================
   SECTION 3: Sidenav button clicks (START)
   - When a .nav-btn is clicked:
     - activateTab() to switch to its target
     - close the drawer on mobile (if your drawer helpers exist)
=========================================================================================== */
navBtns.forEach((btn) => {
  btn.addEventListener("click", () => {
    /* ---- PART 3A: Read the target tab id from data-target (START) ---- */
    const target = btn.dataset.target;
    activateTab(target);
    /* ---- PART 3A (END) ---- */

    /* ---- PART 3B: Close drawer on mobile (START) ---- */
    // Only runs if isDesktop() and closeDrawer() exist in other script blocks.
    if (
      typeof isDesktop === "function" &&
      typeof closeDrawer === "function" &&
      !isDesktop()
    ) {
      closeDrawer();
    }
    /* ---- PART 3B (END) ---- */
  });
});
/* ================================== SECTION 3 (END) ===================================== */



/* ===========================================================================================
   SECTION 4: Back button behavior (START)
   What happens when Back is clicked:
   - Pop a tab off tabHistory
   - Push currentTab into forwardHistory
   - Navigate to the popped tab WITHOUT creating a new history entry
=========================================================================================== */
if (backTabButton) {
  backTabButton.addEventListener("click", () => {
    /* ---- PART 4A: If nothing to go back to, stop (START) ---- */
    if (!tabHistory.length) return;
    /* ---- PART 4A (END) ---- */

    /* ---- PART 4B: Get previous tab from back stack (START) ---- */
    const prev = tabHistory.pop();
    if (!prev) {
      updateBackButtonState();
      return;
    }
    /* ---- PART 4B (END) ---- */

    /* ---- PART 4C: Push current tab into forward stack (START) ---- */
    if (currentTab) {
      forwardHistory.push(currentTab);
      if (forwardHistory.length > 25) {
        forwardHistory.shift();
      }
    }
    /* ---- PART 4C (END) ---- */

    /* ---- PART 4D: Navigate without writing new history (START) ---- */
    isNavigatingBack = true;
    activateTab(prev);
    isNavigatingBack = false;
    updateBackButtonState();
    /* ---- PART 4D (END) ---- */
  });
}
/* ================================== SECTION 4 (END) ===================================== */



/* ===========================================================================================
   SECTION 5: Forward button behavior (START)
   What happens when Forward is clicked:
   - Pop a tab off forwardHistory
   - Push currentTab into tabHistory
   - Navigate to popped tab WITHOUT creating a new history entry
=========================================================================================== */
if (forwardTabButton) {
  forwardTabButton.addEventListener("click", () => {
    /* ---- PART 5A: If nothing to go forward to, stop (START) ---- */
    if (!forwardHistory.length) return;
    /* ---- PART 5A (END) ---- */

    /* ---- PART 5B: Get next tab from forward stack (START) ---- */
    const next = forwardHistory.pop();
    if (!next) {
      updateBackButtonState();
      return;
    }
    /* ---- PART 5B (END) ---- */

    /* ---- PART 5C: Push current tab into back stack (START) ---- */
    if (currentTab) {
      tabHistory.push(currentTab);
      if (tabHistory.length > 25) {
        tabHistory.shift();
      }
    }
    /* ---- PART 5C (END) ---- */

    /* ---- PART 5D: Navigate without writing new history (START) ---- */
    isNavigatingForward = true;
    activateTab(next);
    isNavigatingForward = false;
    updateBackButtonState();
    /* ---- PART 5D (END) ---- */
  });
}
/* ================================== SECTION 5 (END) ===================================== */



/* ===========================================================================================
   SECTION 6: Initial tab on page load (START)
   - Restores from localStorage if possible
   - Defaults to "solve"
=========================================================================================== */
const savedTab = localStorage.getItem(LAST_TAB_KEY) || "solve";
currentTab = savedTab;
activateTab(savedTab);
/* ================================== SECTION 6 (END) ===================================== */
</script>





<!-- BLOCK 6: UI wiring for Snap, Math, Study, Essay ----------------------------------------
--------------------------------------------------------------------------------------=----
===========================================================================================
===========================================================================================
------------------------------------------------------------------------------------------->

<script>
/* ===========================================================================================
   SECTION 0: Run this wiring when the page is ready (START)
   - DOMContentLoaded means the HTML elements exist before we try to grab them
=========================================================================================== */
document.addEventListener("DOMContentLoaded", function () {
/* ================================== SECTION 0 (END) ===================================== */



  /* =========================================================================================
     SECTION 1: SNAP elements (camera/gallery + OCR + solve + preview) (START)
     - IDs are unchanged
  ========================================================================================= */
  const snapInputGallery = document.getElementById("snapInputGallery");
  const snapInputCamera  = document.getElementById("snapInputCamera");
  const snapOCRBtn       = document.getElementById("snapOCRBtn");
  const snapClearBtn     = document.getElementById("snapClearBtn");
  const snapText         = document.getElementById("snapText");
  const snapResult       = document.getElementById("snapResult");
  const snapSolveBtn     = document.getElementById("snapActionSolveBtn");

  const snapCameraBtn = document.getElementById("snapCameraBtn");
  const snapUploadBtn = document.getElementById("snapUploadBtn");
  const snapPreview   = document.getElementById("snapPreview");

  const refreshOcrButton = document.getElementById("refreshOcrButton");

  // Subject input (used for auto-fill)
  const saveSubjectInput = document.getElementById("saveSubjectInput");
  /* ================================= SECTION 1 (END) ==================================== */



  /* =========================================================================================
     SECTION 2: Extra instructions helper (START)
     Goal:
     - Read "tell the AI what you want" from whichever element exists:
       #extraInstructionsInput OR #extraInstructions OR #extraPrompt
  ========================================================================================= */
  function getExtraInstructions() {
    const el =
      document.getElementById("extraInstructionsInput") ||
      document.getElementById("extraInstructions") ||
      document.getElementById("extraPrompt");

    if (!el) return "";
    return (el.value || "").trim();
  }
  /* ================================= SECTION 2 (END) ==================================== */



  /* =========================================================================================
     SECTION 3: Track the last chosen image file (START)
     Goal:
     - Remember camera/gallery choice
     - OCR uses whatever was chosen last
  ========================================================================================= */
  let lastSnapFile = null;
  /* ================================= SECTION 3 (END) ==================================== */



  /* =========================================================================================
     SECTION 4: Auto-fill subject based on OCR/text content (START)
     Goal:
     - If user hasn't set a custom subject, try to auto-fill from snapText
     Rules:
     - Do not overwrite if subject is already set to something not "general"
     - Prefer extractHeadingFromOcrText() if it exists, otherwise use first non-empty line
  ========================================================================================= */
  function maybeFillSubjectFromOcrNow() {
    if (!snapText || !saveSubjectInput) return;

    // Don't overwrite if user already set something custom
    const current = (saveSubjectInput.value || "").trim();
    if (current && current.toLowerCase() !== "general") return;

    const raw = snapText.value || "";
    if (!raw.trim()) return;

    let heading = "";

    // Use smarter heading extractor if it exists
    if (typeof extractHeadingFromOcrText === "function") {
      heading = extractHeadingFromOcrText(raw) || "";
    }

    // Fallback: first non-empty line
    if (!heading) {
      const firstLine = raw
        .split(/\r?\n/)
        .map((l) => l.trim())
        .find((l) => l.length > 0);

      if (firstLine) heading = firstLine;
    }

    if (!heading) return;

    // Trim to something reasonable
    if (heading.length > 60) {
      heading = heading.slice(0, 60).trim() + "…";
    }

    saveSubjectInput.value = heading;
  }

  // ALSO auto-fill when user types/pastes into snapText
  if (snapText) {
    snapText.addEventListener("input", () => {
      maybeFillSubjectFromOcrNow();
    });
  }
  /* ================================= SECTION 4 (END) ==================================== */



  /* =========================================================================================
     SECTION 5: Loading animations (START)
     Two types:
     - Textarea loading (shows “Reading image...” with dots)
     - Result loading (shows “Thinking...” with dots)
     Note:
     - They store interval IDs in dataset.loadingIntervalId so we can stop them cleanly
  ========================================================================================= */

  /* ---- PART 5A: Textarea loading (START) ---- */
  function startTextareaLoading(ta, baseText) {
    if (!ta) return;

    // Ensure we aren't stacking multiple intervals
    stopTextareaLoading(ta);

    let dotCount = 0;
    const maxDots = 3;

    ta.value = baseText;
    if (window.autoResizeTextarea) window.autoResizeTextarea(ta);

    const id = setInterval(() => {
      dotCount = (dotCount + 1) % (maxDots + 1);
      const dots = ".".repeat(dotCount);
      ta.value = baseText + dots;
      if (window.autoResizeTextarea) window.autoResizeTextarea(ta);
    }, 400);

    ta.dataset.loadingIntervalId = String(id);
  }

  function stopTextareaLoading(ta) {
    if (!ta) return;

    const id = ta.dataset.loadingIntervalId;
    if (id) {
      clearInterval(Number(id));
      delete ta.dataset.loadingIntervalId;
    }
  }
  /* ---- PART 5A (END) ---- */


  /* ---- PART 5B: Result element loading (START) ---- */
  function startResultLoading(el, baseText) {
    if (!el) return;

    // For styling consistency (your tool output styles)
    el.classList.add("tool-output");

    stopResultLoading(el);

    let dotCount = 0;
    const maxDots = 3;

    el.textContent = baseText;

    const id = setInterval(() => {
      dotCount = (dotCount + 1) % (maxDots + 1);
      const dots = ".".repeat(dotCount);
      el.textContent = baseText + dots;
    }, 400);

    el.dataset.loadingIntervalId = String(id);
  }

  function stopResultLoading(el) {
    if (!el) return;

    const id = el.dataset.loadingIntervalId;
    if (id) {
      clearInterval(Number(id));
      delete el.dataset.loadingIntervalId;
    }
  }
  /* ---- PART 5B (END) ---- */

  /* ================================= SECTION 5 (END) ==================================== */



  /* =========================================================================================
     SECTION 6: Handle selecting an image file + preview (START)
     Goal:
     - Save the file to lastSnapFile
     - Show preview image in #snapPreview
  ========================================================================================= */
  function handleSnapFile(file) {
    // If no file, clear preview and stored file
    if (!file) {
      lastSnapFile = null;

      if (snapPreview) {
        snapPreview.src = "";
        snapPreview.style.display = "none";
      }
      return;
    }

    // Save this as the most recent file
    lastSnapFile = file;

    // Read file for preview
    const reader = new FileReader();
    reader.onload = (e) => {
      if (snapPreview) {
        snapPreview.src = e.target.result;
        snapPreview.style.display = "block";
      }
    };
    reader.readAsDataURL(file);
  }
  /* ================================= SECTION 6 (END) ==================================== */



  /* =========================================================================================
     SECTION 7: Open Camera / Open Gallery buttons (START)
     - These just trigger clicks on hidden file inputs
  ========================================================================================= */

  /* ---- PART 7A: Open CAMERA input (START) ---- */
  if (snapCameraBtn && snapInputCamera) {
    snapCameraBtn.addEventListener("click", () => {
      snapInputCamera.click();
    });
  }
  /* ---- PART 7A (END) ---- */

  /* ---- PART 7B: Open GALLERY/file picker input (START) ---- */
  if (snapUploadBtn && snapInputGallery) {
    snapUploadBtn.addEventListener("click", () => {
      snapInputGallery.click();
    });
  }
  /* ---- PART 7B (END) ---- */

  /* ================================= SECTION 7 (END) ==================================== */



  /* =========================================================================================
     SECTION 8: When the user picks a file (camera or gallery) (START)
     - We grab the file and call handleSnapFile(file)
  ========================================================================================= */

  /* ---- PART 8A: Camera "change" event (START) ---- */
  if (snapInputCamera) {
    snapInputCamera.addEventListener("change", () => {
      const file = snapInputCamera.files[0];
      handleSnapFile(file);
    });
  }
  /* ---- PART 8A (END) ---- */

  /* ---- PART 8B: Gallery "change" event (START) ---- */
  if (snapInputGallery) {
    snapInputGallery.addEventListener("change", () => {
      const file = snapInputGallery.files[0];
      handleSnapFile(file);
    });
  }
  /* ---- PART 8B (END) ---- */

  /* ================================= SECTION 8 (END) ==================================== */



  /* =========================================================================================
     SECTION 9: Run OCR button (START)
     - Uses lastSnapFile
     - Shows loading animation in #snapText
     - Fills #snapText with OCR text
     - Auto-fills subject
     - Fires an "input" event in case other listeners exist
  ========================================================================================= */
  if (snapOCRBtn) {
    snapOCRBtn.addEventListener("click", async () => {
      if (!lastSnapFile) {
        alert("Choose or take an image first.");
        return;
      }

      startTextareaLoading(snapText, "Reading image");

      const text = await runFakeOCR(lastSnapFile);

      stopTextareaLoading(snapText);

      if (snapText) {
        snapText.value = text;
        if (window.autoResizeTextarea) window.autoResizeTextarea(snapText);

        // update subject from OCR text
        maybeFillSubjectFromOcrNow();

        // still fire input for any other listeners you have
        snapText.dispatchEvent(new Event("input"));
      }
    });
  }
  /* ================================= SECTION 9 (END) ==================================== */



  /* =========================================================================================
     SECTION 10: Refresh OCR button (START)
     - Re-runs OCR without re-uploading
     - Calls runFakeOCR(null) to reuse last stored image data URL
  ========================================================================================= */
  if (refreshOcrButton) {
    refreshOcrButton.addEventListener("click", async () => {
      if (!lastSnapFile) {
        alert("Choose or take an image first.");
        return;
      }

      const originalText = refreshOcrButton.textContent;
      refreshOcrButton.disabled = true;
      refreshOcrButton.textContent = "Refreshing...";

      startTextareaLoading(snapText, "Reading image");

      const text = await runFakeOCR(null); // reuse last image in runFakeOCR

      stopTextareaLoading(snapText);

      if (snapText) {
        snapText.value = text;
        if (window.autoResizeTextarea) window.autoResizeTextarea(snapText);

        // update subject from refreshed OCR
        maybeFillSubjectFromOcrNow();

        // still fire input for any other listeners you have
        snapText.dispatchEvent(new Event("input"));
      }

      refreshOcrButton.textContent = originalText;
      refreshOcrButton.disabled = false;
    });
  }
  /* ================================= SECTION 10 (END) =================================== */



  /* =========================================================================================
     SECTION 11: Clear button (START)
     Clears:
     - Camera/gallery inputs
     - lastSnapFile
     - lastOcrImageDataUrl (if defined in another block)
     - snapText, saveSubjectInput, snapResult, snapPreview
  ========================================================================================= */
  if (snapClearBtn) {
    snapClearBtn.addEventListener("click", () => {
      /* ---- PART 11A: Reset file inputs (START) ---- */
      if (snapInputCamera)  snapInputCamera.value = "";
      if (snapInputGallery) snapInputGallery.value = "";
      /* ---- PART 11A (END) ---- */

      /* ---- PART 11B: Reset image/OCR stored state (START) ---- */
      lastSnapFile = null;

      // lastOcrImageDataUrl is defined in another block, so use try/catch for safety
      try { lastOcrImageDataUrl = null; } catch (e) {}
      /* ---- PART 11B (END) ---- */

      /* ---- PART 11C: Clear main OCR text box (START) ---- */
      if (snapText) {
        snapText.value = "";
        if (window.autoResizeTextarea) window.autoResizeTextarea(snapText);
      }
      /* ---- PART 11C (END) ---- */

      /* ---- PART 11D: Clear subject input (START) ---- */
      if (saveSubjectInput) {
        saveSubjectInput.value = "";
      }
      /* ---- PART 11D (END) ---- */

      /* ---- PART 11E: Clear Snap result output (START) ---- */
      if (snapResult) {
        snapResult.textContent = "";
      }
      /* ---- PART 11E (END) ---- */

      /* ---- PART 11F: Clear preview image (START) ---- */
      if (snapPreview) {
        snapPreview.src = "";
        snapPreview.style.display = "none";
      }
      /* ---- PART 11F (END) ---- */
    });
  }
  /* ================================= SECTION 11 (END) =================================== */



  /* =========================================================================================
     SECTION 12: Solve/Explain from Snap (START)
     Flow:
     - Read text from #snapText
     - Add optional extra instructions
     - Usage gate (__canUseAIOnce / __canUseAIOnceAnon)
     - Activate "solve" tab
     - Copy text into #solveInput (if it exists)
     - Show "Thinking..." loading on #snapResult
     - Run runSnapSolve()
     - Sanitize + render formatted output
     - Save to notebook
  ========================================================================================= */
  if (snapSolveBtn) {
    snapSolveBtn.addEventListener("click", async () => {
      const text = (snapText && snapText.value ? snapText.value : "").trim();
      if (!text) {
        alert("No text to solve.");
        return;
      }

      const extra = getExtraInstructions();
      const promptText = extra
        ? text + "\n\nExtra instructions from student (tone/length/format/etc.):\n" + extra
        : text;

      /* ---- PART 12A: Usage gate (START) ---- */
      if (window.__canUseAIOnce) {
        const allowed = await window.__canUseAIOnce();
        if (!allowed) return;
      } else if (window.__canUseAIOnceAnon && !window.__canUseAIOnceAnon()) {
        return;
      }
      /* ---- PART 12A (END) ---- */

      /* ---- PART 12B: Switch to Solve tab (START) ---- */
      if (typeof activateTab === "function") {
        activateTab("solve");
      }
      /* ---- PART 12B (END) ---- */

      /* ---- PART 12C: Put text into solve input (if present) (START) ---- */
      const solveInput = document.getElementById("solveInput");
      if (solveInput) {
        solveInput.value = text; // keep original in UI
        if (window.autoResizeTextarea) window.autoResizeTextarea(solveInput);
      }
      /* ---- PART 12C (END) ---- */

      /* ---- PART 12D: Run the AI solve call + render (START) ---- */
      startResultLoading(snapResult, "Thinking");

      const ans = await runSnapSolve(promptText);

      stopResultLoading(snapResult);

      const clean = sanitizeAnswerText(ans);
      renderAnswer(snapResult, clean);
      addNotebookItem("Snap", clean);
      /* ---- PART 12D (END) ---- */
    });
  }
  /* ================================= SECTION 12 (END) =================================== */



  /* =========================================================================================
     SECTION 13: MATH UI wiring (START)
     Note:
     - Your UI IDs exist (#mathInput etc.)
     - But this handler reads from #snapText (your “main text box”) by design
  ========================================================================================= */
  const mathInput    = document.getElementById("mathInput");
  const mathSolveBtn = document.getElementById("mathSolveBtn");
  const mathClearBtn = document.getElementById("mathClearBtn");
  const mathResult   = document.getElementById("mathResult");

  /* ---- PART 13A: Solve math (START) ---- */
  if (mathSolveBtn) {
    mathSolveBtn.addEventListener("click", async () => {
      const text = (snapText && snapText.value ? snapText.value : "").trim();
      if (!text) {
        alert("Type or paste a math problem into the main text box first.");
        return;
      }

      const extra = getExtraInstructions();
      const promptText = extra
        ? text + "\n\nExtra instructions from student (tone/steps/detail/etc.):\n" + extra
        : text;

      // usage gate
      if (window.__canUseAIOnce) {
        const allowed = await window.__canUseAIOnce();
        if (!allowed) return;
      } else if (window.__canUseAIOnceAnon && !window.__canUseAIOnceAnon()) {
        return;
      }

      startResultLoading(mathResult, "Thinking");

      const ans = await runMathSolver(promptText);

      stopResultLoading(mathResult);

      const clean = sanitizeAnswerText(ans);
      renderAnswer(mathResult, clean);
      addNotebookItem("Math", clean);
    });
  }
  /* ---- PART 13A (END) ---- */

  /* ---- PART 13B: Clear math result (START) ---- */
  if (mathClearBtn) {
    mathClearBtn.addEventListener("click", () => {
      if (mathResult) mathResult.textContent = "";
    });
  }
  /* ---- PART 13B (END) ---- */

  /* ================================= SECTION 13 (END) =================================== */



  /* =========================================================================================
     SECTION 14: STUDY UI wiring (START)
     Note:
     - Reads from #snapText (main text box) by design
  ========================================================================================= */
  const studyInput    = document.getElementById("studyInput");
  const studyGuideBtn = document.getElementById("studyGuideBtn");
  const studyClearBtn = document.getElementById("studyClearBtn");
  const studyResult   = document.getElementById("studyResult");

  /* ---- PART 14A: Generate study guide (START) ---- */
  if (studyGuideBtn) {
    studyGuideBtn.addEventListener("click", async () => {
      const text = (snapText && snapText.value ? snapText.value : "").trim();
      if (!text) {
        alert("Paste some notes or text into the main text box first.");
        return;
      }

      const extra = getExtraInstructions();
      const promptText = extra
        ? text + "\n\nExtra instructions from student (what to focus on, how short/long, etc.):\n" + extra
        : text;

      // usage gate
      if (window.__canUseAIOnce) {
        const allowed = await window.__canUseAIOnce();
        if (!allowed) return;
      } else if (window.__canUseAIOnceAnon && !window.__canUseAIOnceAnon()) {
        return;
      }

      startResultLoading(studyResult, "Thinking");

      const ans = await runStudyGuide(promptText);

      stopResultLoading(studyResult);

      const clean = sanitizeAnswerText(ans);
      renderAnswer(studyResult, clean);
      addNotebookItem("Study", clean);
    });
  }
  /* ---- PART 14A (END) ---- */

  /* ---- PART 14B: Clear study result (START) ---- */
  if (studyClearBtn) {
    studyClearBtn.addEventListener("click", () => {
      if (studyResult) studyResult.textContent = "";
    });
  }
  /* ---- PART 14B (END) ---- */

  /* ================================= SECTION 14 (END) =================================== */



  /* =========================================================================================
     SECTION 15: ESSAY UI wiring (START)
     Note:
     - Reads from #snapText (main text box) by design
  ========================================================================================= */
  const essayInput    = document.getElementById("essayInput");
  const essayBtn      = document.getElementById("essayBtn");
  const essayClearBtn = document.getElementById("essayClearBtn");
  const essayResult   = document.getElementById("essayResult");

  /* ---- PART 15A: Generate/improve essay (START) ---- */
  if (essayBtn) {
    essayBtn.addEventListener("click", async () => {
      const text = (snapText && snapText.value ? snapText.value : "").trim();
      if (!text) {
        alert("Paste your essay or prompt into the main text box first.");
        return;
      }

      const extra = getExtraInstructions();
      const promptText = extra
        ? text + "\n\nExtra instructions from student (tone, length, structure, citations, etc.):\n" + extra
        : text;

      // usage gate
      if (window.__canUseAIOnce) {
        const allowed = await window.__canUseAIOnce();
        if (!allowed) return;
      } else if (window.__canUseAIOnceAnon && !window.__canUseAIOnceAnon()) {
        return;
      }

      startResultLoading(essayResult, "Thinking");

      const ans = await runEssayHelper(promptText);

      stopResultLoading(essayResult);

      const clean = sanitizeAnswerText(ans);
	  essayResult.dataset.raw = clean;
      renderAnswer(essayResult, clean);
      addNotebookItem("Essay", clean);
    });
  }
  /* ---- PART 15A (END) ---- */

  /* ---- PART 15B: Clear essay result (START) ---- */
  if (essayClearBtn) {
    essayClearBtn.addEventListener("click", () => {
      if (essayResult) essayResult.textContent = "";
    });
  }
  /* ---- PART 15B (END) ---- */

  /* ================================= SECTION 15 (END) =================================== */

}); // end DOMContentLoaded
</script>








<!-- BLOCK 7: Flashcards generation + interactive viewer (FIXED cleanSide collision) ---------
--------------------------------------------------------------------------------------=----
===========================================================================================
===========================================================================================
------------------------------------------------------------------------------------------->

<script>
/* ===========================================================================================
   SECTION 0: Flashcards DOM elements + storage keys (START)
=========================================================================================== */
const cardsInput = document.getElementById("cardsInput");
const cardsBtn = document.getElementById("cardsBtn");
const cardsClearBtn = document.getElementById("cardsClearBtn");
const cardsResult = document.getElementById("cardsResult");

const cardsViewer = document.getElementById("cardsViewer");
const cardsStats = document.getElementById("cardsStats");
const cardsFront = document.getElementById("cardsFront");
const cardsBack = document.getElementById("cardsBack");
const cardsFlipBtn = document.getElementById("cardsFlipBtn");
const cardsGotItBtn = document.getElementById("cardsGotItBtn");
const cardsNeedWorkBtn = document.getElementById("cardsNeedWorkBtn");
const cardsCard = document.getElementById("cardsCard");

const cardsStorageKey = "studyai-flashcards";
const cardsStateKey = "studyai-flashcards-state";

/* 🔹 NEW: disable the "stack squares" UI entirely (removes cardsStacksWrapper) */
const ENABLE_FLASHCARD_STACKS_UI = false;
/* ================================== SECTION 0 (END) ===================================== */



/* ===========================================================================================
   SECTION 1: Load/save flashcard VIEW STATE (deck + index) (START)
=========================================================================================== */
function loadFlashcardsState() {
  try {
    return JSON.parse(localStorage.getItem(cardsStateKey) || "{}");
  } catch (e) {
    return {};
  }
}

function saveFlashcardsState() {
  try {
    localStorage.setItem(
      cardsStateKey,
      JSON.stringify({
        currentDeck,
        currentCardIndex
      })
    );
  } catch (e) {
    // ignore
  }
}
/* ================================== SECTION 1 (END) ===================================== */



/* ===========================================================================================
   SECTION 2: Optional sound effect (START)
=========================================================================================== */
const ENABLE_FLASHCARD_SOUND = true;
let gotItAudio = null;

if (ENABLE_FLASHCARD_SOUND) {
  gotItAudio = new Audio("/sounds/flashcard-success.mp3");
}
/* ================================== SECTION 2 (END) ===================================== */



/* ===========================================================================================
   SECTION 3: Flashcards runtime state (START)
=========================================================================================== */
let flashcards = [];
let currentCardIndex = 0;
let showingBack = false;

let currentDeck = "needs"; // "needs" | "got" | "all"

let cardsStackAllBtn = null;
let cardsStackNeedsBtn = null;
let cardsStackGotBtn = null;

let fixedCardHeight = null;
/* ================================== SECTION 3 (END) ===================================== */



/* ===========================================================================================
   SECTION 4: IMPORTANT FIX — avoid overriding global cleanSide() (START)
=========================================================================================== */
function cleanSideForCardsViewer(raw) {
  if (typeof window.cleanSide === "function") {
    return window.cleanSide(raw);
  }
  if (raw == null) return "";
  return String(raw).trim();
}
/* ================================== SECTION 4 (END) ===================================== */



/* ===========================================================================================
   SECTION 5: Move viewer above textarea (START)
=========================================================================================== */
(function moveViewerAboveTextarea() {
  if (
    cardsViewer &&
    cardsInput &&
    cardsInput.parentNode &&
    cardsInput.parentNode === cardsViewer.parentNode
  ) {
    cardsInput.parentNode.insertBefore(cardsViewer, cardsInput);
  }
})();
/* ================================== SECTION 5 (END) ===================================== */



/* ===========================================================================================
   SECTION 6: Encouragement burst data + helpers (START)
=========================================================================================== */
const GOTIT_PHRASES = [
  "Nice!", "Locked in", "Aced it", "So good", "Too easy", "Big win",
  "On fire", "All set", "Got it", "So clean", "Well done", "Great job",
  "So ready", "Study win", "Gold star", "Go you", "Test ready", "Nice work",
  "Brain power", "Level up", "You win", "So sharp", "Top tier", "Dialed in",
  "Memory win", "Clean hit", "Good job", "So strong", "Sharp mind", "Nice one",
  "All good", "Rock on", "Pro move", "Clutch", "Too smart", "Peak form",
  "Max focus", "Laser brain", "Quiz boss", "Exam ace", "Study pro", "Star mode",
  "Big brain", "Full marks", "Perfect", "Textbook", "On point", "All clear",
  "Solid", "So solid", "So smooth", "Pure win", "Nice save", "Yes!", "Sweet",
  "Boom!", "Love it", "Great!", "Done!", "Win!", "Locked!", "Crushed it",
  "Nailed it", "So pro", "Right on", "So right", "Correct", "Exact",
  "Bullseye", "No doubt", "Zero miss", "All right", "Brain boost",
  "High score", "Quiz king", "Clear win", "So crisp", "Nailed that",
  "Spot on", "Nice pull", "Clutch win", "Sharp shot", "Clean win",
  "Test boss", "Quiz star", "Full brain", "Got this", "Big yes", "All win",
  "Brain gold", "Score!", "Top form", "Prime mind"
];

const GOTIT_COLORS = [
  "#f97316", "#22c55e", "#3b82f6", "#ec4899",
  "#eab308", "#a855f7", "#06b6d4", "#fb7185"
];

let gotitRecentIndices = [];

function pickGotItPhrase() {
  const n = GOTIT_PHRASES.length;
  if (!n) return "Nice!";
  const maxTries = 10;
  let chosen = 0;

  for (let i = 0; i < maxTries; i++) {
    const idx = Math.floor(Math.random() * n);
    if (!gotitRecentIndices.includes(idx)) {
      chosen = idx;
      break;
    }
    chosen = idx;
  }

  gotitRecentIndices.push(chosen);
  if (gotitRecentIndices.length > 10) gotitRecentIndices.shift();

  return GOTIT_PHRASES[chosen];
}

function pickGotItColor() {
  const n = GOTIT_COLORS.length;
  if (!n) return "#f97316";
  return GOTIT_COLORS[Math.floor(Math.random() * n)];
}

function spawnGotItBurst(anchorEl) {
  if (!anchorEl) return;

  const rect = anchorEl.getBoundingClientRect();
  const baseX = rect.left + rect.width / 2;
  const baseY = rect.top + rect.height / 2;

  const phrase = pickGotItPhrase();
  const color = pickGotItColor();

  if (cardsCard) {
    cardsCard.style.borderColor = color;
  }

  const wordEl = document.createElement("div");
  wordEl.textContent = phrase;

  wordEl.style.position = "fixed";
  wordEl.style.left = baseX + "px";
  wordEl.style.top = baseY + "px";
  wordEl.style.transform = "translate(-50%, -50%) scale(0.9)";
  wordEl.style.pointerEvents = "none";
  wordEl.style.whiteSpace = "nowrap";
  wordEl.style.zIndex = "9999";
  wordEl.style.opacity = "0";
  wordEl.style.fontWeight = "800";

  let fontSizePx = 16;
  if (window.innerWidth < 700) fontSizePx = 14;
  else if (window.innerWidth > 1000) fontSizePx = 18;
  wordEl.style.fontSize = fontSizePx + "px";

  wordEl.style.color = color;

  const riseDuration = 700 + Math.random() * 400;
  wordEl.style.transition =
    "transform " + riseDuration + "ms ease-out, opacity " + riseDuration + "ms ease-out";

  const fragContainer = document.createElement("div");
  fragContainer.style.position = "absolute";
  fragContainer.style.left = "50%";
  fragContainer.style.top = "50%";
  fragContainer.style.transform = "translate(-50%, -50%)";
  fragContainer.style.pointerEvents = "none";

  const letters = phrase.replace(/\s+/g, "").split("");
  const fragCount = Math.min(24, Math.max(12, letters.length || 12));

  for (let i = 0; i < fragCount; i++) {
    const ch = letters[i % letters.length] || "•";
    const frag = document.createElement("span");
    frag.textContent = ch;
    frag.style.display = "inline-block";
    frag.style.fontSize = Math.max(10, fontSizePx * 0.75) + "px";
    frag.style.fontWeight = "700";
    frag.style.color = color;
    frag.style.opacity = "1";
    frag.style.transform = "translate(0px, 0px) scale(1)";

    const dur = 550 + Math.random() * 350;
    frag.style.transition =
      "transform " + dur + "ms ease-out, opacity " + dur + "ms ease-out";

    const spread = 70 + Math.random() * 60;
    const angle = Math.random() * Math.PI * 2;
    const tx = Math.cos(angle) * spread;
    const ty = Math.sin(angle) * spread - 20;

    setTimeout(() => {
      frag.style.transform = "translate(" + tx + "px, " + ty + "px) scale(0.5)";
      frag.style.opacity = "0";
    }, 60 + i * 12);

    fragContainer.appendChild(frag);
  }

  wordEl.appendChild(fragContainer);
  document.body.appendChild(wordEl);

  requestAnimationFrame(() => {
    const driftY = -50 - Math.random() * 25;
    wordEl.style.opacity = "1";
    wordEl.style.transform = "translate(-50%, calc(-50% + " + driftY + "px)) scale(1.05)";
  });

  setTimeout(() => {
    wordEl.style.opacity = "0";
    wordEl.style.transform = "translate(-50%, calc(-50% - 70px)) scale(0.95)";
  }, riseDuration);

  setTimeout(() => {
    if (wordEl.parentNode) wordEl.parentNode.removeChild(wordEl);
  }, riseDuration + 600);
}
/* ================================== SECTION 6 (END) ===================================== */



/* ===========================================================================================
   SECTION 7: Theme-aware card styles (START)
=========================================================================================== */
function updateCardStylesForTheme() {
  const theme = document.documentElement.getAttribute("data-theme") || "dark";

  if (cardsFront) {
    cardsFront.classList.toggle("flashcard-question-light", theme === "light");
    cardsFront.classList.toggle("flashcard-question-dark", theme !== "light");
  }

  if (cardsCard) {
    cardsCard.classList.toggle("flashcard-card-light", theme === "light");
    cardsCard.classList.toggle("flashcard-card-dark", theme !== "light");
  }
}

(function watchThemeForFlashcards() {
  updateCardStylesForTheme();
  if (typeof MutationObserver === "function") {
    const obs = new MutationObserver(updateCardStylesForTheme);
    obs.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ["data-theme"]
    });
  }
})();
/* ================================== SECTION 7 (END) ===================================== */



/* ===========================================================================================
   SECTION 8: Load/save flashcards deck (START)
=========================================================================================== */
function loadFlashcardsStorage() {
  try {
    return JSON.parse(localStorage.getItem(cardsStorageKey) || "[]");
  } catch (e) {
    return [];
  }
}

function saveFlashcards(cards) {
  localStorage.setItem(cardsStorageKey, JSON.stringify(cards));
}
/* ================================== SECTION 8 (END) ===================================== */



/* ===========================================================================================
   SECTION 8B: Non-blocking saves (START)
   - localStorage is synchronous (can cause huge INP spikes)
   - Queue saves to run when the browser is idle
=========================================================================================== */
function pgIdle(fn) {
  if (window.requestIdleCallback) {
    return window.requestIdleCallback(fn, { timeout: 800 });
  }
  return setTimeout(fn, 0);
}

let __pgCardsSaveQueued = false;

function queueFlashcardsSave() {
  if (__pgCardsSaveQueued) return;
  __pgCardsSaveQueued = true;

  pgIdle(() => {
    __pgCardsSaveQueued = false;
    try { saveFlashcards(flashcards); } catch (e) {}
    try { saveFlashcardsState(); } catch (e) {}
  });
}
/* ================================== SECTION 8B (END) ==================================== */



/* ===========================================================================================
   SECTION 9: Parse flashcards from Q/A text (START)
=========================================================================================== */
function parseFlashcardsFromText(raw) {
  const text = typeof raw === "string" ? raw : String(raw ?? "");
  const lines = text.split(/\r?\n/);

  const temp = [];
  let current = null;

  for (let line of lines) {
    const trimmed = line.trim();
    if (!trimmed) continue;

    const qMatch = trimmed.match(/^Q[\s.:,-]*?(.*)$/i);
    const aMatch = trimmed.match(/^A[\s.:,-]*?(.*)$/i);

    if (qMatch) {
      if (current && current.front && current.back) {
        temp.push(current);
      }
      current = { front: qMatch[1].trim(), back: "" };
    } else if (aMatch && current) {
      const piece = aMatch[1].trim();
      current.back = current.back ? current.back + "\n" + piece : piece;
    } else if (current) {
      if (!current.back) current.front += "\n" + trimmed;
      else current.back += "\n" + trimmed;
    }
  }

  if (current && current.front && current.back) {
    temp.push(current);
  }

  const now = Date.now();
  return temp.map((c, i) => ({
    id: now + "-" + i,
    front: c.front,
    back: c.back,
    status: "new",
    seen: 0,
    correct: 0,
    lastSeen: now,
  }));
}
/* ================================== SECTION 9 (END) ===================================== */



/* ===========================================================================================
   SECTION 10: Shared loader (START)
=========================================================================================== */
function loadFlashcardsFromText(rawText, opts = {}) {
  const text = typeof rawText === "string" ? rawText : String(rawText ?? "");
  const parsed = parseFlashcardsFromText(text);

  if (!parsed.length) {
    alert("I couldn't detect any Q/A pairs in that text.");
    return;
  }

  const desiredDeck = opts.deck || "needs";

  flashcards = parsed;
  currentDeck = desiredDeck;
  currentCardIndex = 0;
  showingBack = false;
  fixedCardHeight = null;

  queueFlashcardsSave();

  if (ENABLE_FLASHCARD_STACKS_UI) {
    initDeckStacksUI();
    updateStacksUI();
  }

  renderCurrentCard();

  if (opts.scroll !== false && cardsViewer && typeof cardsViewer.scrollIntoView === "function") {
    cardsViewer.style.display = "block";
    cardsViewer.scrollIntoView({ behavior: "smooth", block: "start" });
  }
}

window.loadFlashcardsFromText = loadFlashcardsFromText;
/* ================================== SECTION 10 (END) ==================================== */



/* ===========================================================================================
   SECTION 11: Deck indices helper (START)
=========================================================================================== */
function getDeckIndices() {
  if (!flashcards.length) return [];

  if (currentDeck === "all") return flashcards.map((c, idx) => idx);

  if (currentDeck === "got") {
    return flashcards.reduce((arr, c, idx) => {
      if (c.status === "got") arr.push(idx);
      return arr;
    }, []);
  }

  return flashcards.reduce((arr, c, idx) => {
    if (c.status !== "got") arr.push(idx);
    return arr;
  }, []);
}
/* ================================== SECTION 11 (END) ==================================== */



/* ===========================================================================================
   SECTION 12: Stacks UI creation + updates (START)
   (DISABLED when ENABLE_FLASHCARD_STACKS_UI=false)
=========================================================================================== */
function initDeckStacksUI() {
  // Always remove it if it exists (you said you want it gone)
  const existing = document.getElementById("cardsStacksWrapper");
  if (existing) existing.remove();

  // Never recreate if disabled
  if (!ENABLE_FLASHCARD_STACKS_UI) return;

  if (!cardsViewer || !cardsViewer.parentNode) return;

  const container = cardsViewer.parentNode;

  const wrapper = document.createElement("div");
  wrapper.id = "cardsStacksWrapper";
  wrapper.style.display = "flex";
  wrapper.style.gap = "8px";
  wrapper.style.marginTop = "8px";

  function makeStackButton(label, deckKey) {
    const btn = document.createElement("button");
    btn.type = "button";
    btn.dataset.deck = deckKey;

    btn.style.minWidth = "68px";
    btn.style.minHeight = "44px";
    btn.style.borderRadius = "6px";
    btn.style.border = "1px solid rgba(148, 163, 184, 0.9)";
    btn.style.background = "var(--card-bg)";
    btn.style.fontSize = "11px";
    btn.style.display = "flex";
    btn.style.flexDirection = "column";
    btn.style.alignItems = "center";
    btn.style.justifyContent = "center";
    btn.style.padding = "4px 6px";
    btn.style.cursor = "pointer";
    btn.style.gap = "2px";

    const labelSpan = document.createElement("span");
    labelSpan.textContent = label;
    labelSpan.style.fontWeight = "600";

    const countSpan = document.createElement("span");
    countSpan.className = "cards-stack-count";
    countSpan.textContent = "0";
    countSpan.style.opacity = "0.75";

    btn.appendChild(labelSpan);
    btn.appendChild(countSpan);

    btn.addEventListener("click", () => {
      currentDeck = deckKey;
      currentCardIndex = 0;
      queueFlashcardsSave();
      renderCurrentCard();
      updateStacksUI();
    });

    return btn;
  }

  cardsStackGotBtn = makeStackButton("Got it", "got");
  cardsStackNeedsBtn = makeStackButton("Needs work", "needs");
  cardsStackAllBtn = makeStackButton("All", "all");

  wrapper.appendChild(cardsStackGotBtn);
  wrapper.appendChild(cardsStackNeedsBtn);
  wrapper.appendChild(cardsStackAllBtn);

  if (cardsViewer.nextSibling) container.insertBefore(wrapper, cardsViewer.nextSibling);
  else container.appendChild(wrapper);
}

function updateStacksUI() {
  if (!ENABLE_FLASHCARD_STACKS_UI) return;

  if (!flashcards || !flashcards.length) {
    [cardsStackGotBtn, cardsStackNeedsBtn, cardsStackAllBtn].forEach((btn) => {
      if (!btn) return;
      const c = btn.querySelector(".cards-stack-count");
      if (c) c.textContent = "0";
    });
    return;
  }

  const total = flashcards.length;
  const got = flashcards.filter((c) => c.status === "got").length;
  const needs = flashcards.filter((c) => c.status !== "got").length;

  if (cardsStackGotBtn) {
    const c = cardsStackGotBtn.querySelector(".cards-stack-count");
    if (c) c.textContent = String(got);
  }
  if (cardsStackNeedsBtn) {
    const c = cardsStackNeedsBtn.querySelector(".cards-stack-count");
    if (c) c.textContent = String(needs);
  }
  if (cardsStackAllBtn) {
    const c = cardsStackAllBtn.querySelector(".cards-stack-count");
    if (c) c.textContent = String(total);
  }

  [cardsStackGotBtn, cardsStackNeedsBtn, cardsStackAllBtn].forEach((btn) => {
    if (!btn) return;
    btn.style.boxShadow = (btn.dataset.deck === currentDeck)
      ? "0 0 0 2px rgba(59,130,246,0.7)"
      : "none";
  });
}
/* ================================== SECTION 12 (END) ==================================== */



/* ===========================================================================================
   SECTION 13: Stats + card height lock (START)
=========================================================================================== */
function updateCardsStats() {
  if (!flashcards.length) {
    if (cardsStats) cardsStats.textContent = "No cards yet. Create some above.";
    return;
  }

  const deck = getDeckIndices();
  if (!deck.length) {
    if (cardsStats) cardsStats.textContent = "No cards in this stack. Try another stack above.";
    return;
  }

  const totalDeck = deck.length;
  const got = flashcards.filter((c) => c.status === "got").length;
  const need = flashcards.filter((c) => c.status !== "got").length;
  const indexLabel = currentCardIndex + 1;

  if (cardsStats) {
    cardsStats.textContent =
      `Card ${indexLabel} of ${totalDeck}` +
      ` • Got it ${got}` +
      ` • Study More ${need}`;
  }
}

function lockCardHeightOnce() {
  if (!cardsCard || fixedCardHeight !== null) return;

  requestAnimationFrame(() => {
    const h = cardsCard.offsetHeight;
    if (h && h > 0) {
      fixedCardHeight = h;
      cardsCard.style.minHeight = h + "px";
    }
  });
}
/* ================================== SECTION 13 (END) ==================================== */



/* ===========================================================================================
   SECTION 14: Render current card (UPDATED to use cleanSideForCardsViewer) (START)
=========================================================================================== */
function renderCurrentCard() {
  if (!cardsViewer) return;

  if (!flashcards.length) {
    cardsViewer.style.display = "none";
    if (cardsStats) cardsStats.textContent = "No cards yet. Create some above.";
    return;
  }

  const deck = getDeckIndices();
  if (!deck.length) {
    cardsViewer.style.display = "none";
    if (cardsStats) cardsStats.textContent = "No cards in this stack. Try another stack above.";
    return;
  }

  if (currentCardIndex < 0 || currentCardIndex >= deck.length) {
    currentCardIndex = 0;
  }

  const card = flashcards[deck[currentCardIndex]];
  cardsViewer.style.display = "block";
  showingBack = false;

  if (cardsFront) cardsFront.style.display = "block";
  if (cardsBack) cardsBack.style.display = "none";

  const rawFront = card.front || "[No question]";
  const rawBack  = card.back  || "[No answer]";

  const frontText = cleanSideForCardsViewer(rawFront) || "[No question]";
  const backText  = cleanSideForCardsViewer(rawBack)  || "[No answer]";

  if (cardsFront) cardsFront.textContent = frontText;
  if (cardsBack)  cardsBack.textContent  = backText;

  updateCardStylesForTheme();
  updateCardsStats();
  lockCardHeightOnce();
}
/* ================================== SECTION 14 (END) ==================================== */



/* ===========================================================================================
   SECTION 15: Init from storage on load (START)
=========================================================================================== */
(function initFlashcardsFromStorage() {
  const stored = loadFlashcardsStorage();
  const state = loadFlashcardsState();

  initDeckStacksUI();

  if (stored && stored.length) {
    flashcards = stored;
    currentDeck = state.currentDeck || "needs";
    currentCardIndex =
      typeof state.currentCardIndex === "number" ? state.currentCardIndex : 0;

    if (ENABLE_FLASHCARD_STACKS_UI) updateStacksUI();
    renderCurrentCard();

    if (cardsViewer && typeof cardsViewer.scrollIntoView === "function") {
      cardsViewer.style.display = "block";
      cardsViewer.scrollIntoView({ behavior: "smooth", block: "start" });
    }
  } else {
    if (ENABLE_FLASHCARD_STACKS_UI) updateStacksUI();
  }
})();
/* ================================== SECTION 15 (END) ==================================== */



/* ===========================================================================================
   SECTION 16: Generate flashcards (AI) (START)
=========================================================================================== */
if (cardsBtn) {
  cardsBtn.addEventListener("click", async () => {
    const text = (typeof snapText !== "undefined" && snapText && snapText.value)
      ? snapText.value.trim()
      : "";

    if (!text) {
      alert("Paste content into the main text box first.");
      return;
    }

    if (window.__canUseAIOnce) {
      const allowed = await window.__canUseAIOnce();
      if (!allowed) return;
    } else if (window.__canUseAIOnceAnon && !window.__canUseAIOnceAnon()) {
      return;
    }

    if (cardsResult) cardsResult.textContent = "Thinking...";

    try {
      if (typeof runFlashcards !== "function") {
        throw new Error("runFlashcards() is not defined. Check your TASK HELPERS section.");
      }

      const ans = await runFlashcards(text);
      const answerText = typeof ans === "string" ? ans : String(ans ?? "");

      renderAnswer(cardsResult, answerText);
      loadFlashcardsFromText(answerText, { deck: "needs", scroll: true });
      addNotebookItem("Cards", answerText);
    } catch (err) {
      console.error("Flashcards error:", err);
      if (cardsResult) cardsResult.textContent = "⚠️ Flashcards error: " + err.message;
    }
  });
}
/* ================================== SECTION 16 (END) ==================================== */



/* ===========================================================================================
   SECTION 17: Reset button + flip + next + got/need work (START)
=========================================================================================== */
if (cardsClearBtn) {
  cardsClearBtn.textContent = "Reset";

  cardsClearBtn.addEventListener("click", () => {
    if (!flashcards.length) return;



    const now = Date.now();
    flashcards = flashcards.map((c) => ({
      ...c,
      status: "new",
      seen: 0,
      correct: 0,
      lastSeen: now
    }));

    currentDeck = "needs";
    currentCardIndex = 0;
    showingBack = false;
    fixedCardHeight = null;

    queueFlashcardsSave();
    if (ENABLE_FLASHCARD_STACKS_UI) updateStacksUI();
    renderCurrentCard();

    if (cardsViewer) cardsViewer.style.display = "block";
  });
}

if (cardsFlipBtn) {
  cardsFlipBtn.addEventListener("click", () => {
    if (!flashcards.length) return;
    showingBack = !showingBack;
    if (cardsFront) cardsFront.style.display = showingBack ? "none" : "block";
    if (cardsBack)  cardsBack.style.display  = showingBack ? "block" : "none";
  });
}

function goToNextCard() {
  const deck = getDeckIndices();
  if (!deck.length) {
    renderCurrentCard();
    return;
  }
  currentCardIndex = (currentCardIndex + 1) % deck.length;
  queueFlashcardsSave();
  renderCurrentCard();
}

if (cardsGotItBtn) {
  cardsGotItBtn.addEventListener("click", () => {
    if (!flashcards.length) return;

    const deck = getDeckIndices();
    if (!deck.length) {
      renderCurrentCard();
      return;
    }

    const cardIndex = deck[currentCardIndex];
    const card = flashcards[cardIndex];

    card.status = "got";
    card.seen = (card.seen || 0) + 1;
    card.correct = (card.correct || 0) + 1;
    card.lastSeen = Date.now();

    queueFlashcardsSave();

    if (ENABLE_FLASHCARD_SOUND && gotItAudio) {
      try {
        gotItAudio.currentTime = 0;
        gotItAudio.play();
      } catch (e) {}
    }

    spawnGotItBurst(cardsGotItBtn);

    if (ENABLE_FLASHCARD_STACKS_UI) updateStacksUI();
    goToNextCard();
  });
}

if (cardsNeedWorkBtn) {
  cardsNeedWorkBtn.addEventListener("click", () => {
    if (!flashcards.length) return;

    const deck = getDeckIndices();
    if (!deck.length) {
      renderCurrentCard();
      return;
    }

    const cardIndex = deck[currentCardIndex];
    const card = flashcards[cardIndex];

    card.status = "need_work";
    card.seen = (card.seen || 0) + 1;
    card.lastSeen = Date.now();

    queueFlashcardsSave();

    if (ENABLE_FLASHCARD_STACKS_UI) updateStacksUI();

    if (cardsCard) {
      cardsCard.style.borderColor = "";
    }

    goToNextCard();
  });
}
/* ================================== SECTION 17 (END) ==================================== */
</script>






<!-- BLOCK 9: Simplify and hint “pill” buttons ----------------------------------------------
--------------------------------------------------------------------------------------=----
===========================================================================================
===========================================================================================
------------------------------------------------------------------------------------------->

<script>
/* ===========================================================================================
   SECTION 0: Wire up Simplify + Hint buttons (START)
   IMPORTANT NOTE:
   - This attaches to ALL elements with class ".pill-button"
   - It only runs when the clicked pill has:
       data-action="simplify" or data-action="hint"
     AND data-target="<id of output element>"
=========================================================================================== */
document.querySelectorAll(".pill-button").forEach((btn) => {
  btn.addEventListener("click", async () => {
    /* ---- PART 0A: Read the action + target output element (START) ---- */
    const action = btn.dataset.action;
    const targetId = btn.dataset.target;

    // If a pill button isn't a simplify/hint pill, do nothing
    if (!action || !targetId) return;

    const outputEl = document.getElementById(targetId);
    if (!outputEl) return;
    /* ---- PART 0A (END) ---- */


    /* ---- PART 0B: Get the CURRENT text we want to process (START) ----
       - renderAnswer() stores the “plain” copy in outputEl.dataset.plainText
       - If it doesn’t exist, we fallback to outputEl.textContent
    */
    const currentPlain =
      (outputEl.dataset && outputEl.dataset.plainText) ||
      (outputEl.textContent || "").trim();

    if (!currentPlain) {
      alert("Nothing to process yet.");
      return;
    }
    /* ---- PART 0B (END) ---- */


    /* =====================================================================================
       SECTION 1: SIMPLIFY action (START)
       - Shows a loading message
       - Calls runSimplify()
       - Sanitizes + renders with renderAnswer()
       - Saves to notebook
    ===================================================================================== */
    if (action === "simplify") {
      outputEl.textContent = "Simplifying...";

      const ans = await runSimplify(currentPlain);
      const clean = sanitizeAnswerText(ans);

      renderAnswer(outputEl, clean);
      addNotebookItem("Simplified", clean);
      return;
    }
    /* ================================= SECTION 1 (END) ================================== */


    /* =====================================================================================
       SECTION 2: HINT action (START)
       - Builds a questionText from existing inputs (snapText or mathInput)
       - Calls runHint(questionText, currentPlain)
       - Sanitizes the hint
       - Combines original answer + hint
       - Saves just the hint to notebook
    ===================================================================================== */
    if (action === "hint") {
      /* ---- PART 2A: Safely collect question text (FIXED) (START) ----
         Problem you had:
         - This block used snapText and mathInput variables that might NOT exist
           in this script’s scope, causing a ReferenceError.

         Fix:
         - Always fetch the DOM elements by ID here (safe, no dependency on other blocks).
      */
      const snapTextEl = document.getElementById("snapText");
      const mathInputEl = document.getElementById("mathInput");

      const questionText =
        (snapTextEl && snapTextEl.value) ||
        (mathInputEl && mathInputEl.value) ||
        "";
      /* ---- PART 2A (END) ---- */

      const ans = await runHint(questionText, currentPlain);
      const cleanHint = sanitizeAnswerText(ans);

      const combined = currentPlain + "\n\nHint:\n" + cleanHint;

      renderAnswer(outputEl, combined);
      addNotebookItem("Hint", cleanHint);
      return;
    }
    /* ================================= SECTION 2 (END) ================================== */
  });
});
/* ================================== SECTION 0 (END) ===================================== */
</script>



<!-- BLOCK X: Snap hint row — send OCR text to other tools -----------------------------------
--------------------------------------------------------------------------------------=----
===========================================================================================
===========================================================================================
------------------------------------------------------------------------------------------->

<script>
/* ===========================================================================================
   SECTION 0: Self-contained wrapper (START)
   - Uses an IIFE so variables here don't leak into global scope
=========================================================================================== */
(function () {
  /* ---- PART 0A: Grab Snap text area (START) ---- */
  const snapTextEl = document.getElementById("snapText");
  /* ---- PART 0A (END) ---- */


  /* =========================================================================================
     SECTION 1: Helper: wireSnapAction(buttonId, inputId, tabId) (START)
     What it does:
     - When button is clicked:
       1) Read text from #snapText
       2) Copy it into another tool’s input
       3) Switch tabs (if activateTab exists)
  ========================================================================================= */
  function wireSnapAction(buttonId, inputId, tabId) {
    const btn = document.getElementById(buttonId);
    const input = document.getElementById(inputId);

    // If something isn't on the page, silently do nothing
    if (!btn || !input) return;

    btn.addEventListener("click", () => {
      // If snapText is missing, we can't copy anything
      if (!snapTextEl) return;

      const text = (snapTextEl.value || "").trim();
      if (!text) {
        alert("No OCR text yet. Run OCR or type something first.");
        return;
      }

      // Put OCR text into the target tool input
      input.value = text;

      // Switch to the corresponding tab if activateTab exists
      if (typeof activateTab === "function" && tabId) {
        activateTab(tabId);
      }
    });
  }
  /* ================================= SECTION 1 (END) ==================================== */


  /* =========================================================================================
     SECTION 2: Wire the Snap row buttons to other tools (START)
     NOTE:
     - IDs stay EXACTLY the same
     - If a button/input is missing on the page, it just won't wire up
  ========================================================================================= */
  wireSnapAction("mathSolveBtn", "mathInput", "math");
  wireSnapAction("studyGuideBtn", "studyInput", "study");
  wireSnapAction("essayBtn", "essayInput", "essay");
  wireSnapAction("cardsBtn", "cardsInput", "flashcards");
  /* ================================= SECTION 2 (END) ==================================== */

})();
/* ================================== SECTION 0 (END) ===================================== */
</script>


<!-- BLOCK: Completion animations (non-invasive wrappers) ------------------------------------
--------------------------------------------------------------------------------------=----
===========================================================================================
===========================================================================================
------------------------------------------------------------------------------------------->

<script>
/* ===========================================================================================
   SECTION 0: Self-contained wrapper (START)
   - This is an IIFE (Immediately Invoked Function Expression)
   - It keeps variables inside so nothing leaks globally except what you purposely export
=========================================================================================== */
(function () {

  /* =========================================================================================
     SECTION 1: animatePulse(el) helper (START)
     What it does:
     - Removes the CSS class "pulse-once"
     - Forces a reflow (so the browser restarts the animation)
     - Adds the class back, triggering the animation again
  ========================================================================================= */
  function animatePulse(el) {
    if (!el) return;

    // Remove the class so we can restart the animation
    el.classList.remove("pulse-once");

    // Force reflow so the animation can retrigger
    // (This line makes the browser "re-calc" layout immediately)
    void el.offsetWidth;

    // Re-add the class to trigger the animation
    el.classList.add("pulse-once");
  }
  /* ================================= SECTION 1 (END) ==================================== */


  /* =========================================================================================
     SECTION 2: Export for manual use (OPTIONAL) (START)
     - You can call window.__animatePulse(document.getElementById("snapText"))
       from the console if you want.
  ========================================================================================= */
  window.__animatePulse = animatePulse;
  /* ================================= SECTION 2 (END) ==================================== */



  /* =========================================================================================
     SECTION 3: Wrapper helper to avoid repeating the same pattern (FIX) (START)
     Why this is a fix:
     - Your original code repeated the same "wrap a function" logic many times.
     - This helper does it safely and consistently.
     - It also avoids breaking anything if the function isn't defined yet.

     What it does:
     - Takes a global function name (string), like "runFakeOCR"
     - Replaces it with a new async function that:
         1) calls the original
         2) pulses a specific element
         3) returns the original result
  ========================================================================================= */
  function wrapAsyncGlobalFunction(fnName, getElementToPulse) {
    // Make sure the function exists on window and is callable
    if (typeof window[fnName] !== "function") return;

    // Save the original function
    const originalFn = window[fnName];

    // Replace it with a wrapper
    window[fnName] = async function (...args) {
      const result = await originalFn.apply(this, args);

      // Pulse AFTER it finishes (setTimeout 0 puts it at end of current event loop)
      setTimeout(() => {
        const el = typeof getElementToPulse === "function"
          ? getElementToPulse()
          : null;
        animatePulse(el);
      }, 0);

      return result;
    };

    // (Optional) keep a reference to original in case you ever need it later
    window[fnName].__original = originalFn;
  }
  /* ================================= SECTION 3 (END) ==================================== */



  /* =========================================================================================
     SECTION 4: Apply wrappers (START)
     Each one:
     - Wraps the async function
     - Pulses the correct element after completion
  ========================================================================================= */

  /* ---- PART 4A: After OCR completes -> highlight snapText (START) ---- */
  wrapAsyncGlobalFunction("runFakeOCR", () => document.getElementById("snapText"));
  /* ---- PART 4A (END) ---- */

  /* ---- PART 4B: After Snap solve completes -> highlight snapResult (START) ---- */
  wrapAsyncGlobalFunction("runSnapSolve", () => document.getElementById("snapResult"));
  /* ---- PART 4B (END) ---- */

  /* ---- PART 4C: After Math solver -> highlight mathResult (START) ---- */
  wrapAsyncGlobalFunction("runMathSolver", () => document.getElementById("mathResult"));
  /* ---- PART 4C (END) ---- */

  /* ---- PART 4D: After Study guide -> highlight studyResult (START) ---- */
  wrapAsyncGlobalFunction("runStudyGuide", () => document.getElementById("studyResult"));
  /* ---- PART 4D (END) ---- */

  /* ---- PART 4E: After Essay helper -> highlight essayResult (START) ---- */
  wrapAsyncGlobalFunction("runEssayHelper", () => document.getElementById("essayResult"));
  /* ---- PART 4E (END) ---- */

  /* ---- PART 4F: After Quiz maker -> highlight quizResult (START) ---- */
  wrapAsyncGlobalFunction("runQuiz", () => document.getElementById("quizResult"));
  /* ---- PART 4F (END) ---- */

  /* ---- PART 4G: After Flashcards generation -> highlight viewer or raw result (START) ---- */
  wrapAsyncGlobalFunction("runFlashcards", () => {
    const viewer = document.getElementById("cardsViewer");
    const resultEl = document.getElementById("cardsResult");
    return viewer || resultEl;
  });
  /* ---- PART 4G (END) ---- */

  /* ================================= SECTION 4 (END) ==================================== */

})(); // end IIFE
/* ================================== SECTION 0 (END) ===================================== */
</script>


<!-- BLOCK: Button click pulse (safe + non-breaking) -----------------------------------------
--------------------------------------------------------------------------------------=----
===========================================================================================
===========================================================================================
------------------------------------------------------------------------------------------->

<script>
/* ===========================================================================================
   SECTION 0: Self-contained wrapper (START)
=========================================================================================== */
(function () {

  /* =========================================================================================
     SECTION 1: Ensure __animatePulse exists (START)
     - If a previous block already created window.__animatePulse, we reuse it
     - If not, we define a safe fallback
  ========================================================================================= */
  if (typeof window.__animatePulse !== "function") {
    window.__animatePulse = function (el) {
      if (!el) return;
      el.classList.remove("pulse-once");

      // Force reflow so animation restarts
      void el.offsetWidth;

      el.classList.add("pulse-once");
    };
  }
  /* ================================= SECTION 1 (END) ==================================== */



  /* =========================================================================================
     SECTION 2: Find the "big action" buttons (START)
     - We build ONE selector string from the list of IDs
     - querySelectorAll returns a NodeList of matching elements
  ========================================================================================= */
  const selector = [
    "#snapOCRBtn",
    "#snapActionSolveBtn",
    "#mathSolveBtn",
    "#studyGuideBtn",
    "#essayBtn",
    "#cardsBtn"
  ].join(",");

  const buttons = document.querySelectorAll(selector);
  /* ================================= SECTION 2 (END) ==================================== */



  /* =========================================================================================
     SECTION 3: Add click listeners to pulse the button itself (START)
     - When a button is clicked, it pulses immediately
  ========================================================================================= */
  buttons.forEach((btn) => {
    // querySelectorAll never returns null items, but this check is harmless
    if (!btn) return;

    btn.addEventListener("click", () => {
      window.__animatePulse(btn);
    });
  });
  /* ================================= SECTION 3 (END) ==================================== */

})(); // end IIFE
/* ================================== SECTION 0 (END) ===================================== */
</script>


<!-- BLOCK: Anonymous usage limiter (guest 10 total + logged-in monthly limit) ---------------
--------------------------------------------------------------------------------------=----
===========================================================================================
===========================================================================================
------------------------------------------------------------------------------------------->

<script>
/* ===========================================================================================
   SECTION 0: Self-contained wrapper (START)
   - This IIFE keeps variables from polluting global scope
   - We ONLY expose two globals on purpose:
       window.__canUseAIOnceAnon
       window.__canUseAIOnce
=========================================================================================== */
(function () {

  /* =========================================================================================
     SECTION 1: Constants / configuration (START)
     - ANON_LIMIT: total anonymous uses allowed (lifetime, stored in localStorage)
     - STORAGE_KEY: localStorage key where anon uses are stored
     - FREE_MONTHLY_LIMIT: monthly free limit for logged-in (non-pro) users
  ========================================================================================= */
  const ANON_LIMIT = 10;
  const STORAGE_KEY = "passinggrade-anon-uses";

  // Monthly free limit for logged-in users (non-pro)
  const FREE_MONTHLY_LIMIT = 10; // change whenever you want
  /* ================================= SECTION 1 (END) ==================================== */



  /* =========================================================================================
     SECTION 2: UI helper (refresh usage label) (START)
     - If updateAuthUI exists, call it safely to refresh header text
  ========================================================================================= */
  function refreshUsageLabel() {
    try {
      if (typeof window.updateAuthUI === "function") {
        window.updateAuthUI();
      }
    } catch (e) {
      console.error("updateAuthUI from limiter failed", e);
    }
  }
  /* ================================= SECTION 2 (END) ==================================== */



  /* =========================================================================================
     SECTION 3: Anonymous usage storage helpers (START)
     - getAnonUses(): read integer from localStorage
     - setAnonUses(count): write integer to localStorage
  ========================================================================================= */
  function getAnonUses() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      // parseInt can return NaN, so fallback to 0
      return raw ? (parseInt(raw, 10) || 0) : 0;
    } catch (e) {
      // localStorage might be blocked/unavailable
      return 0;
    }
  }

  function setAnonUses(count) {
    try {
      localStorage.setItem(STORAGE_KEY, String(count));
    } catch (e) {
      // ignore storage errors
    }
  }
  /* ================================= SECTION 3 (END) ==================================== */



  /* =========================================================================================
     SECTION 4: Anonymous limit reached message (START)
  ========================================================================================= */
  function showAnonLimitReached() {
    alert(
      "You’ve used PassingGrade 10 times.\n\nTap ‘Sign in’ at the top right to create a free account and get 10 questions every month."
    );
  }
  /* ================================= SECTION 4 (END) ==================================== */



  /* =========================================================================================
     SECTION 5: Anonymous gate (SYNC) (START)
     What it does:
     - Reads anon uses
     - Blocks if uses >= ANON_LIMIT
     - Otherwise increments uses and returns true
     NOTE:
     - This is the fallback when not logged in (or no Supabase client)
  ========================================================================================= */
  function canUseAIOnceAnon() {
    const uses = getAnonUses();

    if (uses >= ANON_LIMIT) {
      showAnonLimitReached();
      return false;
    }

    // Increment anonymous usage
    setAnonUses(uses + 1);

    // Refresh header label (if present)
    refreshUsageLabel();

    return true;
  }

  // Expose so existing click handlers can call it
  window.__canUseAIOnceAnon = canUseAIOnceAnon;
  /* ================================= SECTION 5 (END) ==================================== */



  /* =========================================================================================
     SECTION 6: Auth-aware gate (ASYNC) (START)
     Behavior:
     - If no Supabase client -> use anonymous localStorage limiter
     - If not logged in -> use anonymous localStorage limiter
     - If logged in & plan === 'pro' -> allow unlimited
     - If logged in & plan !== 'pro' -> enforce FREE_MONTHLY_LIMIT per month

     IMPORTANT NOTE (behavior preserved exactly as your original):
     - This code increments usage in Supabase using:
         action: "ocr"
       even though you call it for "AI actions" generally.
       I did NOT change that because it would affect how your backend counts usage.
  ========================================================================================= */
  async function canUseAIOnce() {
    try {
      /* ---- PART 6A: If Supabase isn't available, fall back to anon (START) ---- */
      if (!window.supabaseClient) {
        return window.__canUseAIOnceAnon();
      }
      /* ---- PART 6A (END) ---- */

      /* ---- PART 6B: Get current logged-in user (START) ---- */
      const {
        data: { user },
        error: userError,
      } = await window.supabaseClient.auth.getUser();

      if (userError || !user) {
        // Not logged in -> use anon localStorage limit
        return window.__canUseAIOnceAnon();
      }
      /* ---- PART 6B (END) ---- */

      /* ---- PART 6C: Look up user plan (START) ---- */
      let isPaid = false;

      try {
        const { data: planRow, error: planError } = await window.supabaseClient
          .from("user_plans")
          .select("plan")
          .eq("user_id", user.id)
          .maybeSingle();

        if (planError) {
          console.error("error reading user_plans", planError);
        }

        const plan = planRow?.plan || "free";
        isPaid = plan === "pro";
      } catch (planEx) {
        console.error("exception reading user_plans", planEx);
      }
      /* ---- PART 6C (END) ---- */

      /* ---- PART 6D: Pro plan -> allow unlimited (but still increment usage) (START) ---- */
      if (isPaid) {
        const { error: rpcErrorPaid } = await window.supabaseClient.rpc(
          "increment_usage",
          {
            p_action: "ocr",
            p_amount: 1,
          }
        );

        if (rpcErrorPaid) {
          console.error("increment_usage failed for paid user", rpcErrorPaid);
        }

        refreshUsageLabel();
        return true;
      }
      /* ---- PART 6D (END) ---- */

      /* ---- PART 6E: Free plan -> enforce monthly limit (START) ---- */

      // Compute first day of this month as YYYY-MM-01
      const now = new Date();
      const month = String(now.getMonth() + 1).padStart(2, "0");
      const periodStart = `${now.getFullYear()}-${month}-01`;

      // Read this month's usage row for action="ocr"
      const { data: row, error: selectError } = await window.supabaseClient
        .from("usage_counters")
        .select("count")
        .eq("user_id", user.id)
        .eq("period_start", periodStart)
        .eq("action", "ocr")
        .maybeSingle();

      if (selectError) {
        console.error("error reading usage", selectError);
        // Behavior preserved: do NOT block on read error
      }

      const currentCount = row?.count || 0;

      // Block if already at/over limit
      if (currentCount >= FREE_MONTHLY_LIMIT) {
        alert(
          "You’ve used your " +
            FREE_MONTHLY_LIMIT +
            " free questions for this month.\n\nUpgrade your plan to keep using PassingGrade."
        );
        return false;
      }

      // Under limit -> increment usage in Supabase
      const { error: rpcError } = await window.supabaseClient.rpc(
        "increment_usage",
        {
          p_action: "ocr",
          p_amount: 1,
        }
      );

      if (rpcError) {
        console.error("increment_usage failed", rpcError);
      }

      refreshUsageLabel();
      return true;
      /* ---- PART 6E (END) ---- */
    } catch (err) {
      /* ---- PART 6F: Fail-open safety (START) ----
         - If anything goes wrong, allow usage so the app doesn't break.
      */
      console.error("canUseAIOnce error", err);
      return true;
      /* ---- PART 6F (END) ---- */
    }
  }
  /* ================================= SECTION 6 (END) ==================================== */



  /* =========================================================================================
     SECTION 7: Expose async helper globally (START)
     - Your other blocks call window.__canUseAIOnce()
  ========================================================================================= */
  window.__canUseAIOnce = canUseAIOnce;
  /* ================================= SECTION 7 (END) ==================================== */

})(); // end IIFE
/* ================================== SECTION 0 (END) ===================================== */
</script>








<!-- BLOCK STUDY: Neon highlighting toolbar only (no grouped snippets) ------------------------
--------------------------------------------------------------------------------------=----
===========================================================================================
===========================================================================================
------------------------------------------------------------------------------------------->

<script>
/* ===========================================================================================
   SECTION 0: Self-contained wrapper (START)
   - This IIFE keeps variables/functions private so nothing leaks globally
=========================================================================================== */
(function () {

  /* =========================================================================================
     SECTION 1: initStudyHighlight() (START)
     - Finds #studyResult
     - Injects CSS once
     - Creates a toolbar once
     - Adds selection-highlighting behavior
  ========================================================================================= */
  function initStudyHighlight() {
    /* ---- PART 1A: Find the Study output element (START) ---- */
    const studyResult = document.getElementById("studyResult");
    if (!studyResult) return; // If Study tool isn't on the page, stop safely
    /* ---- PART 1A (END) ---- */


    /* =====================================================================================
       SECTION 2: Inject CSS once (START)
       - Adds toolbar styles and mobile styles
       - Only injects if #studyHighlightStyles is not already present
    ===================================================================================== */
    if (!document.getElementById("studyHighlightStyles")) {
      const style = document.createElement("style");
      style.id = "studyHighlightStyles";
      style.textContent = `
        /* Sticky toolbar INSIDE the Study div's parent, at the top */
        #studyHighlightToolbar {
          position: sticky;
          top: 54px;
          z-index: 19;
          padding-top: 10px;
          padding-bottom: 10px;
          padding-left: 16px;
          padding-right: 16px;
          display: flex;
          align-items: center;
          justify-content: flex-end; /* right side */
          gap: 8px;
          flex-wrap: wrap;
          background: var(--card-bg, rgba(15,23,42,0.95));
          margin-bottom: 15px;
        }

        #studyHighlightToolbar .study-color-btn {
          border-radius: 999px;
          font-size: 12px;
          padding: 6px 8px;
          border: 1px solid rgba(148,163,184,0.8);
          display: inline-flex;
          align-items: center;
          gap: 4px;
          cursor: pointer;
          background: transparent;
          white-space: nowrap;
        }

        #studyHighlightToolbar .study-color-dot {
          width: 10px;
          height: 10px;
          border-radius: 999px;
          flex-shrink: 0;
        }

        #studyHighlightApplyBtn {
          font-size: 11px;
          padding: 4px 10px;
          border-radius: 999px;
          border: 1px solid rgba(148,163,184,0.9);
          background: var(--card-bg, rgba(15,23,42,0.85));
          display: inline-flex;
          align-items: center;
          cursor: pointer;
          white-space: nowrap;

          /* NOTE: your original code hides this button completely */
          display: none;
        }

        #studyHighlightApplyBtn-label {
          margin-right: 6px;
        }

        #studyHighlightApplyBtn-dot {
          display: inline-block;
          width: 15px;
          height: 15px;
          border-radius: 999px;
        }

        /* MOBILE: keep one row; hide words visually; make dots bigger */
        @media (max-width: 640px) {
          #studyHighlightToolbar {
            padding-top: 8px;
            padding-bottom: 8px;
            justify-content: center;
            gap: 6px;
            flex-wrap: nowrap;
            overflow-x: auto;
          }

          #studyHighlightToolbar .study-color-btn {
            font-size: 10px;
            padding: 7px 4px;
            gap: 3px;
            padding-right: 0;
          }

          #studyHighlightToolbar .study-color-dot {
            width: 13px;
            height: 13px;
          }
        }
      `;
      document.head.appendChild(style);
    }
    /* ================================= SECTION 2 (END) ================================== */



    /* =====================================================================================
       SECTION 3: Highlight color configuration (START)
       - Each color has:
         key, label, lightBg, darkBg, (optional) lightText/darkText
    ===================================================================================== */
    const STUDY_HIGHLIGHT_COLORS = [
      { key: "yellow", label: "Yellow", lightBg: "rgba(250, 204, 21, 0.35)", darkBg: "rgba(234, 179, 8, 0.45)", lightText: "", darkText: "" },
      { key: "blue",   label: "Blue",   lightBg: "rgba(56, 189, 248, 0.35)", darkBg: "rgba(56, 189, 248, 0.45)", lightText: "", darkText: "" },
      { key: "green",  label: "Green",  lightBg: "rgba(74, 222, 128, 0.35)", darkBg: "rgba(34, 197, 94, 0.45)",  lightText: "", darkText: "" },
      { key: "pink",   label: "Pink",   lightBg: "rgba(244, 114, 182, 0.35)",darkBg: "rgba(236, 72, 153, 0.45)", lightText: "", darkText: "" },
      { key: "purple", label: "Purple", lightBg: "rgba(168, 85, 247, 0.35)", darkBg: "rgba(129, 56, 231, 0.45)", lightText: "", darkText: "" }
    ];

    const studyHighlightToolbarId  = "studyHighlightToolbar";
    const studyHighlightApplyBtnId = "studyHighlightApplyBtn";

    // The currently selected highlight color (defaults to first color)
    let currentStudyColorKey = STUDY_HIGHLIGHT_COLORS[0].key;
    /* ================================= SECTION 3 (END) ================================== */



    /* =====================================================================================
       SECTION 4: Theme helpers + color lookup (START)
    ===================================================================================== */
    function getTheme() {
      return document.documentElement.getAttribute("data-theme") || "dark";
    }

    function getColorConfig(key) {
      return STUDY_HIGHLIGHT_COLORS.find((c) => c.key === key);
    }
    /* ================================= SECTION 4 (END) ================================== */



    /* =====================================================================================
       SECTION 5: Apply highlight styles to ONE span (START)
       - Expects span.className === "study-highlight-token"
       - Expects span.dataset.colorKey to exist
    ===================================================================================== */
    function applyHighlightStylesToSpan(span) {
      if (!span || !span.dataset) return;

      const cfg = getColorConfig(span.dataset.colorKey);
      if (!cfg) return;

      const theme = getTheme();
      const bg = theme === "light" ? cfg.lightBg : cfg.darkBg;
      const textColor = theme === "light" ? cfg.lightText : cfg.darkText;

      span.style.backgroundColor = bg;
      span.style.borderRadius = "3px";
      span.style.padding = "0 2px";

      if (textColor) {
        span.style.color = textColor;
      } else {
        span.style.removeProperty("color");
      }
    }
    /* ================================= SECTION 5 (END) ================================== */



    /* =====================================================================================
       SECTION 6: Update ALL highlight spans (START)
       - Finds .study-highlight-token anywhere on the page (same as your original)
    ===================================================================================== */
    function updateAllStudyHighlightSpans() {
      const spans = document.querySelectorAll(".study-highlight-token");
      spans.forEach(applyHighlightStylesToSpan);
    }
    /* ================================= SECTION 6 (END) ================================== */



    /* =====================================================================================
       SECTION 7: Watch theme changes (START)
       - When data-theme changes, update all highlight spans
    ===================================================================================== */
    (function watchThemeForStudyHighlights() {
      if (typeof MutationObserver !== "function") return;

      const obs = new MutationObserver((mutations) => {
        for (const m of mutations) {
          if (m.type === "attributes" && m.attributeName === "data-theme") {
            updateAllStudyHighlightSpans();
            break;
          }
        }
      });

      obs.observe(document.documentElement, {
        attributes: true,
        attributeFilter: ["data-theme"]
      });
    })();
    /* ================================= SECTION 7 (END) ================================== */



    /* =====================================================================================
       SECTION 8: Selection boundary helper (START)
       - Ensures the selection's range is inside #studyResult
    ===================================================================================== */
    function selectionIsInsideStudy(range) {
      if (!range) return false;

      let node = range.commonAncestorContainer;
      while (node) {
        if (node === studyResult) return true;
        node = node.parentNode;
      }
      return false;
    }
    /* ================================= SECTION 8 (END) ================================== */



    /* =====================================================================================
       SECTION 9: Apply highlight to the CURRENT selection (START)
       Steps:
       1) Read window.getSelection()
       2) Validate range exists and is not collapsed
       3) Verify selection is inside #studyResult
       4) Wrap the selected content in <span class="study-highlight-token">
    ===================================================================================== */
    function applySelectionHighlightFromCurrentSelection() {
      const sel = window.getSelection();
      if (!sel || sel.rangeCount === 0) return;

      const range = sel.getRangeAt(0);
      if (!range) return;

      // If selection is empty or outside study, do nothing
      if (range.collapsed || !selectionIsInsideStudy(range)) return;

      const selectedText = range.toString().trim();
      if (!selectedText) return;

      // Create wrapper span for the highlighted selection
      const span = document.createElement("span");
      span.className = "study-highlight-token";
      span.dataset.colorKey = currentStudyColorKey;

      // Apply inline styles based on theme + chosen color
      applyHighlightStylesToSpan(span);

      try {
        // Move selected DOM into the new span, then insert span where selection was
        const extracted = range.extractContents();
        span.appendChild(extracted);
        range.insertNode(span);
      } catch (e) {
        // If the selection is too complex and extract/insert fails, safely bail
        return;
      }

      // Clear selection highlight in the browser
      if (sel.removeAllRanges) {
        sel.removeAllRanges();
      }
    }
    /* ================================= SECTION 9 (END) ================================== */



    /* =====================================================================================
       SECTION 10: Build the toolbar UI (START)
       - Creates toolbar only once
       - Adds color buttons
       - Adds (hidden) "Highlight" button
       - Inserts toolbar above #studyResult within the same parent container
    ===================================================================================== */
    function ensureStudyHighlightUI() {
      const parent = studyResult.parentNode;
      if (!parent) return;

      let toolbar = document.getElementById(studyHighlightToolbarId);

      // If toolbar already exists, do nothing
      if (toolbar) return;

      /* ---- PART 10A: Create toolbar container (START) ---- */
      toolbar = document.createElement("div");
      toolbar.id = studyHighlightToolbarId;
      /* ---- PART 10A (END) ---- */


      /* ---- PART 10B: Create color buttons (START) ---- */
      STUDY_HIGHLIGHT_COLORS.forEach((cfg) => {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.textContent = cfg.label;

        // dataset.colorKey => attribute becomes data-color-key in HTML
        btn.dataset.colorKey = cfg.key;

        btn.className = "study-color-btn";

        // Create the dot that shows the color
        const dot = document.createElement("span");
        dot.className = "study-color-dot";

        // Make dot fully opaque version of lightBg (replace alpha with 1)
        dot.style.backgroundColor = cfg.lightBg.replace(/, ?0\.\d+\)/, ", 1)");
        btn.appendChild(dot);

        btn.addEventListener("click", () => {
          // Update current selected color
          currentStudyColorKey = cfg.key;

          // Show a "selected" ring around the active color
          Array.from(toolbar.querySelectorAll('button[data-color-key]')).forEach((b) => {
            if (b.dataset.colorKey === currentStudyColorKey) {
              b.style.boxShadow = "0 0 0 3px rgba(187,183,193,0.8)";
            } else {
              b.style.boxShadow = "none";
            }
          });

          // Update the (hidden) Highlight button dot color
          const dotEl = document.getElementById(studyHighlightApplyBtnId + "-dot");
          if (dotEl) {
            const cfgNow = getColorConfig(currentStudyColorKey) || STUDY_HIGHLIGHT_COLORS[0];
            dotEl.style.backgroundColor = cfgNow.lightBg.replace(/, ?0\.\d+\)/, ", 1)");
          }

          // Optional: immediately highlight if user currently has a selection
          applySelectionHighlightFromCurrentSelection();
        });

        toolbar.appendChild(btn);
      });
      /* ---- PART 10B (END) ---- */


      /* ---- PART 10C: Mark first color as active (START) ---- */
      setTimeout(() => {
        const firstBtn = toolbar.querySelector(
          'button[data-color-key="' + currentStudyColorKey + '"]'
        );
        if (firstBtn) {
          firstBtn.style.boxShadow = "0 0 0 3px rgba(187,183,193,0.8)";
        }
      }, 0);
      /* ---- PART 10C (END) ---- */


      /* ---- PART 10D: Create "Highlight" apply button (hidden by CSS) (START) ---- */
      const applyBtn = document.createElement("button");
      applyBtn.id = studyHighlightApplyBtnId;
      applyBtn.type = "button";

      const labelSpan = document.createElement("span");
      labelSpan.id = "studyHighlightApplyBtn-label";
      labelSpan.textContent = "Highlight";
      applyBtn.appendChild(labelSpan);

      const applyDot = document.createElement("span");
      applyDot.id = "studyHighlightApplyBtn-dot";

      const cfg0 = getColorConfig(currentStudyColorKey) || STUDY_HIGHLIGHT_COLORS[0];
      applyDot.style.backgroundColor = cfg0.lightBg.replace(/, ?0\.\d+\)/, ", 1)");
      applyBtn.appendChild(applyDot);

      // When user activates the button, highlight current selection
      function onApplyActivate(e) {
        e.preventDefault();
        applySelectionHighlightFromCurrentSelection();
      }

      applyBtn.addEventListener("mousedown", onApplyActivate);
      applyBtn.addEventListener("touchstart", onApplyActivate);

      toolbar.appendChild(applyBtn);
      /* ---- PART 10D (END) ---- */


      /* ---- PART 10E: Insert toolbar at the top of the container (START) ---- */
      parent.insertBefore(toolbar, parent.firstChild);
      /* ---- PART 10E (END) ---- */
    }
    /* ================================= SECTION 10 (END) ================================= */



    /* =====================================================================================
       SECTION 11: Kick off UI creation (START)
    ===================================================================================== */
    ensureStudyHighlightUI();
    /* ================================= SECTION 11 (END) ================================= */
  }
  /* ================================== SECTION 1 (END) ==================================== */



  /* =========================================================================================
     SECTION 12: Run init at the right time (START)
     - If DOM is still loading, wait for DOMContentLoaded
     - Otherwise run immediately
  ========================================================================================= */
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initStudyHighlight);
  } else {
    initStudyHighlight();
  }
  /* ================================= SECTION 12 (END) =================================== */

})(); // end IIFE
/* ================================== SECTION 0 (END) ===================================== */
</script>




<!-- BLOCK TOOL STATE: Persist data + settings for all tools -------------------------------
--------------------------------------------------------------------------------------=----
===========================================================================================
===========================================================================================
------------------------------------------------------------------------------------------->

<script>
/* ===========================================================================================
   SECTION 0: Run after the page is ready (START)
   - DOMContentLoaded fires once the HTML is loaded and we can safely grab elements by ID
=========================================================================================== */
document.addEventListener("DOMContentLoaded", function () {

  /* =========================================================================================
     SECTION 1: localStorage helpers (START)
     - saveToolState(key, value): write a string
     - loadToolState(key): read a string (or null)
     - clearToolState(key): remove a key
  ========================================================================================= */
  function saveToolState(key, value) {
    try {
      localStorage.setItem(key, value);
    } catch (e) {
      // ignore (storage can be blocked)
    }
  }

  function loadToolState(key) {
    try {
      const v = localStorage.getItem(key);
      return v === null ? null : v;
    } catch (e) {
      return null;
    }
  }

  function clearToolState(key) {
    try {
      localStorage.removeItem(key);
    } catch (e) {
      // ignore
    }
  }
  /* ================================= SECTION 1 (END) ==================================== */



  /* =========================================================================================
     SECTION 2: Persist INPUT elements (START)
     - For <input> or <textarea> where user types
     - Loads saved value on page load
     - Saves on every input event
  ========================================================================================= */
  function setupInputPersistence(el, storageKey) {
    if (!el) return;

    // Load saved value
    const saved = loadToolState(storageKey);
    if (saved !== null) {
      el.value = saved;

      // If it's a textarea and auto-resize exists, resize after setting value
      if (window.autoResizeTextarea && el.tagName === "TEXTAREA") {
        window.autoResizeTextarea(el);
      }
    }

    // Save whenever user types
    el.addEventListener("input", () => {
      saveToolState(storageKey, el.value);
    });
  }
  /* ================================= SECTION 2 (END) ==================================== */



  /* =========================================================================================
     SECTION 3: Persist RESULT elements (START)
     - For output containers where HTML changes (renderAnswer writes innerHTML)
     - Loads saved innerHTML on page load
     - Uses a MutationObserver to save whenever the output changes
     - Skips saving during "Thinking..." interval animations
  ========================================================================================= */
  function setupResultPersistence(el, storageKey) {
    if (!el) return;

    // Load saved output HTML
    const saved = loadToolState(storageKey);
    if (saved !== null) {
      el.innerHTML = saved;
    }

    // Watch for changes and persist them
    const observer = new MutationObserver(() => {
      // Don't persist temporary loading animations
      if (el.dataset && el.dataset.loadingIntervalId) return;

      saveToolState(storageKey, el.innerHTML);
    });

    observer.observe(el, {
      childList: true,
      subtree: true,
      characterData: true
    });
  }
  /* ================================= SECTION 3 (END) ==================================== */



  /* =========================================================================================
     SECTION 4: SNAP main text + subject + extra instructions (START)
  ========================================================================================= */
  const snapText = document.getElementById("snapText");
  setupInputPersistence(snapText, "studyai-snap-text");

  const saveSubjectInput = document.getElementById("saveSubjectInput");
  setupInputPersistence(saveSubjectInput, "studyai-save-subject");

  // Extra instructions input (whichever ID exists)
  const extraInput =
    document.getElementById("extraInstructionsInput") ||
    document.getElementById("extraInstructions") ||
    document.getElementById("extraPrompt");
  setupInputPersistence(extraInput, "studyai-extra-instructions");
  /* ================================= SECTION 4 (END) ==================================== */



  /* =========================================================================================
     SECTION 5: SNAP result (START)
  ========================================================================================= */
  const snapResult = document.getElementById("snapResult");
  setupResultPersistence(snapResult, "studyai-snap-result");
  /* ================================= SECTION 5 (END) ==================================== */



  /* =========================================================================================
     SECTION 6: SOLVE tool (if present) (START)
  ========================================================================================= */
  const solveInput  = document.getElementById("solveInput");
  const solveResult = document.getElementById("solveResult");

  setupInputPersistence(solveInput, "studyai-solve-input");
  setupResultPersistence(solveResult, "studyai-solve-result");
  /* ================================= SECTION 6 (END) ==================================== */



  /* =========================================================================================
     SECTION 7: MATH tool (START)
  ========================================================================================= */
  const mathInput    = document.getElementById("mathInput");
  const mathResult   = document.getElementById("mathResult");
  const mathClearBtn = document.getElementById("mathClearBtn");

  setupInputPersistence(mathInput, "studyai-math-input");
  setupResultPersistence(mathResult, "studyai-math-result");

  // Clear button: wipe persisted result so it doesn't come back on refresh
  if (mathClearBtn) {
    mathClearBtn.addEventListener("click", () => {
      clearToolState("studyai-math-result");
    });
  }
  /* ================================= SECTION 7 (END) ==================================== */



  /* =========================================================================================
     SECTION 8: STUDY tool (START)
  ========================================================================================= */
  const studyInput    = document.getElementById("studyInput");
  const studyResult   = document.getElementById("studyResult");
  const studyClearBtn = document.getElementById("studyClearBtn");

  setupInputPersistence(studyInput, "studyai-study-input");
  setupResultPersistence(studyResult, "studyai-study-result");

  if (studyClearBtn) {
    studyClearBtn.addEventListener("click", () => {
      clearToolState("studyai-study-result");
    });
  }
  /* ================================= SECTION 8 (END) ==================================== */



  /* =========================================================================================
     SECTION 9: ESSAY tool (START)
  ========================================================================================= */
  const essayInput    = document.getElementById("essayInput");
  const essayResult   = document.getElementById("essayResult");
  const essayClearBtn = document.getElementById("essayClearBtn");

  setupInputPersistence(essayInput, "studyai-essay-input");
  setupResultPersistence(essayResult, "studyai-essay-result");

  if (essayClearBtn) {
    essayClearBtn.addEventListener("click", () => {
      clearToolState("studyai-essay-result");
    });
  }
  /* ================================= SECTION 9 (END) ==================================== */



  /* =========================================================================================
     SECTION 10: FLASHCARDS extra UI state (cardsResult only) (START)
     NOTE:
     - Flashcard deck + progress are already persisted in Block 7
     - Here we only persist the rendered output HTML in #cardsResult
  ========================================================================================= */
  const cardsResultEl = document.getElementById("cardsResult");
  const cardsClearBtn = document.getElementById("cardsClearBtn");

  setupResultPersistence(cardsResultEl, "studyai-cards-result");

  // "Reset" already resets progress; we also clear saved output HTML
  if (cardsClearBtn) {
    cardsClearBtn.addEventListener("click", () => {
      clearToolState("studyai-cards-result");
    });
  }
  /* ================================= SECTION 10 (END) =================================== */



  /* =========================================================================================
     SECTION 11: SNAP Clear wipes its main tool state (START)
  ========================================================================================= */
  const snapClearBtn = document.getElementById("snapClearBtn");
  if (snapClearBtn) {
    snapClearBtn.addEventListener("click", () => {
      clearToolState("studyai-snap-text");
      clearToolState("studyai-snap-result");
      clearToolState("studyai-save-subject");

      // Keep extra instructions unless you want them cleared too:
      // clearToolState("studyai-extra-instructions");
    });
  }
  /* ================================= SECTION 11 (END) =================================== */



  /* =========================================================================================
     SECTION 12: ACTIVE TAB persistence (FIXED SAFELY) (START)

     Problem in the original:
     - Your app already has a LAST_TAB_KEY system (Block 5).
     - This block wraps window.activateTab and then also calls originalActivateTab(savedTab).
     - That can be OK, but we must ensure we:
         1) Don’t wrap activateTab more than once
         2) Don’t accidentally call the wrapped version when restoring
         3) Don’t crash if activateTab doesn't exist yet

     Fix:
     - Add a guard flag so we only wrap once.
     - When restoring, call the ORIGINAL function reference (not the wrapped one).
  ========================================================================================= */

  // Only wrap once
  if (typeof window.activateTab === "function" && !window.activateTab.__toolStateWrapped) {
    const originalActivateTab = window.activateTab;

    // Create wrapped version
    function wrappedActivateTab(tabId) {
      saveToolState("studyai-active-tab", tabId);
      return originalActivateTab.apply(this, arguments);
    }

    // Mark wrapper so we don't wrap again
    wrappedActivateTab.__toolStateWrapped = true;

    // Replace global
    window.activateTab = wrappedActivateTab;

    // Restore saved tab (call ORIGINAL to avoid double-saving or recursion)
    const savedTab = loadToolState("studyai-active-tab");
    if (savedTab) {
      try {
        originalActivateTab(savedTab);
      } catch (e) {
        // ignore if tab doesn't exist anymore
      }
    }
  }
  /* ================================= SECTION 12 (END) =================================== */

});
/* ================================== SECTION 0 (END) ===================================== */
</script>



<!-- BLOCK AUTH: Supabase client + Google OAuth + header UI ----------------------------------
--------------------------------------------------------------------------------------=----
===========================================================================================
===========================================================================================
------------------------------------------------------------------------------------------->

<!-- Supabase client library (from CDN) -->
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

<script>
/* ===========================================================================================
   SECTION 0: Supabase project constants (START)
   - SUPABASE_URL: your Supabase project URL
   - SUPABASE_ANON_KEY: public anon key (safe to use in client apps)
=========================================================================================== */
const SUPABASE_URL = "https://rwjijfffirbpmkhcptrb.supabase.co";
const SUPABASE_ANON_KEY =
  "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJ3amlqZmZmaXJicG1raGNwdHJiIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjUwMzYxNDgsImV4cCI6MjA4MDYxMjE0OH0.Lfv2HGMbdyyjF_SUA-7rWWN5XpvaLX8I36-upjH8_nQ";
/* ================================= SECTION 0 (END) ===================================== */


/* ===========================================================================================
   SECTION 1: Create one Supabase client for the whole page (START)
   - window.supabase is provided by the CDN script above
   - window.supabaseClient is used by other blocks (usage limiter, etc.)
=========================================================================================== */
const supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
window.supabaseClient = supabaseClient;
/* ================================= SECTION 1 (END) ===================================== */


/* ===========================================================================================
   SECTION 2: Console test helpers (manual) (START)
   - testIncrementUsage(): calls your RPC "increment_usage"
   - showCurrentUsage(): reads this month’s usage row for the logged-in user
   NOTE: These are optional helpers for you while developing.
=========================================================================================== */
async function testIncrementUsage() {
  const { error } = await supabaseClient.rpc("increment_usage", {
    p_action: "ocr",
    p_amount: 1
  });

  if (error) {
    console.error("increment_usage failed", error);
  } else {
    console.log("increment_usage succeeded");
  }
}

async function showCurrentUsage() {
  const { data: userData, error: userError } = await supabaseClient.auth.getUser();

  if (userError || !userData.user) {
    console.error("no logged-in user", userError);
    return;
  }

  // First day of this month as YYYY-MM-01
  const now = new Date();
  const month = String(now.getMonth() + 1).padStart(2, "0");
  const periodStart = `${now.getFullYear()}-${month}-01`;

  const { data, error } = await supabaseClient
    .from("usage_counters")
    .select("*")
    .eq("user_id", userData.user.id)
    .eq("period_start", periodStart)
    .eq("action", "ocr")
    .maybeSingle();

  if (error) {
    console.error("error reading usage", error);
  } else {
    console.log("current usage row:", data);
  }
}
/* ================================= SECTION 2 (END) ===================================== */


/* ===========================================================================================
   SECTION 3: Handle OAuth tokens returned in URL (START)
=========================================================================================== */
async function handleAuthFromUrl() {
  const rawHash = window.location.hash || "";
  const rawSearch = window.location.search || "";

  if (!rawHash && !rawSearch) return;

  const hashParams = new URLSearchParams(rawHash.replace(/^#/, ""));
  const searchParams = new URLSearchParams(rawSearch.replace(/^\?/, ""));

  const accessToken =
    hashParams.get("access_token") || searchParams.get("access_token");
  const refreshToken =
    hashParams.get("refresh_token") || searchParams.get("refresh_token");

  if (!accessToken || !refreshToken) return;

  try {
    await supabaseClient.auth.setSession({
      access_token: accessToken,
      refresh_token: refreshToken
    });

    const cleanedSearch = new URLSearchParams(rawSearch.replace(/^\?/, ""));
    cleanedSearch.delete("access_token");
    cleanedSearch.delete("refresh_token");
    cleanedSearch.delete("token_type");
    cleanedSearch.delete("expires_in");
    cleanedSearch.delete("provider_token");
    cleanedSearch.delete("provider_refresh_token");

    const qs = cleanedSearch.toString();
    const newUrl = window.location.pathname + (qs ? "?" + qs : "");

    window.history.replaceState({}, document.title, newUrl);
  } catch (err) {
    console.error("Error setting session from OAuth redirect:", err);
  }
}
/* ================================= SECTION 3 (END) ===================================== */


/* ===========================================================================================
   SECTION 4: Read user's plan from your "user_plans" table (START)
=========================================================================================== */
async function fetchUserPlan(userId) {
  try {
    const { data, error } = await supabaseClient
      .from("user_plans")
      .select("plan")
      .eq("user_id", userId)
      .maybeSingle();

    if (error) {
      console.error("error loading user plan", error);
      return "free";
    }

    return data?.plan || "free";
  } catch (e) {
    console.error("fetchUserPlan exception", e);
    return "free";
  }
}
/* ================================= SECTION 4 (END) ===================================== */


/* ===========================================================================================
   SECTION 5: Update header UI (START)
=========================================================================================== */
async function updateAuthUI() {
  const userPlanLabel = document.getElementById("userPlanLabel");
  const authButton = document.getElementById("authButton");
  if (!userPlanLabel || !authButton) return;

  const { data, error } = await supabaseClient.auth.getUser();

  if (error || !data.user) {
    let anonUses = 0;
    try {
      const raw = localStorage.getItem("passinggrade-anon-uses");
      anonUses = raw ? (parseInt(raw, 10) || 0) : 0;
    } catch (e) {
      anonUses = 0;
    }

    const limit = 10;

    userPlanLabel.textContent = `Guest · ${anonUses}/${limit} free OCR scans`;
    authButton.textContent = "Sign in";
    authButton.dataset.authState = "signed-out";
    return;
  }

  const user = data.user;
  const email = user.email || "";
  const namePart = (email.split("@")[0] || "your account");

  const plan = await fetchUserPlan(user.id);
  const isPro = plan === "pro";

  let usageText = "";

  try {
    const now = new Date();
    const month = String(now.getMonth() + 1).padStart(2, "0");
    const periodStart = `${now.getFullYear()}-${month}-01`;

    const { data: row, error: usageError } = await supabaseClient
      .from("usage_counters")
      .select("count")
      .eq("user_id", user.id)
      .eq("period_start", periodStart)
      .eq("action", "ocr")
      .maybeSingle();

    if (usageError) {
      console.error("usage label read error", usageError);
    }

    const currentCount = row?.count || 0;

    usageText = isPro
      ? ` · ${currentCount} uses this month`
      : ` · ${currentCount}/10 uses this month`;
  } catch (e) {
    console.error("usage label exception", e);
  }

  let label = `signed in as ${namePart}`;
  if (!isPro) {
    label = `Free plan · ${label}`;
  }

  userPlanLabel.textContent = `${label}${usageText}`;
  authButton.textContent = "Sign out";
  authButton.dataset.authState = "signed-in";
}
/* ================================= SECTION 5 (END) ===================================== */


/* ===========================================================================================
   SECTION 6: Auth button click handler (START)
=========================================================================================== */
async function handleAuthButtonClick() {
  const authButton = document.getElementById("authButton");
  if (!authButton) return;

  const state = authButton.dataset.authState || "signed-out";

  if (state === "signed-in") {
    await supabaseClient.auth.signOut();
    await updateAuthUI();
    alert("Signed out.");
    return;
  }

  try {
    const { error } = await supabaseClient.auth.signInWithOAuth({
      provider: "google",
      options: {
        redirectTo: "https://passinggrade.app"
      }
    });

    if (error) {
      console.error("Google sign-in error:", error);
      alert("Error starting Google sign-in. Please try again.");
      return;
    }
  } catch (err) {
    console.error("OAuth error:", err);
    alert("Error starting sign-in. Please try again.");
  }
}
/* ================================= SECTION 6 (END) ===================================== */


/* ===========================================================================================
   SECTION 7: DOM wiring (START)
=========================================================================================== */
document.addEventListener("DOMContentLoaded", async () => {
  await handleAuthFromUrl();

  const authButton = document.getElementById("authButton");
  if (authButton) {
    authButton.addEventListener("click", handleAuthButtonClick);
  }

  updateAuthUI();
});
/* ================================= SECTION 7 (END) ===================================== */


/* ===========================================================================================
   SECTION 8: Global helper: getCurrentUserPlan (START)
=========================================================================================== */
window.getCurrentUserPlan = async function () {
  try {
    const { data, error } = await supabaseClient.auth.getUser();

    if (error || !data.user) {
      console.warn("no logged-in user for getCurrentUserPlan", error);
      return null;
    }

    return await fetchUserPlan(data.user.id);
  } catch (e) {
    console.error("getCurrentUserPlan exception", e);
    return "free";
  }
};
/* ================================= SECTION 8 (END) ===================================== */
</script>

<!-- BLOCK BILLING: Upgrade button + Pro badge (plan check + checkout redirect) ---------------
--------------------------------------------------------------------------------------=----
===========================================================================================
===========================================================================================
------------------------------------------------------------------------------------------->

<script>
/* ===========================================================================================
   SECTION 0: Run after DOM loads (START)
=========================================================================================== */
document.addEventListener("DOMContentLoaded", () => {

  /* =========================================================================================
     SECTION 1: Grab elements (START)
  ========================================================================================= */
  const upgradeBtn = document.getElementById("upgradeButton");
  const proBadge = document.getElementById("proBadge");

  // U13 disclaimer (supports id OR class OR data attr)
  const u13Disclaimer =
    document.getElementById("u13Disclaimer") ||
    document.querySelector(".u13-disclaimer") ||
    document.querySelector("[data-u13-disclaimer]");
  /* ================================= SECTION 1 (END) ==================================== */



  /* =========================================================================================
     SECTION 2: Helpers (START)
     - IMPORTANT: force-hide uses !important so CSS cannot override it
  ========================================================================================= */
  function forceHide(el) {
    if (!el) return;
    el.style.setProperty("display", "none", "important");
  }

  function unforceHide(el) {
    if (!el) return;
    el.style.removeProperty("display");
  }

  function setProUI() {
    forceHide(upgradeBtn);
    if (proBadge) {
      unforceHide(proBadge);
      proBadge.style.display = "inline-block";
    }
  }

  function setUpgradeUI() {
    unforceHide(upgradeBtn);
    if (proBadge) forceHide(proBadge);
  }
  /* ================================= SECTION 2 (END) ==================================== */



  /* =========================================================================================
     SECTION 3: Check plan on page load (START)
     - Logged out: show upgrade, show disclaimer
     - Logged in: hide disclaimer
     - Pro: hide upgrade, show badge
  ========================================================================================= */

  // ✅ NEW: prevent flicker from overlapping async checks
  let latestRunId = 0;
  let scheduleTimer = null;

  // ✅ NEW: remember last known plan so temporary errors don’t flip UI wrong
  let lastKnownIsPro = null;

  async function checkPlanOnLoad() {
    const runId = ++latestRunId;

    try {
      if (!window.supabaseClient) return;

      const { data, error } = await window.supabaseClient.auth.getUser();

      // If another newer run started, ignore this run’s result
      if (runId !== latestRunId) return;

      if (error || !data.user) {
        setUpgradeUI();
        if (u13Disclaimer) unforceHide(u13Disclaimer);
        lastKnownIsPro = null;
        return;
      }

      // Logged in: hide disclaimer always
      if (u13Disclaimer) forceHide(u13Disclaimer);

      const user = data.user;

      const { data: planRow, error: planError } = await window.supabaseClient
        .from("user_plans")
        .select("plan")
        .eq("user_id", user.id)
        .maybeSingle();

      // If another newer run started, ignore this run’s result
      if (runId !== latestRunId) return;

      if (!planError && planRow && planRow.plan === "pro") {
        lastKnownIsPro = true;
        setProUI();
      } else {
        lastKnownIsPro = false;
        setUpgradeUI();
      }
    } catch (e) {
      console.error("Error checking user plan", e);

      // ✅ NEW: if we *already* know they’re Pro, don’t pop Upgrade back in on a transient error
      if (lastKnownIsPro === true) {
        setProUI();
      } else {
        // Fail open: keep upgrade visible so user isn't blocked
        setUpgradeUI();
      }
    }
  }

  function scheduleCheck(delayMs) {
    clearTimeout(scheduleTimer);
    scheduleTimer = setTimeout(checkPlanOnLoad, delayMs || 0);
  }

  // run once now
  scheduleCheck(0);

  // run again shortly after load (covers “session restore” timing) — but without overlap
  scheduleCheck(300);

  // re-run whenever auth changes (sign in/out, session refresh)
  try {
    window.supabaseClient.auth.onAuthStateChange(() => {
      scheduleCheck(50);
    });
  } catch (e) {}
  /* ================================= SECTION 3 (END) ==================================== */



  /* =========================================================================================
     SECTION 4: Click handler for Upgrade (START)
  ========================================================================================= */
  if (!upgradeBtn) return;

  upgradeBtn.addEventListener("click", async () => {
    try {
      if (!window.supabaseClient) {
        alert("Auth system isn't loaded yet. Please refresh and try again.");
        return;
      }

      const { data, error } = await window.supabaseClient.auth.getUser();

      if (error || !data.user) {
        alert("Please sign in first before upgrading to Pro.");
        return;
      }

      const user = data.user;

      const originalText = upgradeBtn.textContent;
      upgradeBtn.disabled = true;
      upgradeBtn.textContent = "Opening checkout...";

      try {
        const res = await fetch("/api/create-checkout-session", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            userId: user.id,
            email: user.email
          })
        });

        if (!res.ok) {
          throw new Error("Network error: " + res.status);
        }

        const payload = await res.json();

        if (!payload.url) {
          throw new Error("No checkout URL returned");
        }

        window.location.href = payload.url;
      } catch (err) {
        console.error("Upgrade error", err);
        alert("Could not start checkout. Please try again in a moment.");

        upgradeBtn.disabled = false;
        upgradeBtn.textContent = originalText;
      }

    } catch (e) {
      console.error("Error checking auth before upgrade", e);
      alert("Could not verify your login. Please sign in again and try.");
    }
  });

  /* ================================= SECTION 4 (END) ==================================== */

});
/* ================================== SECTION 0 (END) ===================================== */
</script>



<script>
/* ===========================================================================================
   SECTION 0: Run after DOM loads (START)
   - We can safely query #upgradeButton and #proBadge here
=========================================================================================== */
document.addEventListener("DOMContentLoaded", () => {

  /* =========================================================================================
     SECTION 1: Grab elements (START)
     - upgradeBtn: the Upgrade button
     - proBadge: a "Pro" badge element
  ========================================================================================= */
  const upgradeBtn = document.getElementById("upgradeButton");
  const proBadge = document.getElementById("proBadge");
  /* ================================= SECTION 1 (END) ==================================== */



  /* =========================================================================================
     SECTION 2: Helpers (START)
     - setProUI(): hide upgrade button, show badge
     - setUpgradeUI(): show upgrade button, hide badge (optional)
  ========================================================================================= */
  function setProUI() {
    if (upgradeBtn) upgradeBtn.style.display = "none";
    if (proBadge) proBadge.style.display = "inline-block";
  }

  function setUpgradeUI() {
    if (upgradeBtn) upgradeBtn.style.display = "";
    if (proBadge) proBadge.style.display = "none";
  }
  /* ================================= SECTION 2 (END) ==================================== */



  /* =========================================================================================
     SECTION 3: Check plan (UPDATED) (START)
     Fix:
     - Billing check may run BEFORE OAuth session is set (async in another handler)
     - So we:
       1) retry if supabaseClient isn't ready yet
       2) re-check whenever auth state changes
  ========================================================================================= */
  async function checkPlanAndUpdateUI() {
    try {
      // If supabaseClient isn't available yet, retry shortly (non-blocking)
      if (!window.supabaseClient) {
        setTimeout(checkPlanAndUpdateUI, 80);
        return;
      }

      const { data, error } = await window.supabaseClient.auth.getUser();
      if (error || !data.user) {
        // Not logged in -> leave upgrade visible
        setUpgradeUI();
        return;
      }

      const user = data.user;

      // Look up plan by user_id (your current schema)
      const { data: planRow, error: planError } = await window.supabaseClient
        .from("user_plans")
        .select("plan")
        .eq("user_id", user.id)
        .maybeSingle();

      if (!planError && planRow && planRow.plan === "pro") {
        // ✅ Already Pro
        setProUI();
      } else {
        setUpgradeUI();
      }
    } catch (e) {
      console.error("Error checking user plan", e);
      // Fail open: keep upgrade visible so user isn't blocked
      setUpgradeUI();
    }
  }

  // Run once on load
  checkPlanAndUpdateUI();

  // Re-run whenever auth state changes (this fixes OAuth timing)
  try {
    if (window.supabaseClient && window.supabaseClient.auth && window.supabaseClient.auth.onAuthStateChange) {
      window.supabaseClient.auth.onAuthStateChange(() => {
        checkPlanAndUpdateUI();
      });
    }
  } catch (e) {
    // ignore
  }
  /* ================================= SECTION 3 (END) ==================================== */



  /* =========================================================================================
     SECTION 4: Click handler for Upgrade (START)
     What this does:
     1) Requires login (alerts if not logged in)
     2) Calls /api/create-checkout-session with userId + email
     3) Redirects browser to returned checkout URL
  ========================================================================================= */

  // If button isn't on the page, stop safely
  if (!upgradeBtn) return;

  upgradeBtn.addEventListener("click", async () => {
    /* ---- PART 4A: Require login (START) ---- */
    try {
      if (!window.supabaseClient) {
        alert("Auth system isn't loaded yet. Please refresh and try again.");
        return;
      }

      const { data, error } = await window.supabaseClient.auth.getUser();

      if (error || !data.user) {
        alert("Please sign in first before upgrading to Pro.");
        return;
      }

      const user = data.user;

      /* ---- PART 4B: Lock button + show loading text (START) ---- */
      const originalText = upgradeBtn.textContent;
      upgradeBtn.disabled = true;
      upgradeBtn.textContent = "Opening checkout...";
      /* ---- PART 4B (END) ---- */

      /* ---- PART 4C: Call your backend to create checkout session (START) ---- */
      try {
        const res = await fetch("/api/create-checkout-session", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            userId: user.id,
            email: user.email
          })
        });

        if (!res.ok) {
          throw new Error("Network error: " + res.status);
        }

        const payload = await res.json();

        if (!payload.url) {
          throw new Error("No checkout URL returned");
        }

        // Redirect to Stripe Checkout (or whatever URL your backend returns)
        window.location.href = payload.url;
      } catch (err) {
        console.error("Upgrade error", err);
        alert("Could not start checkout. Please try again in a moment.");

        // Restore button state
        upgradeBtn.disabled = false;
        upgradeBtn.textContent = originalText;
      }
      /* ---- PART 4C (END) ---- */

    } catch (e) {
      /* ---- PART 4D: Auth check failed unexpectedly (START) ---- */
      console.error("Error checking auth before upgrade", e);
      alert("Could not verify your login. Please sign in again and try.");
      /* ---- PART 4D (END) ---- */
    }
  });

  /* ================================= SECTION 4 (END) ==================================== */

});
/* ================================== SECTION 0 (END) ===================================== */
</script>




<!-- BLOCK: Make textareas grow --------------------------------------------------------------
--------------------------------------------------------------------------------------=----
===========================================================================================
===========================================================================================
------------------------------------------------------------------------------------------->

<script>
/* ===========================================================================================
   SECTION 0: Self-contained wrapper (START)
   - Keeps variables private
=========================================================================================== */
(function () {

  /* =========================================================================================
     SECTION 1: autoResize(ta) helper (START)
     What it does:
     - Sets height to "auto" so the browser can shrink it if text was removed
     - Then sets height to scrollHeight so it expands to fit all content
     - Hides the vertical scrollbar while it auto-grows
  ========================================================================================= */
  function autoResize(ta) {
    if (!ta) return;

    // Reset height so it can shrink if text got shorter
    ta.style.height = "auto";

    // Hide scrollbar while we control the height ourselves
    ta.style.overflowY = "hidden";

    // Expand to fit all text
    ta.style.height = ta.scrollHeight + "px";
  }
  /* ================================= SECTION 1 (END) ==================================== */



  /* =========================================================================================
     SECTION 2: Expose globally for other blocks (START)
     - Other scripts already call window.autoResizeTextarea(...)
     - So we keep the exact global name
  ========================================================================================= */
  window.autoResizeTextarea = autoResize;
  /* ================================= SECTION 2 (END) ==================================== */



  /* =========================================================================================
     SECTION 3: Wire up all textareas on DOMContentLoaded (START)
     - Finds all <textarea> elements
     - Resizes them immediately
     - Resizes again anytime the user types
  ========================================================================================= */
  document.addEventListener("DOMContentLoaded", () => {
    const textareas = document.querySelectorAll("textarea");

    textareas.forEach((ta) => {
      // Initial resize on page load (handles saved content too)
      autoResize(ta);

      // Resize every time user types
      ta.addEventListener("input", () => autoResize(ta));
    });
  });
  /* ================================= SECTION 3 (END) ==================================== */

})(); // end IIFE
/* ================================== SECTION 0 (END) ===================================== */
</script>



<!-- BLOCK: Copy icon for Snap textbox -------------------------------------------------------
--------------------------------------------------------------------------------------=----
===========================================================================================
===========================================================================================
------------------------------------------------------------------------------------------->

<script>
/* ===========================================================================================
   SECTION 0: Run after DOM loads (START)
=========================================================================================== */
document.addEventListener("DOMContentLoaded", () => {

  /* =========================================================================================
     SECTION 1: Grab elements (START)
     - copySnapTextBtn: the copy button next to the Snap textbox
     - snapText: the textarea that contains the text to copy
     - labelSpan: optional span inside the button that shows "Copy" / "Copied!"
  ========================================================================================= */
  const copySnapTextBtn = document.getElementById("copySnapTextBtn");
  const snapText = document.getElementById("snapText");

  // If either element is missing, exit safely (no errors)
  if (!copySnapTextBtn || !snapText) return;

  const labelSpan = copySnapTextBtn.querySelector(".copy-label");
  /* ================================= SECTION 1 (END) ==================================== */



  /* =========================================================================================
     SECTION 2: Clipboard helper (START)
     Why this exists:
     - navigator.clipboard.writeText can fail on some browsers or if not HTTPS
     - This helper tries modern clipboard first, then falls back to execCommand("copy")
     NOTE:
     - We keep everything inside this block so IDs/classes don’t change.
  ========================================================================================= */
  async function copyTextToClipboardSafe(text) {
    const value = String(text || "");

    // 1) Modern clipboard API (best)
    if (navigator.clipboard && navigator.clipboard.writeText) {
      await navigator.clipboard.writeText(value);
      return;
    }

    // 2) Fallback for older browsers
    const ta = document.createElement("textarea");
    ta.value = value;
    ta.style.position = "fixed";
    ta.style.opacity = "0";
    document.body.appendChild(ta);
    ta.select();

    const ok = document.execCommand("copy");
    document.body.removeChild(ta);

    if (!ok) {
      throw new Error("execCommand copy failed");
    }
  }
  /* ================================= SECTION 2 (END) ==================================== */



  /* =========================================================================================
     SECTION 3: Click handler (START)
     - Copies snapText.value to clipboard
     - Temporarily changes the label to "Copied!" then restores it
  ========================================================================================= */
  copySnapTextBtn.addEventListener("click", async () => {
    try {
      await copyTextToClipboardSafe(snapText.value || "");

      // Update button label (if it exists)
      if (labelSpan) {
        const old = labelSpan.textContent;
        labelSpan.textContent = "Copied!";
        setTimeout(() => {
          labelSpan.textContent = old;
        }, 1200);
      }
    } catch (err) {
      console.error("Copy failed", err);
    }
  });
  /* ================================= SECTION 3 (END) ==================================== */

});
/* ================================== SECTION 0 (END) ===================================== */
</script>


<!-- BLOCK: OCR buttons dropdown menu --------------------------------------------------------
--------------------------------------------------------------------------------------=----
===========================================================================================
===========================================================================================
------------------------------------------------------------------------------------------->

<script>
/* ===========================================================================================
   SECTION 0: Run after DOM loads (START)
=========================================================================================== */
document.addEventListener("DOMContentLoaded", () => {

  /* =========================================================================================
     SECTION 1: Grab elements (START)
     - toggle = the button that opens/closes the menu
     - menu   = the dropdown menu container
  ========================================================================================= */
  const toggle = document.getElementById("snapActionsToggle");
  const menu = document.getElementById("snapActionsMenu");

  // If either element is missing, exit safely
  if (!toggle || !menu) return;
  /* ================================= SECTION 1 (END) ==================================== */



  /* =========================================================================================
     SECTION 2: Helpers (START)
     - isMenuOpen(): returns true if menu is currently visible
     - openMenu(): show it
     - closeMenu(): hide it
     - toggleMenu(): flip between open/closed
     IMPORTANT:
     - Your original code relied on menu.style.display being "block" or "none".
       We keep that behavior to avoid breaking anything.
  ========================================================================================= */
  function isMenuOpen() {
    return menu.style.display === "block";
  }

  function openMenu() {
    menu.style.display = "block";
  }

  function closeMenu() {
    menu.style.display = "none";
  }

  function toggleMenu() {
    if (isMenuOpen()) {
      closeMenu();
    } else {
      openMenu();
    }
  }
  /* ================================= SECTION 2 (END) ==================================== */



  /* =========================================================================================
     SECTION 3: Toggle click handler (START)
     - stopPropagation prevents the document click handler from immediately closing it
     - toggles the menu open/closed
  ========================================================================================= */
  toggle.addEventListener("click", (e) => {
    e.stopPropagation();
    toggleMenu();
  });
  /* ================================= SECTION 3 (END) ==================================== */



  /* =========================================================================================
     SECTION 4: Close menu when clicking outside (START)
     - If the click is NOT inside the menu AND NOT on the toggle button, close it
  ========================================================================================= */
  document.addEventListener("click", (e) => {
    const clickedInsideMenu = menu.contains(e.target);
    const clickedToggle = toggle.contains(e.target);

    if (!clickedInsideMenu && !clickedToggle) {
      closeMenu();
    }
  });
  /* ================================= SECTION 4 (END) ==================================== */

});
/* ================================== SECTION 0 (END) ===================================== */
</script>



<!-- BLOCK: Close header dropdown after clicking a menu item --------------------------------
--------------------------------------------------------------------------------------=----
===========================================================================================
===========================================================================================
------------------------------------------------------------------------------------------->

<script>
/* ===========================================================================================
   SECTION 0: Run after DOM loads (START)
=========================================================================================== */
document.addEventListener("DOMContentLoaded", () => {

  /* =========================================================================================
     SECTION 1: Find the header menu container (START)
     - menu  = the outer header menu wrapper
     - inner = the clickable area inside the menu (where buttons/chips live)
  ========================================================================================= */
  const menu = document.querySelector(".header-menu");
  if (!menu) return;

  const inner = menu.querySelector(".header-menu-inner");
  if (!inner) return;
  /* ================================= SECTION 1 (END) ==================================== */



  /* =========================================================================================
     SECTION 2: Click handler (event delegation) (START)
     What it does:
     - Listens for ANY click inside .header-menu-inner
     - Checks if the click happened on (or inside) a button or .chip element
     - If yes, finds the nearest <details> ancestor and closes it
     Why event delegation:
     - Works even if buttons/chips are added later
  ========================================================================================= */
  inner.addEventListener("click", (e) => {

    // Find the nearest element that counts as a "menu item" click target
    const clickable = e.target.closest("button, .chip");
    if (!clickable) return;

    // Find the closest <details> element that contains the clicked item
    const details = clickable.closest("details");
    if (!details) return;

    // Close the dropdown by removing the "open" attribute
    details.removeAttribute("open");
  });
  /* ================================= SECTION 2 (END) ==================================== */

});
/* ================================== SECTION 0 (END) ===================================== */
</script>




<!-- BLOCK: Text actions dropdown (Solve / Math / Study / Essay / Flashcards) -----------------
--------------------------------------------------------------------------------------=----
===========================================================================================
===========================================================================================
------------------------------------------------------------------------------------------->

<script>
/* ===========================================================================================
   SECTION 0: Grab elements (START)
   - textActionsToggle: the button that opens/closes the dropdown
   - textActionsMenu:   the dropdown menu container
=========================================================================================== */
const textActionsToggle = document.getElementById("textActionsToggle");
const textActionsMenu   = document.getElementById("textActionsMenu");
/* ================================= SECTION 0 (END) ===================================== */


/* ===========================================================================================
   SECTION 1: Only initialize if both elements exist (START)
   - Prevents errors if this menu isn't on a page/layout
=========================================================================================== */
if (textActionsToggle && textActionsMenu) {

  /* =========================================================================================
     SECTION 2: Menu open/close helpers (START)
     NOTE:
     - Your original code controls visibility with inline style.display.
       We keep that exact behavior: "block" means open, "none" means closed.
  ========================================================================================= */
  function isMenuOpen() {
    return textActionsMenu.style.display === "block";
  }

  function openMenu() {
    textActionsMenu.style.display = "block";
  }

  function closeMenu() {
    textActionsMenu.style.display = "none";
  }

  function toggleMenu() {
    if (isMenuOpen()) {
      closeMenu();
    } else {
      openMenu();
    }
  }
  /* ================================= SECTION 2 (END) ==================================== */



  /* =========================================================================================
     SECTION 3: Toggle button click (START)
     - stopPropagation prevents the document click handler from immediately closing it
     - toggles open/close
  ========================================================================================= */
  textActionsToggle.addEventListener("click", (e) => {
    e.stopPropagation();
    toggleMenu();
  });
  /* ================================= SECTION 3 (END) ==================================== */



  /* =========================================================================================
     SECTION 4: Close when any button inside the menu is clicked (START)
     - This does NOT stop the button's normal click handler.
     - It only hides the menu immediately.
  ========================================================================================= */
  textActionsMenu.addEventListener("click", (e) => {
    const btn = e.target.closest("button");
    if (!btn) return;

    closeMenu();
    // let the existing click handler for that button run as normal
  });
  /* ================================= SECTION 4 (END) ==================================== */



  /* =========================================================================================
     SECTION 5: Close when clicking outside (START)
     - If click is not inside menu AND not inside toggle button -> close
  ========================================================================================= */
  document.addEventListener("click", (e) => {
    const clickedInsideMenu = textActionsMenu.contains(e.target);
    const clickedToggle = textActionsToggle.contains(e.target);

    if (!clickedInsideMenu && !clickedToggle) {
      closeMenu();
    }
  });
  /* ================================= SECTION 5 (END) ==================================== */

}
/* ================================== SECTION 1 (END) ===================================== */
</script>

<!-- BLOCK: Notebook dropdowns (auto-close after choosing an item) ----------------------------
--------------------------------------------------------------------------------------=----
===========================================================================================
===========================================================================================
------------------------------------------------------------------------------------------->

<script>
/* ===========================================================================================
   SECTION 0: Run after DOM loads (START)
   - Ensures .nb-dropdown elements exist before we query them
=========================================================================================== */
document.addEventListener("DOMContentLoaded", () => {

  /* =========================================================================================
     SECTION 1: Find all notebook dropdowns (START)
     - Assumes each dropdown is a <details class="nb-dropdown"> ... </details>
     - We keep the same class name so nothing breaks
  ========================================================================================= */
  const dropdowns = document.querySelectorAll(".nb-dropdown");
  /* ================================= SECTION 1 (END) ==================================== */



  /* =========================================================================================
     SECTION 2: For each dropdown, close it when a menu button is chosen (START)
     How it works:
     - Listen for clicks inside the dropdown
     - If the click is on a <button> that is NOT the toggle button,
       then close the <details> by removing the "open" attribute
  ========================================================================================= */
  dropdowns.forEach((dd) => {
    dd.addEventListener("click", (e) => {
      // Find the nearest button that was clicked (or inside what was clicked)
      const btn = e.target.closest("button");
      if (!btn) return;

      // If user clicked the toggle button, don't close (they’re opening/closing it)
      if (btn.classList.contains("nb-dropdown-toggle")) return;

      // Otherwise, user chose a menu item -> close the dropdown
      dd.removeAttribute("open");
    });
  });
  /* ================================= SECTION 2 (END) ==================================== */

});
/* ================================== SECTION 0 (END) ===================================== */
</script>

<!-- BLOCK: Autofill subject from OCR (Snap text -> saveSubjectInput) ------------------------
--------------------------------------------------------------------------------------=----
===========================================================================================
===========================================================================================
------------------------------------------------------------------------------------------->

<script>
/* ===========================================================================================
   SECTION 0: Helper that extracts a "heading" from OCR text (START)
   - Goal: take the first meaningful line and make it a safe short subject
=========================================================================================== */
function extractHeadingFromOcrText(ocrText) {
  if (!ocrText) return "";

  /* ---- PART 0A: Split into lines + clean them (START) ---- */
  const lines = String(ocrText)
    .split(/\r?\n/)               // split into lines
    .map((line) => line.trim())   // trim each line
    .filter(Boolean);             // remove empty lines
  /* ---- PART 0A (END) ---- */

  if (!lines.length) return "";

  /* ---- PART 0B: Use the first non-empty line (START) ---- */
  let first = lines[0];

  // Normalize whitespace (turn multiple spaces into one)
  first = first.replace(/\s+/g, " ");
  /* ---- PART 0B (END) ---- */

  /* ---- PART 0C: Cap length so it doesn’t get huge (START) ---- */
  const MAX_LEN = 80;
  if (first.length > MAX_LEN) {
    first = first.slice(0, MAX_LEN - 3) + "...";
  }
  /* ---- PART 0C (END) ---- */

  return first;
}
/* ================================= SECTION 0 (END) ===================================== */


/* ===========================================================================================
   SECTION 1: initAutoSubjectFromSnap() (START)
   What it does:
   - Watches #snapText input changes
   - Automatically fills #saveSubjectInput with a heading (first OCR line)
   - BUT stops overwriting once the user has typed their own subject
=========================================================================================== */
function initAutoSubjectFromSnap() {

  /* ---- PART 1A: Grab elements (START) ---- */
  const snapTextEl = document.getElementById("snapText");
  const subjectEl  = document.getElementById("saveSubjectInput");
  if (!snapTextEl || !subjectEl) return;
  /* ---- PART 1A (END) ---- */


  /* ---- PART 1B: Track whether the user edited the subject (START) ---- */
  let userEditedSubject = false;

  // If user types a real subject (not blank, not "general"), stop auto-fill
  subjectEl.addEventListener("input", () => {
    const v = (subjectEl.value || "").trim();

    if (v && v.toLowerCase() !== "general") {
      userEditedSubject = true;
    } else if (!v) {
      // If they clear it completely, allow auto-fill again
      userEditedSubject = false;
    }
  });
  /* ---- PART 1B (END) ---- */


  /* =========================================================================================
     SECTION 2: maybeAutoFillSubject() (START)
     - Only fills when userEditedSubject is false
     - Pulls a heading from snap text and writes it into saveSubjectInput
  ========================================================================================= */
  function maybeAutoFillSubject() {
    if (userEditedSubject) return;

    const heading = extractHeadingFromOcrText(snapTextEl.value || "");
    if (heading) {
      subjectEl.value = heading;

      // OPTIONAL: if you want other listeners to react, you could dispatch input:
      // subjectEl.dispatchEvent(new Event("input"));
      // (Leaving it off to avoid unexpected side effects.)
    }
  }
  /* ================================= SECTION 2 (END) ==================================== */


  /* =========================================================================================
     SECTION 3: Wire auto-fill to Snap text changes (START)
     - Anytime OCR fills in snapText, it triggers an "input" event in your other blocks
     - Also covers user paste/type
  ========================================================================================= */
  snapTextEl.addEventListener("input", () => {
    maybeAutoFillSubject();
  });
  /* ================================= SECTION 3 (END) ==================================== */


  /* =========================================================================================
     SECTION 4: Run once on load (START)
     - If snapText already has saved text (from persistence), fill subject immediately
  ========================================================================================= */
  maybeAutoFillSubject();
  /* ================================= SECTION 4 (END) ==================================== */


  /* =========================================================================================
     SECTION 5: Expose helpers globally (START)
     - Other blocks already reference these names sometimes
     - So we keep both names pointing at the same function
  ========================================================================================= */
  window.maybeAutoFillSubjectFromOcr = maybeAutoFillSubject;
  window.maybeFillSubjectFromOcrNow = maybeAutoFillSubject;
  /* ================================= SECTION 5 (END) ==================================== */
}
/* ================================== SECTION 1 (END) ===================================== */


/* ===========================================================================================
   SECTION 6: Initialize on DOMContentLoaded (START)
=========================================================================================== */
document.addEventListener("DOMContentLoaded", initAutoSubjectFromSnap);
/* ================================== SECTION 6 (END) ===================================== */
</script>


<!-- BLOCK: Extract Notes tool (Snap -> Notes tab + Notebook save) ---------------------------
--------------------------------------------------------------------------------------=----
===========================================================================================
===========================================================================================
------------------------------------------------------------------------------------------->

<script>
/* ===========================================================================================
   SECTION 0: AI helper for Extract Notes (START)
   - This becomes a GLOBAL function so other scripts can call it if needed:
       window.runExtractNotes(text)
   - It uses your existing callAI() function (from BLOCK 3)
=========================================================================================== */
window.runExtractNotes = async function runExtractNotes(text) {
  const cheat = !!window.__cheatMode; // false = learn mode, true = cheat mode

  // Always work with a safe string
  const cleanedText = String(text || "").trim();
  if (!cleanedText) return "";

  /* ---- PART 0A: Build prompts (START) ---- */
  const basePrompt =
    "You are helping a student turn messy homework/textbook text into short, high-yield notes.\n" +
    "From the text below, extract ONLY the most important points as a bullet list.\n" +
    "- Prefer short bullets\n" +
    "- Focus on key facts, definitions, steps, formulas, dates, and names\n" +
    "- Do NOT rewrite the whole passage\n" +
    "- Return plain text only. Use '-' or '•' at the start of each bullet.\n\n" +
    "Text:\n" +
    cleanedText;

  const cheatPrompt =
    "From this text, return ONLY the most important bullet-point notes.\n" +
    "Make 5–20 very short bullets. No intro, no conclusion.\n\n" +
    "Text:\n" +
    cleanedText;

  const prompt = cheat ? cheatPrompt : basePrompt;
  /* ---- PART 0A (END) ---- */

  /* ---- PART 0B: Call backend via callAI (START) ---- */
  if (typeof callAI !== "function") {
    // If BLOCK 3 isn't loaded, fail safely with a helpful message
    return "⚠️ callAI() is not defined. Make sure BLOCK 3 (AI backend call) loads before this block.";
  }

  const result = await callAI({
    prompt,
    task: "extract_notes" // backend task name (you can keep or change server-side)
  });

  return typeof result === "string" ? result : String(result ?? "");
  /* ---- PART 0B (END) ---- */
};
/* ================================= SECTION 0 (END) ===================================== */


/* ===========================================================================================
   SECTION 1: Wire UI on DOMContentLoaded (START)
   - Uses existing IDs (DO NOT CHANGE):
       #snapText, #notesInput, #notesResult, #notesBtn, #notesClearBtn
=========================================================================================== */
document.addEventListener("DOMContentLoaded", () => {

  /* =========================================================================================
     SECTION 2: Grab elements (START)
  ========================================================================================= */
  const snapText    = document.getElementById("snapText");
  const notesInput  = document.getElementById("notesInput");
  const notesResult = document.getElementById("notesResult");
  const notesBtn    = document.getElementById("notesBtn");
  const notesClear  = document.getElementById("notesClearBtn");

  if (!snapText || !notesInput || !notesResult || !notesBtn) {
    console.warn("[Extract Notes] Missing elements; not wired up.");
    return;
  }

  // Guard: don’t double-wire if this script accidentally runs twice
  if (notesBtn.dataset && notesBtn.dataset.notesWired === "1") return;
  if (notesBtn.dataset) notesBtn.dataset.notesWired = "1";
  /* ================================= SECTION 2 (END) ==================================== */



  /* =========================================================================================
     SECTION 3: Local loading animation for notesResult (START)
     Why we do this:
     - In your other block, startResultLoading/stopResultLoading are scoped locally,
       so they are NOT available here.
     - This is a safe self-contained loading indicator that won’t break anything.
  ========================================================================================= */
  function startNotesLoading(baseText) {
    const label = baseText || "Finding key points";

    // Stop any previous loading interval first
    stopNotesLoading();

    let dotCount = 0;
    const maxDots = 3;

    notesResult.textContent = label;
    const id = setInterval(() => {
      dotCount = (dotCount + 1) % (maxDots + 1);
      notesResult.textContent = label + ".".repeat(dotCount);
    }, 400);

    // Store interval id on the element so we can stop it later
    notesResult.dataset.loadingIntervalId = String(id);
  }

  function stopNotesLoading() {
    const id = notesResult.dataset.loadingIntervalId;
    if (id) {
      clearInterval(Number(id));
      delete notesResult.dataset.loadingIntervalId;
    }
  }
  /* ================================= SECTION 3 (END) ==================================== */



  /* =========================================================================================
     SECTION 4: Main "Extract Notes" button click (START)
     What happens:
     1) Read Snap text
     2) Copy to notesInput (so the Notes tab shows same source text)
     3) Switch tab to "notes"
     4) Run usage limiter
     5) Call AI and render result
     6) Save to Notebook as type "Notes"
  ========================================================================================= */
  notesBtn.addEventListener("click", async () => {

    /* ---- PART 4A: Read Snap text (START) ---- */
    const text = (snapText.value || "").trim();
    if (!text) {
      alert("Paste or OCR some text into the main Snap box first.");
      return;
    }
    /* ---- PART 4A (END) ---- */

    /* ---- PART 4B: Copy into notesInput + switch tab (START) ---- */
    notesInput.value = text;

    if (typeof activateTab === "function") {
      activateTab("notes");
    }
    /* ---- PART 4B (END) ---- */

    /* ---- PART 4C: Usage limiter (START) ---- */
    if (window.__canUseAIOnce) {
      const allowed = await window.__canUseAIOnce();
      if (!allowed) return;
    } else if (window.__canUseAIOnceAnon && !window.__canUseAIOnceAnon()) {
      return;
    }
    /* ---- PART 4C (END) ---- */

    /* ---- PART 4D: Loading + AI call (START) ---- */
    startNotesLoading("Finding key points");

    try {
      const raw = await window.runExtractNotes(text);

      stopNotesLoading();

      // IMPORTANT: do NOT run sanitizeAnswerText here because it would remove bullet lines
      const clean = String(raw || "").trim();

      // Render with your styled output helper if available
      if (typeof renderAnswer === "function") {
        renderAnswer(notesResult, clean);
      } else {
        notesResult.textContent = clean;
      }

      // Save to Notebook
      if (typeof addNotebookItem === "function") {
        addNotebookItem("Notes", clean);
      }
    } catch (err) {
      console.error("[Extract Notes] error:", err);
      stopNotesLoading();
      notesResult.textContent = "⚠️ Error extracting notes: " + (err && err.message ? err.message : String(err));
    }
    /* ---- PART 4D (END) ---- */
  });
  /* ================================= SECTION 4 (END) ==================================== */



  /* =========================================================================================
     SECTION 5: Clear button inside Notes tool (START)
     - Clears the Notes tool textarea + output
  ========================================================================================= */
  if (notesClear) {
    notesClear.addEventListener("click", () => {
      notesInput.value = "";
      notesResult.textContent = "";
    });
  }
  /* ================================= SECTION 5 (END) ==================================== */

});
/* ================================== SECTION 1 (END) ===================================== */
</script>





<!-- BLOCK: OCR button behavior (close dropdown + scroll to Snap textbox) --------------------
--------------------------------------------------------------------------------------=----
===========================================================================================
===========================================================================================
------------------------------------------------------------------------------------------->

<script>
/* ===========================================================================================
   SECTION 0: Run after DOM loads (START)
=========================================================================================== */
document.addEventListener("DOMContentLoaded", () => {

  /* =========================================================================================
     SECTION 1: Grab elements (START)
     - snapOCRBtn: button that triggers OCR
     - snapText: the textarea we want to scroll to
     - snapActionsMenu: the dropdown menu we want to close (optional)
  ========================================================================================= */
  const snapOCRBtn      = document.getElementById("snapOCRBtn");
  const snapText        = document.getElementById("snapText");
  const snapActionsMenu = document.getElementById("snapActionsMenu");

  // If OCR button or textbox is missing, exit safely
  if (!snapOCRBtn || !snapText) return;
  /* ================================= SECTION 1 (END) ==================================== */



  /* =========================================================================================
     SECTION 2: Click handler (START)
     What it does:
     1) Close the image actions dropdown (if it exists)
     2) Smooth-scroll to the Snap textbox
  ========================================================================================= */
  snapOCRBtn.addEventListener("click", () => {

    /* ---- PART 2A: Close dropdown (START) ---- */
    if (snapActionsMenu) {
      snapActionsMenu.style.display = "none";
    }
    /* ---- PART 2A (END) ---- */


    /* ---- PART 2B: Smooth scroll to Snap textbox (START) ----
       Why the small timeout:
       - Lets the menu close first so layout is stable before scrolling
    */
    setTimeout(() => {
      snapText.scrollIntoView({
        behavior: "smooth",
        block: "center"
      });
    }, 50);
    /* ---- PART 2B (END) ---- */

  });
  /* ================================= SECTION 2 (END) ==================================== */

});
/* ================================== SECTION 0 (END) ===================================== */
</script>





<!-- BLOCK: Output format controls (Plain / MLA / APA / Chicago / IEEE) -----------------------
--------------------------------------------------------------------------------------=----
===========================================================================================
===========================================================================================
------------------------------------------------------------------------------------------->

<script>
/* ===========================================================================================
   SECTION 0: Format templates (START)
   - OUTPUT_FORMATTERS is a "map" (dictionary) of formatter functions
   - Each formatter takes plain text and returns formatted text
=========================================================================================== */
const OUTPUT_FORMATTERS = {

  /* ---- PART 0A: Plain (no change) (START) ---- */
  plain: function (text) {
    return String(text || "");
  },
  /* ---- PART 0A (END) ---- */


  /* ---- PART 0B: MLA template (START) ---- */
  mla: function (text) {
    return [
      "Your Name",
      "Professor Lastname",
      "Course Name",
      "Day Month Year",
      "",
      "(Double-spaced, Times New Roman 12, 1\" margins when you paste into Word/Docs.)",
      "",
      String(text || "")
    ].join("\n");
  },
  /* ---- PART 0B (END) ---- */


  /* ---- PART 0C: APA template (START) ---- */
  apa: function (text) {
    return [
      "Title of Paper",
      "",
      "Your Name",
      "Department, University Name",
      "Course Name and Number",
      "Instructor Name",
      "Due Date",
      "",
      "(APA 7 student paper – double-spaced, 1\" margins, page number in header.)",
      "",
      String(text || "")
    ].join("\n");
  },
  /* ---- PART 0C (END) ---- */


  /* ---- PART 0D: Chicago template (START) ---- */
  chicago: function (text) {
    return [
      "Title of Paper",
      "",
      "Your Name",
      "",
      "(Chicago / Turabian – set 1\" margins, double-space, and add notes/bibliography in your doc.)",
      "",
      String(text || "")
    ].join("\n");
  },
  /* ---- PART 0D (END) ---- */


  /* ---- PART 0E: IEEE template (START) ---- */
  ieee: function (text) {
    return [
      "Paper Title",
      "",
      "Author Name, Department, University",
      "",
      "(IEEE – usually two-column layout, numbered references; adjust in your editor.)",
      "",
      String(text || "")
    ].join("\n");
  }
  /* ---- PART 0E (END) ---- */

};
/* ================================= SECTION 0 (END) ===================================== */


/* ===========================================================================================
   SECTION 1: setupOutputFormatControls() (START)
   What this does:
   - Finds every button with class ".output-format-apply"
   - When clicked:
       1) Finds target output element by id from data-target
       2) Finds matching select ".output-format-select" with same data-target
       3) Formats the output text using the chosen format
   IMPORTANT NOTE (compatibility with your app):
   - Some of your outputs use renderAnswer(), which replaces the element’s innerHTML.
   - Because of that, .textContent may include extra UI text like "Copy".
   - So we prefer to use dataset.plainText when available (your renderAnswer sets it).
=========================================================================================== */
function setupOutputFormatControls() {

  /* ---- PART 1A: Find all apply buttons (START) ---- */
  const applyButtons = document.querySelectorAll(".output-format-apply");
  /* ---- PART 1A (END) ---- */


  /* ---- PART 1B: Wire click handler for each button (START) ---- */
  applyButtons.forEach(function (btn) {

    btn.addEventListener("click", function () {

      /* =============================================================================
         STEP 1: Find which output element we’re formatting (by id)
      ============================================================================= */
      const targetId = btn.getAttribute("data-target");
      if (!targetId) return;

      const outputEl = document.getElementById(targetId);
      if (!outputEl) return;

      /* =============================================================================
         STEP 2: Find the select dropdown that chooses the format
         - It must have: class="output-format-select"
         - And: data-target="same targetId"
      ============================================================================= */
      const select = document.querySelector(
        '.output-format-select[data-target="' + targetId + '"]'
      );
      if (!select) return;

      /* =============================================================================
         STEP 3: Decide which formatter to use
      ============================================================================= */
      const formatKey = select.value || "plain";
      const formatter =
        OUTPUT_FORMATTERS[formatKey] || OUTPUT_FORMATTERS.plain;

      /* =============================================================================
         STEP 4: Get the *clean* current text
         FIX:
         - If this is essayResult, pull the CURRENT text from the student's text box
           so it never uses old cached output.
         - Otherwise behave exactly like before.
      ============================================================================= */
      let currentTxt = "";

      if (targetId === "essayResult") {
        // Prefer #essayInput if it exists, otherwise use #snapText (your main box)
        const essayTa = document.getElementById("essayInput");
        const snapTa  = document.getElementById("snapText");

        currentTxt =
          (essayTa && essayTa.value ? essayTa.value : "") ||
          (snapTa && snapTa.value ? snapTa.value : "");

      } else {
        currentTxt =
          (outputEl.dataset && outputEl.dataset.plainText) ||
          outputEl.textContent ||
          "";
      }

      /* =============================================================================
         STEP 5: Capture the original text
         FIX:
         - For essayResult, ALWAYS refresh originalText (so it never stays stuck on old text)
         - For other outputs, keep your original behavior (capture once)
      ============================================================================= */
      if (targetId === "essayResult") {
        if (outputEl.dataset) outputEl.dataset.originalText = String(currentTxt || "");
      } else {
        if (
          (!outputEl.dataset.originalText || !outputEl.dataset.originalText.trim()) &&
          String(currentTxt).trim()
        ) {
          outputEl.dataset.originalText = String(currentTxt);
        }
      }

      /* =============================================================================
         STEP 6: Choose base text
         FIX:
         - For essayResult, base is ALWAYS the current text box text (no caching)
         - For other outputs, keep your original behavior
      ============================================================================= */
      const base =
        (targetId === "essayResult")
          ? String(currentTxt)
          : ((outputEl.dataset.originalText && outputEl.dataset.originalText.trim())
              ? outputEl.dataset.originalText
              : String(currentTxt));

      /* =============================================================================
         STEP 7: Apply formatting
         IMPORTANT:
         - If this output element is normally styled by renderAnswer(),
           we should re-render with renderAnswer so the Copy button stays.
         - If renderAnswer isn't available, we just set textContent.
      ============================================================================= */
      const formatted = formatter(base);

      if (typeof renderAnswer === "function") {
        // Keep the styled container + copy button
        renderAnswer(outputEl, formatted);
      } else {
        // Plain fallback
        outputEl.textContent = formatted;
      }

    });

  });
  /* ---- PART 1B (END) ---- */

}
/* ================================= SECTION 1 (END) ===================================== */



/* ===========================================================================================
   SECTION 2: Run on load (START)
   - If DOM is still loading, wait for DOMContentLoaded
   - Otherwise run immediately
=========================================================================================== */
if (document.readyState === "loading") {
  document.addEventListener("DOMContentLoaded", setupOutputFormatControls);
} else {
  setupOutputFormatControls();
}
/* ================================= SECTION 2 (END) ===================================== */
</script>



<!-- BLOCK PG METRICS: Sticky loop, progress pills, mobile toggles ---------------------------
--------------------------------------------------------------------------------------=----
===========================================================================================
===========================================================================================
------------------------------------------------------------------------------------------->

<script>
/* ===========================================================================================
   SECTION 0: Self-contained wrapper (START)
   - Keeps variables private
=========================================================================================== */
(function () {

  /* =========================================================================================
     SECTION 1: onReady helper (START)
     - Runs your init code after DOM is ready
  ========================================================================================= */
  function onReady(fn) {
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", fn);
    } else {
      fn();
    }
  }
  /* ================================= SECTION 1 (END) ==================================== */



  /* =========================================================================================
     SECTION 2: Initialize all PG metrics features (START)
     - Sticky loop rotator
     - Progress metrics (streak + weekly active + sessions)
     - Mobile toggle wiring
  ========================================================================================= */
  onReady(function () {
    setupStickyLoop();
    setupProgressMetrics();
    wireMobileToggles();
  });
  /* ================================= SECTION 2 (END) ==================================== */



  /* =========================================================================================
     SECTION 3: Sticky loop rotator (START)
     - Looks for containers with [data-sticky-loop]
     - Inside each container it looks for #pg-loop-metrics-rotator
     - Rotates children with class ".pg-loop-item"
     IMPORTANT FIX:
     - Prevents multiple intervals if this script runs more than once
       (stores interval id on the container)
  ========================================================================================= */
  function setupStickyLoop() {
    var containers = document.querySelectorAll("[data-sticky-loop]");

    containers.forEach(function (container) {
      var rotator = container.querySelector("#pg-loop-metrics-rotator");
      if (!rotator) return;

      var items = Array.from(rotator.querySelectorAll(".pg-loop-item"));
      if (items.length <= 1) return;

      // If we already started an interval for this container, don't start another one
      if (container.dataset && container.dataset.pgLoopIntervalId) return;

      var intervalMs = parseInt(
        container.getAttribute("data-loop-interval") || "6000",
        10
      );
      if (!intervalMs || intervalMs < 500) intervalMs = 6000; // safety

      var index = 0;

      // Make sure exactly one is active at start (optional safety)
      items.forEach(function (it, i) {
        it.classList.toggle("pg-loop-item--active", i === index);
      });

      var intervalId = setInterval(function () {
        items[index].classList.remove("pg-loop-item--active");
        index = (index + 1) % items.length;
        items[index].classList.add("pg-loop-item--active");
      }, intervalMs);

      // Store interval id so we don’t create duplicates
      container.dataset.pgLoopIntervalId = String(intervalId);
    });
  }
  /* ================================= SECTION 3 (END) ==================================== */



  /* =========================================================================================
     SECTION 4: Progress metrics (START)
     - Streak tracking: pg_last_visit + pg_streak
     - Weekly active days: pg_active_days (object of dates -> true)
     - Sessions this week: pg_sessions_this_week + pg_sessions_week_key
     - Writes results into:
         [data-pg-streak-value]
         [data-pg-weekly-summary]
         [data-pg-session-count]
  ========================================================================================= */
  function setupProgressMetrics() {
    try {
      var now = new Date();
      var todayKey = now.toISOString().slice(0, 10); // YYYY-MM-DD

      /* ---- PART 4A: Streak logic (START) ---- */
      var lastVisit = localStorage.getItem("pg_last_visit");
      var streakStr = localStorage.getItem("pg_streak") || "0";
      var streak = parseInt(streakStr, 10) || 0;

      if (!lastVisit) {
        streak = 1;
      } else if (lastVisit !== todayKey) {
        var lastDate = new Date(lastVisit + "T00:00:00");

        // difference in days, in UTC (so it works across timezones)
        var diff =
          (Date.UTC(now.getFullYear(), now.getMonth(), now.getDate()) -
            Date.UTC(
              lastDate.getFullYear(),
              lastDate.getMonth(),
              lastDate.getDate()
            )) /
          (1000 * 60 * 60 * 24);

        if (diff === 1) {
          streak += 1;
        } else if (diff > 1) {
          streak = 1; // streak broken
        }
      }

      localStorage.setItem("pg_last_visit", todayKey);
      localStorage.setItem("pg_streak", String(streak));
      /* ---- PART 4A (END) ---- */


      /* ---- PART 4B: Weekly active days (START) ---- */
      var activeDaysRaw = localStorage.getItem("pg_active_days");
      var activeDays = activeDaysRaw ? JSON.parse(activeDaysRaw) : {};
      activeDays[todayKey] = true;
      localStorage.setItem("pg_active_days", JSON.stringify(activeDays));

      var weeklyCount = countActiveDaysThisWeek(activeDays, now);
      /* ---- PART 4B (END) ---- */


      /* ---- PART 4C: Sessions this week (START) ---- */
      var sessionsRaw = localStorage.getItem("pg_sessions_this_week") || "0";
      var sessions = parseInt(sessionsRaw, 10) || 0;

      var weekKey = getWeekKey(now);
      var lastWeekKey = localStorage.getItem("pg_sessions_week_key");

      if (lastWeekKey !== weekKey) {
        sessions = 0; // new week -> reset
      }
      sessions += 1;

      localStorage.setItem("pg_sessions_this_week", String(sessions));
      localStorage.setItem("pg_sessions_week_key", weekKey);
      /* ---- PART 4C (END) ---- */


      /* ---- PART 4D: Write into the UI pills (START) ---- */
      var streakNode = document.querySelector("[data-pg-streak-value]");
      if (streakNode) {
  streakNode.textContent = streak === 1 ? "Checked in today" : `${streak}-day streak`;
}


      var weeklyNode = document.querySelector("[data-pg-weekly-summary]");
      if (weeklyNode) {
        weeklyNode.textContent =
          weeklyCount +
          " active day" +
          (weeklyCount === 1 ? "" : "s") +
          " this week";
      }

      var sessionsNode = document.querySelector("[data-pg-session-count]");
      if (sessionsNode) {
        sessionsNode.textContent =
          sessions + " session" + (sessions === 1 ? "" : "s");
      }
      /* ---- PART 4D (END) ---- */

    } catch (e) {
      // Fail silently; this is just for engagement
      console.warn("PassingGrade progress metrics error", e);
    }
  }
  /* ================================= SECTION 4 (END) ==================================== */



  /* =========================================================================================
     SECTION 5: Week helpers (START)
     - getWeekKey(): returns ISO-ish week key like "2025-W50"
     - countActiveDaysThisWeek(): counts Mon–Sun in activeDaysObj
  ========================================================================================= */
  function getWeekKey(date) {
    var d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
    var dayNum = d.getUTCDay() || 7; // 1-7 (Mon-Sun)
    d.setUTCDate(d.getUTCDate() + 4 - dayNum);
    var yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
    var weekNo = Math.ceil(((d - yearStart) / 86400000 + 1) / 7);
    return d.getUTCFullYear() + "-W" + weekNo;
  }

  function countActiveDaysThisWeek(activeDaysObj, now) {
    var count = 0;
    var today = new Date(Date.UTC(now.getFullYear(), now.getMonth(), now.getDate()));
    var dayNum = today.getUTCDay() || 7; // 1-7 (Mon-Sun)

    var monday = new Date(today);
    monday.setUTCDate(today.getUTCDate() - (dayNum - 1)); // back to Monday

    for (var i = 0; i < 7; i++) {
      var d = new Date(monday);
      d.setUTCDate(monday.getUTCDate() + i);
      var key = d.toISOString().slice(0, 10);
      if (activeDaysObj[key]) count++;
    }
    return count;
  }
  /* ================================= SECTION 5 (END) ==================================== */



  /* =========================================================================================
     SECTION 6: Mobile toggles wiring (START)
     - Wires sticky-loop buttons to trigger the original Menu/Tools buttons
     - Also wires a nav close button to close the menu + send Escape
     IMPORTANT FIX:
     - Adds "already wired" guards so repeated calls don’t add duplicate listeners
  ========================================================================================= */
  function wireMobileToggles() {
    var loopMenuButton = document.getElementById("pg-loop-menu-toggle");
    var loopToolsButton = document.getElementById("pg-loop-tools-toggle");
    var navCloseButton = document.getElementById("pg-nav-close");

    if (!loopMenuButton && !loopToolsButton && !navCloseButton) return;

    // Find existing Menu / Tools controls by text (keeps your current behavior)
    var allButtons = Array.prototype.slice.call(
      document.querySelectorAll("button, [role='button']")
    );

    var menuOriginal = findByText(allButtons, "Menu");
    var toolsOriginal = findByText(allButtons, "Tools");

    // Hide originals on mobile only via CSS hook class (no behavior change)
    [menuOriginal, toolsOriginal].forEach(function (el) {
      if (el && !el.classList.contains("pg-mobile-hide-original-toggle")) {
        el.classList.add("pg-mobile-hide-original-toggle");
      }
    });

    /* ---- PART 6A: Loop Menu -> click original Menu (START) ---- */
    if (loopMenuButton && menuOriginal) {
      if (!loopMenuButton.dataset.pgWired) {
        loopMenuButton.dataset.pgWired = "1";
        loopMenuButton.addEventListener("click", function () {
          menuOriginal.click();
        });
      }
    }
    /* ---- PART 6A (END) ---- */

    /* ---- PART 6B: Loop Tools -> click original Tools (START) ---- */
    if (loopToolsButton && toolsOriginal) {
      if (!loopToolsButton.dataset.pgWired) {
        loopToolsButton.dataset.pgWired = "1";
        loopToolsButton.addEventListener("click", function () {
          toolsOriginal.click();
        });
      }
    }
    /* ---- PART 6B (END) ---- */

    /* ---- PART 6C: Nav close button behavior (START) ---- */
    if (navCloseButton) {
      if (!navCloseButton.dataset.pgWired) {
        navCloseButton.dataset.pgWired = "1";
        navCloseButton.addEventListener("click", function () {

          // 1) Try to toggle whatever opens/closes the nav
          if (loopMenuButton) {
            loopMenuButton.click();
          } else if (menuOriginal) {
            menuOriginal.click();
          }

          // 2) Also fire Escape (some drawers/sheets listen for this)
          try {
            var escEvt = new KeyboardEvent("keydown", {
              key: "Escape",
              keyCode: 27,
              which: 27,
              bubbles: true
            });
            document.dispatchEvent(escEvt);
          } catch (e) {
            // ignore if KeyboardEvent fails
          }
        });
      }
    }
    /* ---- PART 6C (END) ---- */
  }
  /* ================================= SECTION 6 (END) ==================================== */



  /* =========================================================================================
     SECTION 7: findByText helper (START)
     - Finds the first node whose textContent contains the requested word
     IMPORTANT NOTE:
     - This keeps your original behavior, but it can match more than you expect
       (example: "Menu" might match "Menu Settings").
=========================================================================================== */
  function findByText(nodes, text) {
    text = String(text || "").toLowerCase();
    for (var i = 0; i < nodes.length; i++) {
      var t = (nodes[i].textContent || "").toLowerCase();
      if (t.indexOf(text) !== -1) return nodes[i];
    }
    return null;
  }
  /* ================================= SECTION 7 (END) ==================================== */

})(); // end IIFE
/* ================================== SECTION 0 (END) ===================================== */
</script>





<!-- BLOCK: Sticky loop "stuck" state watcher (adds/removes .pg-is-stuck) --------------------
--------------------------------------------------------------------------------------=----
===========================================================================================
===========================================================================================
------------------------------------------------------------------------------------------->

<script>
/* ===========================================================================================
   SECTION 0: Self-contained wrapper (START)
   - Keeps variables private
=========================================================================================== */
(function () {

  /* =========================================================================================
     SECTION 1: onReady helper (START)
     - Runs once the DOM is ready
  ========================================================================================= */
  function onReady(fn) {
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", fn);
    } else {
      fn();
    }
  }
  /* ================================= SECTION 1 (END) ==================================== */



  /* =========================================================================================
     SECTION 2: Initialize observer on ready (START)
  ========================================================================================= */
  onReady(function () {

    /* ---- PART 2A: Find elements (START) ---- */
    var header = document.querySelector("header");
    var sticky = document.getElementById("pg-sticky-loop-shell");
    if (!header || !sticky) return;
    /* ---- PART 2A (END) ---- */


    /* ---- PART 2B: Prevent double-wiring (START) ----
       - If this script is included twice, we don't want multiple observers.
       - We'll mark the sticky element as "wired".
    */
    if (sticky.dataset && sticky.dataset.pgStuckObserverWired === "1") return;
    if (sticky.dataset) sticky.dataset.pgStuckObserverWired = "1";
    /* ---- PART 2B (END) ---- */


    /* ---- PART 2C: Create the IntersectionObserver (START) ----
       What it does:
       - Watches the <header>
       - If header is visible -> sticky bar is NOT stuck
       - If header is not visible -> sticky bar IS stuck
    */
    var observer = new IntersectionObserver(
      function (entries) {
        entries.forEach(function (entry) {
          if (entry.isIntersecting) {
            // header visible -> not stuck
            sticky.classList.remove("pg-is-stuck");
          } else {
            // header scrolled off -> sticky bar is stuck
            sticky.classList.add("pg-is-stuck");
          }
        });
      },
      {
        threshold: 0
      }
    );
    /* ---- PART 2C (END) ---- */


    /* ---- PART 2D: Start observing (START) ---- */
    observer.observe(header);
    /* ---- PART 2D (END) ---- */

  });
  /* ================================= SECTION 2 (END) ==================================== */

})(); // end IIFE
/* ================================== SECTION 0 (END) ===================================== */
</script>


<!-- BLOCK: Global click-off close for dropdown menus (Snap actions + Text actions) ---------
--------------------------------------------------------------------------------------=----
===========================================================================================
===========================================================================================
------------------------------------------------------------------------------------------->

<script>
(function () {
  function onReady(fn) {
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", fn);
    } else {
      fn();
    }
  }

  onReady(() => {
    // Register dropdowns here: { toggle, menu, close() }
    const dropdowns = [];

    // 1) Snap actions dropdown
    const snapToggle = document.getElementById("snapActionsToggle");
    const snapMenu   = document.getElementById("snapActionsMenu");
    if (snapToggle && snapMenu) {
      dropdowns.push({
        toggle: snapToggle,
        menu: snapMenu,
        close: () => (snapMenu.style.display = "none"),
      });
    }

    // 2) Text actions dropdown
    const textToggle = document.getElementById("textActionsToggle");
    const textMenu   = document.getElementById("textActionsMenu");
    if (textToggle && textMenu) {
      dropdowns.push({
        toggle: textToggle,
        menu: textMenu,
        close: () => (textMenu.style.display = "none"),
      });
    }

    // Close on click outside (works for mouse + touch + pen)
    document.addEventListener("pointerdown", (e) => {
      dropdowns.forEach((d) => {
        const clickedInside =
          d.menu.contains(e.target) || d.toggle.contains(e.target);
        if (!clickedInside) d.close();
      });
    });

    // Close on Escape
    document.addEventListener("keydown", (e) => {
      if (e.key !== "Escape") return;
      dropdowns.forEach((d) => d.close());
    });
  });
})();
</script>


<!-- BLOCK: Click-off close for Notebook <details> dropdowns (Saved Subjects / filters) -----
--------------------------------------------------------------------------------------=----
===========================================================================================
===========================================================================================
------------------------------------------------------------------------------------------->

<script>
(function () {
  document.addEventListener("pointerdown", (e) => {
    document.querySelectorAll("details.nb-dropdown[open]").forEach((dd) => {
      if (!dd.contains(e.target)) {
        dd.removeAttribute("open");
      }
    });
  });

  document.addEventListener("keydown", (e) => {
    if (e.key !== "Escape") return;
    document.querySelectorAll("details.nb-dropdown[open]").forEach((dd) => {
      dd.removeAttribute("open");
    });
  });
})();
</script>




</body>
</html>
